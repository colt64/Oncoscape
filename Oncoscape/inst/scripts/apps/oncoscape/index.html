




<!DOCTYPE html> 
<html>

<head>
   <meta charset="UTF-8">
   <meta property="og:title" content="Oncoscape" />

   <title> OncoDev 1.4</title>

   <script src="http://code.jquery.com/qunit/qunit-1.18.0.js"></script>
   <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.18.0.css">

   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/jquery-2.1.3.min.js"></script>
   <!-- script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/jquery-1.11.2.min.js"></script-->
   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/jquery-ui-1.11.4.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.7/themes/smoothness/jquery-ui.css">

   <!-- script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/cytoscape-2.4.4.min.js"></script-->
   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/cytoscape-2.5.1.min.js"></script>

   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/jquery.cytoscape.js-panzoom.js"></script>
   <link   href="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/css/jquery.cytoscape.js-panzoom.css" 
           rel="stylesheet" 
           type="text/css">


   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/d3.min.js"></script>

   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/jquery.dataTables-1.10.5.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/css/jquery.dataTables-1.10.5.min.css">

   <script src="http://cdn.datatables.net/colvis/1.1.0/js/dataTable.colVis.js"></script>

   <link   rel="stylesheet" type="text/css"
           href="http://cdn.datatables.net/colvis/1.1.0/css/dataTables.colVis.css">

   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/jquery.multi-select.js" type="text/javascript"></script>
   <link href="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/css/multi-select.css" media="screen" rel="stylesheet" type="text/css">
   <script src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/js/chosen.jquery.min.js" type="text/javascript"></script>
   <link href="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/css/chosen.min.css" media="screen" rel="stylesheet" type="text/css">

    <link rel="SHORTCUT ICON" type="image/x-icon" href="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/favicon.ico"/>
    <link rel="ICON" type="image/x-icon" href="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/favicon.ico"/>


<script> 
//--------------------------------------------------------------------------------------------------
// hooks for google analytics

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-528883-29', 'auto');
  ga('send', 'pageview');
//--------------------------------------------------------------------------------------------------
</script> 

<script>
navigator.sayswho= (function(){
    var ua= navigator.userAgent, tem,
    M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
    }
    if(M[1]!== 'Chrome'){
       alert("Oncoscape is currently developed and tested under Chrome.  For best results, please use Chrome version 45.0 and later.")
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
    }
    M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();
</script>

</head>

<style>

.flex-container {
  display: -webkit-flex;
  display: flex;
  }

.ui-slider-range {
   background-image: none;
   background: lightgrey;
   }

th,td {
   font-size:12px;
   }

.patientDataFilterSliderReadout{
   font-size: 10px;
   height:16px;
   }

.ui-tabs .ui-tabs-nav li a{
   font-size:10pt !important;
   }

.ui-button .ui-button-text{
   font-size:10pt !important;
   }

.ui-dialog .ui-dialog-titlebar-close span{ margin:0 }

.SelectionMenu{
color: rgb(0, 0, 0); 
background-color: rgb(255, 255, 255);
}

</style>



<script>
//----------------------------------------------------------------------------------------------------
// These javascript functions and variables are arranged into a simple module so that
// implementation details are kept private from the public API other oncoscape 
// browser modules will use.  common services and utility functions are provided here
//----------------------------------------------------------------------------------------------------
var HubModule = (function () {

  var name = "HubModule";
     // keys are module names, their outermost divs are the values.
     // providing these outermost divs allows was inspired by 
     // the need to allow raising of tabs by the sending tab.
     // TODO: not sure that's still needed

  var selectionDestinations = {};
  var dispatchOptions = {};
  var socketIsConnected = false;
  var socketConnectedFunctions = [];
  var onDocumentReadyFunctions = [];
  var socketURI = window.location.href.replace("http://", "ws://");
  var socket;
  
  var  messagingRestrictedToLogin = false;

  var modules = {};
//----------------------------------------------------------------------------------------------------
function registerModule(name, moduleObject)
{
   modules[name] = moduleObject;

} // registerModule
//----------------------------------------------------------------------------------------------------
function getModuleNames()
{
   return(Object.getOwnPropertyNames(modules));

} // getModuleNames
//----------------------------------------------------------------------------------------------------
function getModules()
{
   return modules;

} // getModules
//----------------------------------------------------------------------------------------------------
// TODO: add 3rd argument: acceptsIncomingMessages
//       datasets, for instance, seems to have no need for incoming json/websocket messages
function registerSelectionDestination(names, outermostDivID)
{
  if(typeof(names) == "string")
    names = [names];

  for(var i=0; i < names.length; i++)
     selectionDestinations[names[i]] = outermostDivID;

} // registerSelectionDestination
//----------------------------------------------------------------------------------------------------
function getRegisteredSelectionDestinations()
{
  return(selectionDestinations);

} // getRegisteredSelectionDestinations
//----------------------------------------------------------------------------------------------------
function setupSocket(socket)
{
  console.log("=== Module.hub setupSocket");

  try {
     socket.onopen = function() {
        console.log("websocket connection now open");
        socketIsConnected = true;
        for(var f=0; f < socketConnectedFunctions.length; f++){
           console.log("calling the next sockectConnectedFunction");
           socketConnectedFunctions[f]();
           } // for f
        } // socked.onopen

     socket.onmessage = function got_packet(msg) {
        var msg = JSON.parse(msg.data)
        dispatchMessage(msg)
        } // socket.onmessage, got_packet

     socket.onclose = function(){
        alert("Web socket connection to server has closed");
        } // socket.onclose
     } // try
  catch(exception) {
    console.log("Error: " + exception);
    }
 
  return(socket);

} // setupSocket
//----------------------------------------------------------------------------------------------------
function socketConnected()
{
   return(socketIsConnected);

} // socketConnected
//----------------------------------------------------------------------------------------------------
function addSocketConnectedFunction(func)
{
   socketConnectedFunctions.push(func)

} // addSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function getSocketConnectedFunctions()
{
   return(socketConnectedFunctions)

} // getSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function addOnDocumentReadyFunction(func)
{
   onDocumentReadyFunctions.push(func)

} // addOnDocumentReadyFunction
//----------------------------------------------------------------------------------------------------
function getOnDocumentReadyFunctions()
{
   return(onDocumentReadyFunctions)

} // getOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
// the nginx proxy server, used by fhcrc IT for the publicly-visible version of Oncoscape
// times out web sockets at 90 seconds.
// this function, when called more often that that, will keep the websocket open.
keepAlive = function()
{   
    //console.log("keep alive"); 
    msg = {cmd: "keepAlive", callback: "", status:"request", payload:""}
    socket.send(JSON.stringify(msg));

} // keepAlive
//--------------------------------------------------------------------------------------------------
function runOnDocumentReadyFunctions()
{
  setInterval(keepAlive, 10000);  // 10 seconds
  var funcs = getOnDocumentReadyFunctions()
  console.log("==== Module.hub: " + funcs.length + " onDocumentReadyFunctions");

  for (var f = 0; f < funcs.length; f++) {
     console.log("calling on ready function");
     funcs[f]();
     }

} // runOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
function runningInNode()
{
    // a not very sophisticated test, but adequate for our purposes thus far
  return(typeof(window) == "undefined")

} // functionRunningInNode
//----------------------------------------------------------------------------------------------------
function initializeWebSocket()
{
   if(runningInNode()){
     console.log("--- web socket not currently available when runing in Node");
     process.exit(code=1)
     }

   socket = new WebSocket(socketURI);
   socket = setupSocket(socket);

} // initializeWebSocket
//----------------------------------------------------------------------------------------------------
function getSocket()
{
  return(socket);

} // getSocket
//----------------------------------------------------------------------------------------------------
function addMessageHandler(cmd, func)
{
  if(cmd in dispatchOptions){
     dispatchOptions[cmd].push(func)
     }
  else{
     dispatchOptions[cmd] = [func]
     }
  
} // addMessageHandler
//----------------------------------------------------------------------------------------------------
function getRegisteredMessageNames()
{
   return(Object.keys(dispatchOptions));
  
} // getRegisteredMessageNames
//----------------------------------------------------------------------------------------------------
function getDispatchOptions()
{
   return(dispatchOptions);
  
} // getDispatchOptions
//----------------------------------------------------------------------------------------------------
function dispatchMessage(msg)
{
   var cmd = msg.cmd;
   var status = msg.status;
   console.log("====== Module.hub dispatchMessage '" + cmd + "' [" + Date() + "]" );

   var dispatchKeys = Object.keys(dispatchOptions);
   var cmdIndex = dispatchKeys.indexOf(cmd);
   console.log("hub.dispatchMessage(" + cmd + "): " + cmdIndex);

   if(cmdIndex === -1){
      console.log("unrecognized socket request: " + msg.cmd);
      console.log(" --- msg:");
      console.log(msg);
      console.log(" --- dispatchOptions");
      console.log(dispatchOptions);
      }
   else{
     var funcs = dispatchOptions[cmd];
     //console.log(" func count for msg cmd " + cmd + ": " + funcs.length);
      for(var i=0; i < funcs.length; i++){
         //console.log("--- Module.hub executing func # " + i + " for cmd " + msg.cmd);
         funcs[i](msg); // dispatchOptions[msg.cmd](msg)
         } // for i
      }

}  // dispatchMessage
//----------------------------------------------------------------------------------------------------
function restrictMessagingToLogin(newState)
{
   messagingRestrictedToLogin = newState;

} // restrictMessagingToLogin
//----------------------------------------------------------------------------------------------------
function send(msg)
{
   var cmd = JSON.parse(msg).cmd;
   if(messagingRestrictedToLogin && cmd === "checkPassword"){
      console.log("hub.send drops non-login msg");
      return;
      }

   var browserLocalCommand = Object.keys(dispatchOptions).indexOf(cmd) >= 0;
   var mode = "server";
   if(browserLocalCommand)
      mode = "browser local";

   console.log("--- hub.send: '" + cmd + "' (" + mode + ")");

   if(browserLocalCommand)
      dispatchMessage(JSON.parse(msg));
   else{
      socket.send(msg);
      }

}  // send
//----------------------------------------------------------------------------------------------------
function setTitle (newTitle)
{
  window.document.title = newTitle;

}  // setTitle
//----------------------------------------------------------------------------------------------------
// add a pulldown menu to the specified menuSelector, which has been provided by the caller, which
// is assumed to be an Oncoscape module.  append the names of all previously-registered divs, 
// except for those explicitly excluded in the incoming argument "excludedModules".
// This supports the usual (but not universal) case: a module does not want to send selections
// to itself.
// this argument will often be an array of one element, the name of the calling module.
// some modules may have multiple send destinations (eg, "PCA" & "PCA (highlight)".
function configureSendSelectionMenu(menuSelector, excludedModules, changeFunction, menuTitle)
{
  var menu = $(menuSelector);
  menu.append("<option>" + menuTitle + "</option>");
  menu.change(changeFunction);
  var otherModules = Object.keys(hub.getRegisteredSelectionDestinations());

  for(var i=0; i < otherModules.length; i++){
     var moduleName = otherModules[i];
     var excluded = excludedModules.indexOf(moduleName) >= 0;
     if(!excluded){
        menu.append("<option>" + moduleName + "</option>");
        }
     } // for i

  return(menu);

} // createSendSelectionMenu
//--------------------------------------------------------------------------------------------
// from http://stackoverflow.com/questions/4068373/center-a-popup-window-on-screen
function openCenteredBrowserWindow(url, title, w, h, replaceAnyExistingPopup) {
      // Fixes dual-screen position                       Most browsers      Firefox
    var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
    var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
    width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
    height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

    var left = ((width / 2) - (w / 2)) + dualScreenLeft;
    var top = ((height / 2) - (h / 2)) + dualScreenTop;
    var options = 'scrollbars=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left;

    var newWindow;

      // warning, a bug: when multiple popup windows are created, they
      // all have the same content -- not what we want.  fix this
      // by severing their relationship, and/or switching to jQuery dialog

    if(replaceAnyExistingPopup)
      newWindow = window.open(url, title, options);
    else // leave any existing popup windows untouched
      newWindow = window.open(url, "_blank", options);

    if (window.focus) {
       newWindow.focus();
       }
       
    return newWindow;

} // openCenteredBrowserWindow
//--------------------------------------------------------------------------------------------
function disableButton(button)
{
   button.prop("disabled", true);
   button.css({"background-color": "lightgray", "color": "gray"});

} // disableButton
//--------------------------------------------------------------------------------------------
function enableButton(button)
{
   button.prop("disabled", false);
   //button.css({ 'color': 'black'})
   button.css({"background-color": "white", "color": "black"});

} // enableButton
//--------------------------------------------------------------------------------------------
function disableAllTabsExcept(tabIDstring)
{
  if(typeof tabIDstring == "string") tabIDstring = [tabIDstring]
  var allDivIDs = getTabDivIDs()
  allDivIDs = allDivIDs.filter(function(i, id){ return(tabIDstring.indexOf(id) == -1) })
  for(var i=0;i<allDivIDs.length; i++){  	disableTab(allDivIDs[i]) }
  
  return allDivIDs;  //returns divIDs that have been disabled
  
} // disableTab
//--------------------------------------------------------------------------------------------
function disableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "disable", "#" + tabIDstring  )

} // disableTab
//--------------------------------------------------------------------------------------------
function enableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "enable", "#" + tabIDstring   )
} // enableTab

//--------------------------------------------------------------------------------------------
// if jQuery-style tabs are in use with Oncoscape, this function raised the named tab to the
// the front (visible) position in the tabset
// the argument, "tabIDString" is the tab id used in the module's widget.html, reproduced exactly
// in tabsApp/widget.html, with some current examples being
//  pcaDiv, patientTimeLinesDiv, gbmPathwaysDiv
//
function raiseTab(tabIDString)
{
  var tabsWidget = $("#oncoscapeTabs");

  if(tabsWidget.length > 0){
     var selectionString = '#oncoscapeTabs a[href="#' + tabIDString + '"]';
     var tabIndex = $(selectionString).parent().index ();
     if(tabIndex < 0) throw "Module.hub does not recognize tabIDString '" + tabIDString + "'";
     console.log("Module.hub:raiseTab for '" + tabIDString + "' (" + tabIndex + ") set to active'");
     setTimeout(function(){tabsWidget.tabs( "option", "active", tabIndex);}, 0);
     } // if tabs exist

} // raiseTab
//----------------------------------------------------------------------------------------------------
// each of our tabs is a div, nested directly within $("oncoscapeTabs").  
// this function returns an array of each of the div ids
function getTabNames()
{
  var tabNames = $("#oncoscapeTabs").children()[0].textContent.trim().split("\n")
  for (i=0;i< tabNames.length; i++){ tabNames[i] = tabNames[i].trim()}
  tabNames =tabNames.filter(function(name){return name != ""})

	return tabNames;

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// each of our tabs has a title within the $("oncoscapeTabs") nav bar
// this function returns an array of each tab Title
function getTabDivIDs()
{
   return ($("#oncoscapeTabs").children("div").map(function(index,dom){return dom.id}));

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTab("Login", "#loginDiv");
function hideTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideTab
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTabNav("Login");
function hideTabNav(tabTitle)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()

} // hideTab
//----------------------------------------------------------------------------------------------------
function hideAllTabsButOne(tabTitle, tabDivIDstring)
{
  var divIDs = getTabDivIDs();
  
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideAllTabsButOne
//----------------------------------------------------------------------------------------------------
function showTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").show()
  $(tabDivIDstring).show();

} // showTab
//----------------------------------------------------------------------------------------------------
function addTab(tabTitle, tabDivIDstring,  content)
{
  var tabs = $("#oncoscapeTabs").tabs()
  var listItem = "<li><a href='#" + tabDivIDstring + "}'>" + tabTitle + "</a>";

  tabs.find(".ui-tabs-nav").append(listItem);
  tabs.append("<div id='" + tabDivIDstring + "'><p>" + content + "</p></div>");
  tabs.tabs("refresh");

} // addTab
//----------------------------------------------------------------------------------------------------
function getRandomFloat (min, max)
{
    return Math.random() * (max - min) + min;
}
//----------------------------------------------------------------------------------------------------
function getRandomInt (min, max) 
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
//----------------------------------------------------------------------------------------------------
String.prototype.beginsWith = function (string) 
{
    return(this.toLowerCase().indexOf(string.toLowerCase()) === 0);
};
//----------------------------------------------------------------------------------------------------
uniqueElementsOfArray = function(vector)
{
  var u = {}, a = [];

  for(var i = 0, l = vector.length; i < l; ++i){
     if(u.hasOwnProperty(vector[i])){
       continue;
       }
     a.push(vector[i]);
     u[vector[i]] = 1;
     } // for i

   return a;

} // uniqueElementsOfArray
//----------------------------------------------------------------------------------------------------
// return the targets matched by the candidates, where match is tolerant of differences by suffix
// thus incoming id "TCGA.06.0649.01" matches existing id "TCGA.06.0649" and
//      incoming id "TCGA.06.0649"    matches existing id "TCGA.06.0649.01" 
// this may cause problems with gene names, eg, MYC would mach MYCL and MYCA
// todo: make this suffix-tolerant match suffix-specific 
function intersectionOfArrays(candidates, targets) {

  hits=[]; 

  for(var i=0; i < candidates.length; i++){
    for (var j=0; j < targets.length; j++){
       candidate = candidates[i];
       target = targets[j];
       index1 = candidate.indexOf(target);   // "abc".indexOf("ab") -> 0
       index2 = target.indexOf(candidate); 
       //console.log("c(t): " + candidate + " contains " + target + ": " + index1);
       //console.log("t(c): " + target + " contains " + candidate + ": " + index2);
       if (index1 == 0)
          hits.push(target)
       else if (index2 == 0)
          hits.push(target)
         } // for j
     } // for i

  return(hits)

} // intersectionOfArays
//----------------------------------------------------------------------------------------------------
function setupGlobalExceptionHandler()
{
   window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {

      var title = "Oncoscape Error";
      var options = {buttons: { "Ok": function () { $(this).dialog("close"); } },
                     title: title};
      var text = "<i>" + errorMsg + "</i><br>" +
                 "<br><b>Script</b>: " + url + 
                 "<br><b>Line:</b> " + lineNumber + 
                 "<br><b>Column:</b> " + column + 
                 "<br><b>StackTrace:</b> " +  errorObj;
      $("<div></div>").dialog(options).html(text);
      };
 
} // setupGlobalExceptionHandler
//----------------------------------------------------------------------------------------------------
function start()
{
  setupGlobalExceptionHandler();
  initializeWebSocket();
  $(document).ready(runOnDocumentReadyFunctions);
  QUnit.config.altertitle = false;

}  // start
//----------------------------------------------------------------------------------------------------
function logEventOnServer(moduleOfOrigin, eventName, eventStatus, comment)
{
   console.log("about to logEvent: " + eventName);
   payload= {eventName: eventName, eventStatus: eventStatus, 
             moduleOfOrigin: moduleOfOrigin, comment: comment};

   hub.send(JSON.stringify({cmd: "logEvent", callback: "", status: "request", payload: payload}));

} // logEventOnServer
//----------------------------------------------------------------------------------------------------
function test_intersectionOfArrays()
{
   console.log("---  test_intersectionOfArrays");
   var targets = ["TCGA.02.0006"];
   var candidates = ["TCGA.02.0006"];

   QUnit.test("test_intersectionOfArrays 1", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   targets = ["TCGA.02.0006"];
   candidates = ["bogus"];
   QUnit.test("test_intersectionOfArrays 2", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });

   targets = ["bogus"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 3", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });


   targets = ["TCGA.02.0006.01"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 4", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   //targets = ["MAP2"];   this test will fail because sometimes we want incomplete matches:
   //  see test4 just above
   //candidates = ["MAP2K4", "abc"];
   //QUnit.test("test_intersectionOfArrays 5", function(assert) {
   //   assert.equal(hub.intersectionOfArrays(candidates, targets), []);
   //   });


} //  test_intersectionOfArrays
//----------------------------------------------------------------------------------------------------
function standAloneTest()
{
   test_intersectionOfArrays();

}  // standaloneTest
//----------------------------------------------------------------------------------------------------

  return({
     getName: function() {return(name)},
     restrictMessagingToLogin: restrictMessagingToLogin,
     registerModule: registerModule,
     getModules: getModules,
     registerSelectionDestination: registerSelectionDestination,
     getRegisteredSelectionDestinations: getRegisteredSelectionDestinations,
     socketConnected: socketConnected,
     addSocketConnectedFunction: addSocketConnectedFunction,
     getSocketConnectedFunctions: getSocketConnectedFunctions,
     addOnDocumentReadyFunction: addOnDocumentReadyFunction,
     getOnDocumentReadyFunctions: getOnDocumentReadyFunctions,
     openCenteredBrowserWindow: openCenteredBrowserWindow,
     runningInNode: runningInNode,
     initializeWebSocket: initializeWebSocket,
     getSocket: getSocket,
     addMessageHandler: addMessageHandler,
     getRegisteredMessageNames: getRegisteredMessageNames,
     getDispatchOptions: getDispatchOptions,
     dispatchMessage: dispatchMessage,
     configureSendSelectionMenu: configureSendSelectionMenu,
     openCenteredBrowserWindow: openCenteredBrowserWindow,
     enableButton: enableButton,
     disableButton: disableButton,
     enableTab: enableTab,
     disableTab: disableTab,
     disableAllTabsExcept: disableAllTabsExcept,
     getRandomInt: getRandomInt,
     getRandomFloat: getRandomFloat,
     intersectionOfArrays: intersectionOfArrays,
     uniqueElementsOfArray: uniqueElementsOfArray,
     send: send,
     setTitle: setTitle,
     getTabDivIDs: getTabDivIDs,
     getTabNames: getTabNames,
     raiseTab: raiseTab,
     hideTab: hideTab,
     hideTabNav: hideTabNav,
     showTab: showTab,
     addTab: addTab,
     sat: standAloneTest,
     start: start,
     logEventOnServer: logEventOnServer
     });

}); // HubModule
//----------------------------------------------------------------------------------------------------


var hub = HubModule();
hub.start();
hub.addOnDocumentReadyFunction(function() {
    console.log("====== tabapps document ready");
    window.tabsAppRunning = true
    $("#oncoscapeTabs").tabs({
         // todo: distinguish between tabs, only do needed resets
       activate: function(event, ui) {
            console.log(" tabsApp/code.js:activate");
            var tableRef = $("#historyTable").dataTable();
            var tableRef2 = $("#userDataStoreTable").dataTable();
            if (tableRef.length > 0) {
               console.log("   adjusting patient history table");
               tableRef.fnAdjustColumnSizing();
               } // if
            if (tableRef2.length > 0) {
               console.log("   skipping! - adjusting user data store table");
               tableRef2.fnAdjustColumnSizing();
               } // if
            //console.log(" ==== tab.activate, possible cyjs resize and fit");
            if(typeof(cwMarkers) != "undefined") {
              console.log("adjusting cwMarkers? " + cwMarkers.width() + " * " + cwMarkers.height());
               if(cwMarkers.width() > 0){
                  cwMarkers.resize(); 
                  console.log("after resize");
                  cwMarkers.fit(50);
                  console.log("done adjusting cwMarkers");
		  }
               }
            if(typeof(cyGbm) != "undefined") {
               //console.log("adjusting cwGbm");
               cyGbm.resize();
               cyGbm.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cwAngio) != "undefined") {
               //console.log("adjusting cwAngio");
               cwAngio.resize();
               cwAngio.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cyPathway) != "undefined") {
               cyPathway.resize();
               cyPathway.fit(50);
               }
            } // activate
        }); // tabs
    });  // ready



hub.raiseTab("datasetsDiv");
hub.setTitle("oncoscape");
</script>
<body>
<style>
.ui-tabs .ui-tabs-nav li a {font-size:10pt !important;}
.ui-button .ui-button-text {font-size:10pt !important;}
</style>


<script>
//----------------------------------------------------------------------------------------------------
var DashboardModule = (function () {

  var HIDRAlink = "<a href='http://www.fhcrc.org/en/labs/hidra.html' name='newWindow'>HIDRA</a>"

  var TCGAdatalink = "<a href='https://tcga-data.nci.nih.gov/tcga/tcgaCancerDetails.jsp?diseaseType=GBM&diseaseid=Glioblastoma%20multiforme' name='newWindow'>TCGA portal</a>"

  var GBM2013paper = "<a href='http://www.ncbi.nlm.nih.gov/pubmed/24120142' name='newWindow'>(Brennan et al, Cell 2013)</a>"

//----------------------------------------------------------------------------------------------------
function isIE () {
  var myNav = navigator.userAgent.toLowerCase();
  return (myNav.indexOf('msie') != -1) ? parseInt(myNav.split('msie')[1]) : false;
}
//----------------------------------------------------------------------------------------------------

function DashboardInitializeUI(){
        
        console.log(navigator.userAgent)
        //if(navigator.userAgent.indexOf("Chrome/3") < 0){
        //  alert("To display networks reliably, Chrome v37 or later is required. Please switch or upgrade.");
        //  }

        console.log("===== Display User Information")        

        $("#DashboardAccordion" ).accordion({
              active: false,
              heightStyle: "content",
              collapsible: true,
              icons: null
              });
            
        $("#AvailableDataAccordian" ).accordion({
              active: false,
              heightStyle: "content",
              collapsible: true,
              icons: null
        });

        LoadDatainfo();
        document.getElementsByName("newWindow").onclick = function(){
                var thisIsIt = 1
                  return !window.open(this.href);
        }
            
       /* $('a').each(function() {
              var a = new RegExp('/' + window.location.host + '/');
              if(!a.test(this.href)) {
                 $(this).click(function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        window.open(this.href, '_blank');
                  });
               }
        }); */
               
    };
//----------------------------------------------------------------------------------------------------
function LoadDatainfo(){
 
      var TCGAdata =  $("#TCGAdataInfo")
      TCGAdata.append("<p><h4 align=center>Glioblastoma multiforme (GBM) Pilot demo</h4></p>")
      TCGAdata.append("<p>Copy Number Alterations, Single Nucleotide Alterations, indels and patient histories were downloaded from the " +
                      TCGAdatalink + ", based off the 2013 publication "+GBM2013paper+" and supplemented by in-house data.</p>")          
          
      TCGAdata.append("<div id='TCGArnadata'><p>The TCGA GBM expression data included in Oncoscape is for 304 patients that meet the following criteria:<br>" +
           "<ol type='A'><li>TCGA clinical data has (529 GBM samples) <ul> <li>'histologic type' is 'GBM'</li><li>'sample type' is 'primary'</li><li>an assigned expression subtype (ie not empty)</li></ul>"+
           "<li>TCGA expression data within unified (Agilent + Affymetrix) set defined in comparative paper (PMID:21436879)  (323 GBM samples).</li></ol>"+
           "</p></div>")
 
      var UWMSCCAdata =  $("#UWMSCCAdataInfo")
      UWMSCCAdata.append("<p>Access to information regarding <a href='http://www.uwmedicine.org/' name='newWindow'>University of Washington Medicine</a> and <a href='http://www.seattlecca.org/'  name='newWindow'>SCCA</a> patients is restricted by IRB approval.  Please contact <a href='http://www.fhcrc.org/en/diseases/featured-researchers/fearn-paul.html'  name='newWindow'>Paul Fearn</a> for questions regarding access.</p>")

      var TableContents = $("#TableContentsDiv")
      TableContents.append("<p><h4>Patient History:</h4> Table view of patient information.  Filter data by Age of Diagnosis & survival sliders or by specific search terms.</p>")
      TableContents.append("<p><h4>Patient Timelines:</h4> Visual representation of patient histories.  Align or Order patient histories by clinical events.  Couple features (e.g. time to progression, histology type, or age at diagnosis) with patient timelines. </p>")
      TableContents.append("<p><h4>Principle Component Analysis (PCA):</h4> Two dimensional view of per sample expression data.</p>")
      TableContents.append("<p><h4>Partial Least Squares Regression (PLSR):</h4> Use linear regression to correlate genes with clinical features using RNA expression </p>")
      TableContents.append("<p><h4>GBM Pathways:</h4> Map patient specific expression levels on a hand curated network of genes associated with GBM.  Click on edges to view the abstracts defining the relationship. </p>")   
//      TableContents.append("<p><h4>Angiogenesis:</h4> Map patient specific expression levels on a small network of genes associated with angiogenesis.  Click on edges to view the abstracts defining the relationship. </p>")   
      TableContents.append("<p><h4>Markers & Patients:</h4> Link copy number variation and mutation data to patients grouped by GBM classification: mesenchymal, classical, neural, proneural, and G-CIMP </p>")
//      TableContents.append("<p><h4>Distributions:</h4> Plot clinical features of defined populations. </p>")
      TableContents.append("<p><h4>Survival:</h4> Compare survival rates of selected patients against the remaining population in a Kaplan Meier plot.</p>")

      var AboutOncoscape = $("#AboutOncoscapeDiv")
      AboutOncoscape.append("<p>Oncoscape is developed at the <a href= 'http://www.fhcrc.org' name='newWindow'>Fred Hutchinson Cancer Research Center</a> under the auspices of the <a href='http://www.sttrcancer.org' name='newWindow'>Solid Tumor Translational Research</a> initiative.</p>")
      AboutOncoscape.append("<p> Oncoscape is a web-based, menu-driven analysis and visualization platform for large-scale, heterogeneous clinical and molecular patient timeline data as exemplified by the <a href='http://www.fhcrc.org/en/labs/hidra.html'  name='newWindow'>Fred Hutch HIDRA</a> database.</p>")
      AboutOncoscape.append("<p>Oncoscape was conceived, and is managed, by a Steering Committee comprising: <a href='http://www.fhcrc.org/en/diseases/featured-researchers/holland-eric.html' name='newWindow'>Eric Holland</a>, <a href='http://www.sttrcancer.org/en/contact-us.html'  name='newWindow'>Desert Horse-Grant</a>, <a href='http://www.fhcrc.org/en/diseases/featured-researchers/fearn-paul.html'  name='newWindow'>Paul Fearn</a>, <a href='http://fhcrc.academia.edu/PaulShannon'  name='newWindow'>Paul Shannon</a>,<a href='http://www.researchgate.net/profile/Lisa_McFerrin' name='newWindow'>Lisa McFerrin</a>, and <a href='http://research.fhcrc.org/bolouri/' name='newWindow'>Hamid Bolouri</a>.</p>")

      AboutOncoscape.append("<p> Paul Shannon (lead) and Lisa McFerrin are the primary developers of Oncoscape, with additional code contributions by Cliff Rostomily and Hamid Bolouri.</p>")

   }

//----------------------------------------------------------------------------------------------------
return{

   init: function(){
      hub.addOnDocumentReadyFunction(DashboardInitializeUI);
      
      }
   };

}); // DateAndTimeModule
//----------------------------------------------------------------------------------------------------
Dashboard = DashboardModule();
Dashboard.init();

hub.registerModule("Dashboard", Dashboard);

//----------------------------------------------------------------------------------------------------
var DataSummaryModule = (function () {

  var dataSummaryDiv;

  var outputDiv;
  var dataSetNamesOutputDiv;
  var thisModulesName = "Datasets";
  var thisModulesOutermostDiv = "datasetsDiv";

  var tableElement;
  var tableRef;
  var datasetMenu;
  var selectedDataSet;
  var useThisDatasetButton;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";
  var passwordProtected = false;

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
  sendSelectionsMenu = hub.configureSendSelectionMenu("#datasetsSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

  hub.disableButton(sendSelectionsMenu);

  $(window).resize(handleWindowResize);
  datasetMenu = $("#datasetMenu");
  datasetMenu.change(selectManifest);

  dataSetNamesOutputDiv = $("#dataSetNamesOutputDiv");
  dataSummaryDiv = $("#dataSummaryOutputDiv");

  useThisDatasetButton = $("#selectDatasetButton");
  useThisDatasetButton.button();
  hub.disableButton(useThisDatasetButton);
  useThisDatasetButton.click(specifyCurrentDataset);

  outputDiv = $("#dataSummaryOutputDiv");
  tableElement = $("#datasetsManifestTable");
      
    // if no login tab is present, then allow unrestricted choice of datasets.
    // if it IS present, then that tab will control this.

  var loginRequired = $("#loginDiv").length === 1;
  console.log("loginRequired? " + loginRequired);

  if(!loginRequired){
    console.log(" enabling datasetMenu");
    hub.enableButton($("#datasetMenu"));
    }
  else{
    console.log(" disabling datasetMenu");
    hub.disableButton($("#datasetMenu"));
    }

   if(hub.socketConnected())
      populateDataSetMenu();
   else
     hub.addSocketConnectedFunction(populateDataSetMenu);

} // initializeUI
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
   $("#datasetsStatusDiv").text(msg);   // todo: this is obsolete
   $("#datasetsMinorStatusDiv").text(msg);
   
} // postStatus
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  $("#"+thisModulesOutermostDiv).width($(window).width() * 0.95);
//  $("#"+thisModulesOutermostDiv).height($(window).height() * 0.95);

//  console.log("  div: " + outputDiv.width());
//  console.log("  tbl before: " + tableElement.width());
//  tableElement.width($(window).width() * 0.50);
//  console.log("  tbl after: " + tableElement.width());

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   var cmd = "sendSelectionTo_" + destination;
   payload = "dummy payload";
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//----------------------------------------------------------------------------------------------------
function selectManifest(event)
{
   selectedDataSet = datasetMenu.val();
   console.log("dataset '" + selectedDataSet + "'");
   $("#datasetsManifestTable").css("display", "none");
   $("#loadingDatasetMessage").text("Loading Datasets...");

   $("#loadingDatasetMessage").css("display", "inline");

   if(selectedDataSet === ""){
      $("#datasetInstructions").css("display", "block");
      hub.disableButton(useThisDatasetButton);
      }
    else{
      $("#datasetInstructions").css("display", "none");
      requestDataSetSummary(selectedDataSet);
    }

} // selectManifest
//----------------------------------------------------------------------------------------------------
function populateDataSetMenu()
{
   console.log("Module.datasets, entering populateDataSetMenu");

   console.log("      socket connected? " + hub.socketConnected());
   console.log("=== datasetMenu ready, now issuing populateDataSetMenu request to server");
   var msg = {cmd: "getDataSetNames",  callback: "handleDataSetNames", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // populateDataSetMenu
//----------------------------------------------------------------------------------------------------
function handleDataSetNames(msg)
{
   console.log("=== handleDataSetNames");
   
   var dataSetNames = msg.payload.datasets;
   console.log("dataSetNames length: " + dataSetNames.length);
   console.log("dataSetNames: " + JSON.stringify(dataSetNames));

   var passwordProtected = msg.payload.passwordProtected;

   if(!Array.isArray(dataSetNames))
      dataSetNames = [dataSetNames];

   for(var i=0; i < dataSetNames.length; i++){
      var s = dataSetNames[i];
      datasetMenu.append("<option value='" + s + "'>" + s + "</option>");
      }

  $("#datasetsMinorStatusDiv").text("datasetMenu loaded");

} // handleDataSetNames
//----------------------------------------------------------------------------------------------------
function requestDataSetSummary(dataSetName)
{
   console.log("=== requestDataSetSummary");

   var msg = {cmd: "getDataManifest",  callback: "displayDataManifest", status: "request", 
              payload: dataSetName};
   hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "request", dataSetName);

   hub.send(JSON.stringify(msg));

} // requestDataSetSummary
//----------------------------------------------------------------------------------------------------
function displayDataManifest(msg)
{
   $("#datasetsManifestTable").css("display", "block");
   $("#loadingDatasetMessage").css("display", "none");

   var payload = msg.payload;
   var tblColumnNames = payload.colnames;

   var columnTitles = [];
     // convert simple strings to array of objects, each an sTitle
   for(var i=0; i < tblColumnNames.length; i++){
      columnTitles.push({sTitle: tblColumnNames[i]});
      }
     
   if(typeof(tableRef) != "undefined"){
      tableRef.destroy();
      tableElement.empty();
      }


   $(tableElement).ready(function() {
      tableRef = tableElement.DataTable({
        //sDom: 't',
        aoColumns: columnTitles,
        //scrollX: true,
        bPaginate: false,
        bFilter: false, 
        bAutoWidth: true,
        bSort: false,
        bInfo: false
        }); // dataTable

     tableRef = $("#datasetsManifestTable").DataTable();

     tableRef.rows.add(payload.mtx).draw();
     // tableRef.fnAddData(payload.mtx);

     $('#datasetsManifestTable tbody').on( 'click', 'tr', function (){ 
         console.log("=== click");
         var category = $('td', this).eq(0).text();
         var subcategory = $('td', this).eq(1).text();
         if($(this).hasClass("selected")){
            $(this).removeClass('selected');
            hub.disableButton(sendSelectionsMenu);
            }
         else{
            tableRef.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            hub.enableButton(sendSelectionsMenu);
            console.log("selected " + category + ", " + subcategory);
            }
         });

     handleWindowResize();
     hub.enableButton(useThisDatasetButton);
     postStatus("manifest table displayed");
     hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "complete", "");
     }); // tableElement.ready

} // displayDataManifest
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset()
{
   console.log("Module.datasets 'Use Dataset' button clicked, specifyCurrentDataset: " + selectedDataSet);
 
   hub.disableAllTabsExcept([thisModulesOutermostDiv, "userDataStoreDiv", "ericTestDiv", "DashboardDiv"]);
  
   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: selectedDataSet};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   console.log("--- Module.datasets:  datasetSpecified");

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function test(dataSetName)
{
   console.log("Module.datasets test, on datasetName: '" + dataSetName + "'");

   QUnit.test("choose dataset '" + dataSetName + "'", function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = dataSetName;
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value;});

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset);
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         //testLoadPatientHistoryTable();
         }, 5000);
      });


} // test
//----------------------------------------------------------------------------------------------------
function moduleInit()
{
  hub.addOnDocumentReadyFunction(initializeUI);
  //hub.addSocketConnectedFunction(populateDataSetMenu);
  hub.addMessageHandler("handleDataSetNames", handleDataSetNames);
  hub.addMessageHandler("displayDataManifest", displayDataManifest);
  hub.addMessageHandler("datasetSpecified", datasetSpecified);

} // moduleInit
//----------------------------------------------------------------------------------------------------
return{
   init: moduleInit,
   test: test
   }; // DataSummaryModule return value

//----------------------------------------------------------------------------------------------------
}); // DataSummaryModule

var dataSummaryModule = DataSummaryModule();
dataSummaryModule.init();
hub.registerModule("Datasets", dataSummaryModule);
//----------------------------------------------------------------------------------------------------
var patientHistoryTableRef;

var ageAtDxMinReadout;
var ageAtDxMaxReadout;
var survivalMinReadout, survivalMaxReadout;

var ageAtDxMin, ageAtDxMax;
var ageAtDxSlider, survivalSlider;
var survivalMin, survivalMax;


var PatientHistoryModule = (function () {

  var statusDiv;
  var patientHistoryDiv;
  var controlsDiv;
  var tableDiv;
  var tableElement;
  var sendSelectionsMenu;

  var thisModulesName = "patientHistory";
  var thisModulesOutermostDiv = "patientHistoryDiv";
  var selectionDestinations = [thisModulesName];

  var sendSelectionsMenuTitle = "Send selection...";
  var showAllRowsButton;
  
//--------------------------------------------------------------------------------------------
function initializeUI()
{
  console.log("=== Module.patientHistory, initializeUID");

  $(window).resize(handleWindowResize);

  statusDiv = $("#patientHistoryStatusDiv");

  patientHistoryDiv = $("#patientHistoryDiv");
  controlsDiv = $("#patientHistoryControlsDiv");
  tableDiv = $("#patientHistoryTableDiv");
  tableElement = $("#patientHistoryTable");

  showAllRowsButton = $("#patientHistoryShowAllRowsButton");
  showAllRowsButton.click(showAllRows);

  sendSelectionsMenu = hub.configureSendSelectionMenu("#patientHistorySendSelectionsMenu", 
                                                      selectionDestinations, sendSelections,
                                                      sendSelectionsMenuTitle);

  handleWindowResize();
  hub.disableTab(thisModulesOutermostDiv)


} // initializeUI
//----------------------------------------------------------------------------------------------------
function createDataTable(colnames, data)
{
      // DataTable likes some structure for column titles

   var columnTitles = [];
   for(var i=0; i < colnames.length; i++){
     columnTitles.push({sTitle: colnames[i]});
     }

   if(typeof(patientHistoryTableRef) != "undefined"){
      patientHistoryTableRef.destroy();
      tableElement.empty();
      }

   patientHistoryTableRef = tableElement.DataTable({
                             data: data,
                             columns: columnTitles,
                             //dom: "C<fi<t>>",
                             dom: 'C<"clear">lfrtip',
                             paging: false,
                             jQueryUI: false
                             });

   if(colnames.indexOf("AgeDx") >= 0){
      var minMax = learnSliderMinAndMax(data, colnames.indexOf("AgeDx"));
      console.log("minMax for AgeDx: ");
      console.log(minMax);
      ageAtDxMin = minMax[0];
      ageAtDxMax = minMax[1];
         // slider, title & readouts for specifying age range for table display
      createAgeAtDiagnosisWidget(ageAtDxMin, ageAtDxMax);  
      } // ageAtDx slider

   if(colnames.indexOf("Survival") >= 0){
      minMax = learnSliderMinAndMax(data, colnames.indexOf("Survival"));
      console.log("minMax for Survival: ");
      console.log(minMax);
      survivalMin = minMax[0];
      survivalMax = minMax[1];
         // slider, title & readouts for specifying age range for table display
      createSurvivalWidget(survivalMin, survivalMax);  
      } // survival slider

   showAllRows();
   setupSliderDrivenFilterBehavior(colnames);
 

} // createDataTable
//----------------------------------------------------------------------------------------------------
function setupSliderDrivenFilterBehavior(colnames)
{
  var ageDxColumn = colnames.indexOf("AgeDx");
  var survivalColumn = colnames.indexOf("Survival");

  if(ageDxColumn >= 0) {
    jQuery.fn.dataTable.ext.search.push(
       function(settings, data, dataIndex) {
         var ageAtDxMin      = parseFloat(ageAtDxMinReadout.val());
         var ageAtDxMax      = parseFloat(ageAtDxMaxReadout.val());

         var patientAgeAtDx  = parseFloat(data[ageDxColumn]) || 0;
 
         var ageAtDxInRange  = (patientAgeAtDx >= ageAtDxMin) && (patientAgeAtDx <= ageAtDxMax);
         if(ageAtDxInRange)
            return true;
         return false;
        }); // anonymous function
      } // push

  if(survivalColumn >= 0) {
    jQuery.fn.dataTable.ext.search.push(
       function(settings, data, dataIndex) {
         var survivalMin      = parseFloat(survivalMinReadout.val());
         var survivalMax      = parseFloat(survivalMaxReadout.val());

         var patientSurvival  = parseFloat(data[survivalColumn]) || 0;
         var survivalInRange  = (patientSurvival >= survivalMin) && (patientSurvival <= survivalMax);
         if(survivalInRange)
            return true;
         return false;
        }); // anonymous function
      } // push


} // setupSliderDrivenFilterBehavior
//----------------------------------------------------------------------------------------------------
function createAgeAtDiagnosisWidget(minValue, maxValue)
{
  ageAtDxSlider = $("#ageAtDxSlider");
  ageAtDxMinReadout = $("#ageAtDxMinSliderReadout");
  ageAtDxMaxReadout = $("#ageAtDxMaxSliderReadout");

  ageAtDxSlider.slider({
     range: true,
     slide: function(event, ui) {
        //console.log("AgeDx: " + ui.values[0] + ", " + ui.values[1]);
        if(ui.values[0] > ui.values[1]){
           return false;
           }          
       ageAtDxMinReadout.text (ui.values[0]);
       ageAtDxMaxReadout.text (ui.values[1]);
       patientHistoryTableRef.draw();
       handleWindowResize();
       //updateRowCountReadout();
       },
    min: minValue,
    max: maxValue,
    values: [minValue, maxValue]
    });

  ageAtDxMinReadout.text(minValue);
  ageAtDxMaxReadout.text(maxValue);

} // createAgeAtDiagnosisWidget
//----------------------------------------------------------------------------------------------------
function createSurvivalWidget(minValue, maxValue)
{
  survivalSlider = $("#survivalSlider");
  survivalMinReadout = $("#survivalMinSliderReadout");
  survivalMaxReadout = $("#survivalMaxSliderReadout");
  console.log("createSurvivalWidget");

  survivalSlider.slider({
     range: true,
     slide: function(event, ui) {
        //console.log("survival: " + ui.values[0] + ", " + ui.values[1]);
        if(ui.values[0] > ui.values[1]){
           return false;
           }          
       survivalMinReadout.text (ui.values[0]);
       survivalMaxReadout.text (ui.values[1]);
       patientHistoryTableRef.draw();
       handleWindowResize();
       },
    min: minValue,
    max: maxValue,
    values: [minValue, maxValue]
    });

  survivalMinReadout.text(minValue);
  survivalMaxReadout.text(maxValue);

} // createSurvivalWidget
//----------------------------------------------------------------------------------------------------
// when the patient history table arrives, the filtering sliders can be setup, using the 
// min and max values of selected columns.  our sliders are currently ageAtDx and survival.
// the column numbers for these are specified by the caller.  missing values are not
// troublesome to Javascript's min and max functions.  note the use of floor and ceil,
// to nudge min and max values out a bit.
function learnSliderMinAndMax(tbl, columnNumber)
{
  var rowCount = tbl.length;
  var min = Number.MAX_VALUE;
  var max = -Number.MAX_VALUE;

  for(var r=0; r < rowCount; r++){
    var value = parseFloat(tbl[r][columnNumber]);
    //console.log(value)
    if(value < min)
      min = value;
    if(value > max)
      max = value;
    } // for r

  return[Math.floor(min), Math.ceil(max)];

} // learnSliderMinAndMax
//----------------------------------------------------------------------------------------------------
function showAllRows()
{
   if(typeof(ageAtDxMin)  != "undefined" &&
      typeof(ageAtDxMax)  != "undefined" &&
      typeof(survivalMin) != "undefined" &&
      typeof(survivalMax) != "undefined") {

        ageAtDxSlider.slider("values", [ageAtDxMin, ageAtDxMax]);
        survivalSlider.slider("values", [survivalMin, survivalMax]);
        ageAtDxMinReadout.text(ageAtDxMin);
        ageAtDxMaxReadout.text(ageAtDxMax);
        survivalMinReadout.text(survivalMin);
        survivalMaxReadout.text(survivalMax);
        } // all 4 min/max slider values defined

    // chained calls: clear the DataTable search box, then iterate through the columns, then render

   if(typeof(patientHistoryTableRef) != "undefined")
       patientHistoryTableRef.search('').columns().search('').draw();

   handleWindowResize();

} // showAllRows
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{

  patientHistoryDiv.width($(window).width() * 0.95);
  patientHistoryDiv.height($(window).height() * 0.90);  // leave room for tabs above

  //controlsDiv.width($(window).width() * 0.90);
  controlsDiv.width(patientHistoryDiv.width()); //  * 0.95);
  controlsDiv.height("100px");

  tableDiv.width(patientHistoryDiv.width()); //  * 0.95);
  tableDiv.height(patientHistoryDiv.height() - 130);

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();

   var visibleRows = patientHistoryTableRef.rows({'filter': 'applied'})[0];
   if(visibleRows.length === 0)
      return;

   var selectedIDs = [];

   var data = patientHistoryTableRef.data();

   for(var i=0; i < visibleRows.length; i++){
      var id = data[visibleRows[i]][0];
      selectedIDs.push(id);
      } // for i

   var cmd = "sendSelectionTo_" + destination;

   payload = {value: selectedIDs, count: selectedIDs.length, source: "patient history module"};
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function handleSelections(msg)
{
   showAllRows();
   var ids = msg.payload.value;
   if(typeof(ids) == "string")
      ids = [ids];

      // incoming ids may have trailing version number, e.g., "TCGA.02.0114.01"
      // strip all such 2-digit suffixes:

   ids = ids.map(function(id) {return(id.replace(/\.0[0-9]$/, ""))})
   filterByString(ids);
   hub.raiseTab(thisModulesOutermostDiv);

} // handleSelections
//----------------------------------------------------------------------------------------------------
filterByString = function(strings)
{
   var filterString = strings[0];
   for(var i=1; i < strings.length; i++){
     filterString += "|" + strings[i];
     }

   showAllRows();
   console.log(filterString);

   if(typeof(patientHistoryTableRef) != "undefined")
      patientHistoryTableRef.search(filterString, true, false).draw();   // string, regex, smart

}; // filterByString
//----------------------------------------------------------------------------------------------------
function displayPatientHistoryTable(msg)
{
   var payload = msg.payload;
   var colnames = payload.colnames;
   var data = payload.tbl; // an array of arrays

   console.log("incoming table, rows: " + data.length);
   console.log("incoming table, cols: " + data[0].length);
   createDataTable(colnames, data);
   postStatus("patientHistory data table loaded");
   hub.enableTab(thisModulesOutermostDiv)

}  // displayPatientHistoryTable
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the patient history table from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

     // request patient data table
   var payload = {datasetName: datasetName, durationFormat: "byYear"};
   var newMsg = {cmd: "getPatientHistoryTable",  callback: "displayPatientHistoryTable", 
                 status: "request", payload: payload};

   hub.send(JSON.stringify(newMsg));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
// for standalone exploration, development, and testing.   assumes a hub has been
// created and initialized.  set the dataset, and in the callback load the table
// thus 
//   specifyCurrentDataSet -> getPatientHistoryTable -> displayPatientHistoryTable
//
function testLoad()
{
   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: "TCGAgbm"};

   hub.send(JSON.stringify(msg));

} // test
//----------------------------------------------------------------------------------------------------
function testSelect()
{
   var msg={cmd: "sendSelectionTo_patientHistory", status: "request", callback: "", 
            payload:["TCGA.02.0011", "TCGA.06.0238"]};

   hub.send(JSON.stringify(msg));

} // testSelect
//----------------------------------------------------------------------------------------------------
return{
   init: function(){
      hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
      hub.addOnDocumentReadyFunction(initializeUI);
      hub.addMessageHandler("sendSelectionTo_patientHistory", handleSelections);
      hub.addMessageHandler("datasetSpecified", datasetSpecified);
      hub.addMessageHandler("displayPatientHistoryTable", displayPatientHistoryTable);
      //hub.addSocketConnectedFunction(testLoad);
      //hub.setTitle("patientHistory");
      },
   testSelect: testSelect,
   testLoad:   testLoad
   }; // PatientHistoryModule return value

//----------------------------------------------------------------------------------------------------
}); // PatientHistoryModule
pts = PatientHistoryModule();
pts.init();


//----------------------------------------------------------------------------------------------------
var TimeLineModule = (function () {

	// Integration Components
	//--------------------------------------------------------------------------------------------------

    var sendSelectionMenu;
    var sendSelectionsMenuTitle = "Send selection...";
    var selectionDestinationsOfferedHere = ["Timelines"];
    var OneDay = 1000 *60 * 60*24;
	var ThisModuleName = "Timelines";
    var thisModulesOutermostDiv = "patientTimeLinesDiv";
    
    var then, now;

	// Data Elements
	//--------------------------------------------------------------------------------------------------
		var EventTypes;
		var Events;
		var ptList;
		var ptOrderArray = [];

	// Display features
	//--------------------------------------------------------------------------------------------------
		var TimeLineMargin = {top: 15, right: 15, bottom: 30, left: 25};
        var TimeLineDisplay;
        var TimelineSize, SideBarSize, legendSize;
		var svg, SidePlot, TimeLine, legend, tooltip;
		var MainEvents = ["Birth","Encounter", "Diagnosis", "Procedure","Pathology", "Radiation", "Drug","Progression", "Tests", "Status", "History", "Absent"];
		var MainEventColors = ["#17becf", "#d62728", "#8c564b","#ff7f0e", "#7f7f7f","#e7969c","#9467bd","#1f77b4","#2ca02c", "#bcbd22","#000000" ,"#000000" ];
        var MainEventTextSpacing = [0, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90];
        var TextOffSet = d3.scale.ordinal().range(MainEventTextSpacing).domain(MainEvents);
        var TimeLineColor = d3.scale.ordinal().range(MainEventColors).domain(MainEvents);


//--------------------------------------------------------------------------------------------
     function initializeUI(){
        console.log("========== initializing Timeline UI");
       	d = new Date();
       	then = d.getTime();
       	d = new Date();
		now = d.getTime();
		console.log("Initialize UI start: ", now - then);
		then = now;

		TimeLineDisplay = $("#TimeLineDisplay");
        HandleWindowResize();
 
        sendSelectionMenu = hub.configureSendSelectionMenu("#timeLineSendSelectionsMenu", 
                                                        selectionDestinationsOfferedHere,
                                                        sendSelections,
                                                        sendSelectionsMenuTitle);  

        $(window).resize(HandleWindowResize);

        $("#AlignOptions").change(updateDisplayAlignment);
        $("#OrderOptions").change(updateDisplayOrder);
        $("#SideBarOptions").change(updateDisplaySidePlot);
		
		$('#FitToPage').change(function() { 	HandleWindowResize();  });
	    
		svg = d3.select("#TimeLineDisplay").append("svg")
				  .attr("id", "timelineSVG")
				  .attr("width", TimeLineSize.width + 2*SideBarSize.width + 2*TimeLineMargin.left + 2*TimeLineMargin.right )
				  .attr("height", SideBarSize.height + TimeLineMargin.top + TimeLineMargin.bottom + legendSize.height)
				  ;
		
	    tooltip = d3.select("body").attr("data-toggle", "tooltip")
				   .attr("class", "tooltip")
				   .append("div").attr("id", "tooltipDiv").attr("class", "tooltipNoHover")
				   .style("position", "absolute")
				   .style("z-index", "10")
				   .style("background", "lightgray")
				   .style("border", "thin solid black")
				   .style("border-radius", "5px")
				   .style("padding", "10px")
				   .style("overflow-y", "auto");                        

			//setTimeoutHover = function(el){setTimeout( el.className = "tooltipNoHover", 1000);};
             tooltip.on("mouseover",  function(){
             		   	this.className = "tooltipHover";});
             tooltip.on("mouseout", function(){
            			var x = document.getElementsByClassName("tooltipHover");
            			for(var i=0;i<x.length;i++){x[i].className = "tooltipNoHover"; }
             });

		
		hub.disableTab(thisModulesOutermostDiv);


    }
//--------------------------------------------------------------------------------------------
     function HandleWindowResize(){

		var width, height;

		if($('#FitToPage').is(":checked")){
			  TimeLineDisplay.width($(window).width() * 0.9);
			  TimeLineDisplay.height($(window).height() * 0.9);

			  width = $("#TimeLineDisplay").width();
			  height = $("#TimeLineDisplay").height();
		  
			  TimeLineSize = {width: (0.8 *width - TimeLineMargin.left - TimeLineMargin.right), height: (0.9*height - TimeLineMargin.top - TimeLineMargin.bottom)};
			   SideBarSize = {width: (0.25*width - TimeLineMargin.left - TimeLineMargin.right), height: (0.9*height - TimeLineMargin.top - TimeLineMargin.bottom)};
				legendSize = {width: TimeLineSize.width, height: (0.1*height)};
		} else{
			  TimeLineDisplay.width($(window).width() * 0.9);
			  width = $("#TimeLineDisplay").width();
			  height = ptOrderArray.length * 20;
			  TimeLineSize = {width: (0.8 *width - TimeLineMargin.left - TimeLineMargin.right), height: height};
			   SideBarSize = {width: (0.25*width - TimeLineMargin.left - TimeLineMargin.right), height: height};		
				legendSize = {width: TimeLineSize.width, height: legendSize.height};

		}
         if(typeof TimeLine !== "undefined") redrawSVG();
     }


//--------------------------------------------------------------------------------------------------
	function redrawSVG(){
		initDisplay();
		loadLegend();
		plotTimelines();
		plotSideBar();
	}


//--------------------------------------------------------------------------------------------
     function LogTime(t, TimeScale){ 
        TimeScale = typeof TimeScale !== 'undefined' ? TimeScale : OneDay;
               var Dir = (t<0 ? -1 : 1); 
              return Dir * Math.log(Math.abs(t/TimeScale)+1)/Math.log(2); 
     }     
//--------------------------------------------------------------------------------------------
	function getFormattedDate(date) {  // takes date and returns mm/dd/yyyy
		var dd = date.getDate();
		var mm = date.getMonth()+1; //January is 0!
		var yyyy = date.getFullYear();

		if(dd<10) { dd='0'+dd; } 
		if(mm<10) { mm='0'+mm;} 

		date = mm+'/'+dd+'/'+yyyy;
		
		return date;
	 }
//--------------------------------------------------------------------------------------------
	function insertAscending(id, array) {  //null orderBy values listed first
		  
		  var val = ptList[id].orderVal;
		  array.splice(locationOf(val, array) +1, 0, id);
		  return array;
	}

//--------------------------------------------------------------------------------------------
	function locationOf(val, array, start, end) {
	  
	  if (array.length >0 && ptList[array[0]].orderVal < val || typeof val === "undefined") return -1;
	  start = start || 0;
	  end = end || array.length;
	  var pivot = parseInt(start + (end - start) / 2, 10);
	  if (end-start <= 1 || ptList[array[pivot]].orderVal === val) return pivot;
	  if (ptList[array[pivot]].orderVal > val || typeof ptList[array[pivot]].orderVal === "undefined") {
		return locationOf(val, array, pivot, end);
	  } else {
		return locationOf(val, array, start, pivot);
	  }
	}


//--------------------------------------------------------------------------------------------------
	function sendSelections()
	{
	  var destination = sendSelectionMenu.val();
	  var selectedIDs = identifyEntitiesInCurrentSelection();

	  var cmd = "sendSelectionTo_" + destination;
	  var payload = {value: selectedIDs, count: selectedIDs.length, source: "timelines module"};
	  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

	  sendSelectionMenu.val(sendSelectionsMenuTitle);

	  hub.send(JSON.stringify(newMsg));

	} // sendSelections
//--------------------------------------------------------------------------------------------
	function identifyEntitiesInCurrentSelection ()
	{
       currentlySelectedRegion = TimeLined3PlotBrush.extent();

	   var x1 = currentlySelectedRegion[0][0],
   		   y1 = currentlySelectedRegion[0][1],
		   x2 = currentlySelectedRegion[1][0],
		   y2 = currentlySelectedRegion[1][1],
	   	   ids = [];
	   
	   var selectedPts = ptOrderArray.slice(Math.max(Math.floor(y1)+1,0), Math.min(Math.ceil(y2), ptOrderArray.length-1));		//patient IDs within Y range
    	var AlignOp = document.getElementById("AlignOptions");
		var AlignBy = AlignOp.options[AlignOp.selectedIndex].text;
	   
	   for(var i=0; i < selectedPts.length; i++){		//return IDs with events in X range
	   	  var ptObj = ptList[selectedPts[i]];
		  var dateEvents = ptObj.dateEvents;
		  for(var j=0;j<dateEvents.length;j++){
		     if(AlignBy == "--"){
				 if(dateEvents[j].date-ptObj.offset >=x1 & dateEvents[j].date-ptObj.offset <= x2) {
					ids.push(selectedPts[i]);
					break;
		    	 } //if
		     }else{
				 if(LogTime(dateEvents[j].date-ptObj.offset) >=x1 & LogTime(dateEvents[j].date-ptObj.offset) <= x2) {
					ids.push(selectedPts[i]);
					break;
		    	 } //if
		    }
	   	  } // for dateEvents
	   } // for patients

	  return (ids);
	}

//-------------------------------------------------------------------------------------------
// when a dataset is specified, this module 
//  1) extracts the name of the dataset from the payload of the incoming msg
//  2) (for now) extracts the name of the matrices, from the manifest (also in the payload
//     of the incoming msg, chooses the first mtx.mrna entry it finds
//  3) sends a "createPLSR" message to the server, with dataset & matrix name specified
//  4) asks that the server, upon successful completion of that createPLSR request, callback
//     here so that the sliders can be set
	function datasetSpecified(msg)
	{
//	   timelinesXXX = msg;
	   var dataPackageName = msg.payload.datasetName;
        
        d = new Date();
       	then = d.getTime();
       	d = new Date();
		now = d.getTime();
		console.log("Dataset specified start: ", (now - then));
		then = now;

		   // ["mtx.cn.RData", "history.RData", "mtx.mrna.RData", "mtx.mrna.ueArray.RData", 
		   // "mtx.mut.RData", "mtx.prot.RData", "mtx.meth.RData", "markers.json.RData", 
		   // "genesets.RData", "g.markers.json"]
	   var dataElementNames = msg.payload.rownames;

		  // for now, and very temporarily, use the first match (if any are found)
	   var hits = dataElementNames.map(function(name) {if(name.indexOf("history") >= 0) return(name);});
	   hits = hits.filter(function(n){ return (n !== undefined); });

	   var dataName = null;

	   if(hits.length > 0){
			// for now always grab the first hit, remove the trailing .RData
			// the PLSR constructor wants both dataPacakgeName & a matrix name
			// our convention is that the maniftest rowname is the same as
			// its name, with ".RData" appended
		  dataName = hits[0].replace(".RData", "");
		  }
	   else{
		  return;
		  }
   
	   createTimelinesObjectOnServer();

	} // datasetSpecified
//--------------------------------------------------------------------------------------------
	function createTimelinesObjectOnServer()
	{
	  console.log("create Timelines on server ");
	  payload = "";
	  msg = {cmd: "createTimelines", callback: "DisplayPatientTimeLine", status: "request", payload: payload};
	  msg.json = JSON.stringify(msg);
	  hub.send(msg.json);

	} // createTimelinesObjectOnServer
//--------------------------------------------------------------------------------------------------     
     function handlePatientIDs(msg){
  
		if(msg.status == "success"){
             var patientIDs = msg.payload;
             
             ptOrderArray = patientIDs.filter(function(id){ return Object.keys(ptList).indexOf(id) !== -1 });
			 OrderEvents();
			 redrawSVG();
        } else{
             console.log("Timelines handlePatientIDs about to call alert: " + msg);
             alert(msg.payload);
         }

        hub.raiseTab(thisModulesOutermostDiv);


	} //handlePatientIDs
//--------------------------------------------------------------------------------------------------     
     function handleIncomingIDs(msg){
          
          if(msg.status == "request"){
             var patientIDs = msg.payload.value;
             msg = {cmd: "canonicalizePatientIDsInDataset", callback: "TimelinesHandlePatientIDs", status: "request", 
                    payload: patientIDs};
             hub.send(JSON.stringify(msg));
          }
          else{
             console.log("handlePatientIDs about to call alert: " + msg);
             alert(msg.payload);
         }
     } // handlePatientIDs



 //--------------------------------------------------------------------------------------------------
     function initDisplay(){

          console.log("======== initDisplay");

  		  svg.selectAll("g").remove();
  		  $("#timelineSVG")
				  .attr("width", TimeLineSize.width + 2*SideBarSize.width + 2*TimeLineMargin.left + 2*TimeLineMargin.right )
				  .attr("height", SideBarSize.height + TimeLineMargin.top + TimeLineMargin.bottom + legendSize.height)
				  ;
                    
          SidePlot = svg.append("g").attr("id", "SidePlotSVG")
                            .attr("transform", "translate(" + TimeLineMargin.left + "," + (TimeLineMargin.top) + ")");     
             
          TimeLine = svg.append("g").attr("id", "TimeLineSVG")
                            .attr("transform", "translate(" + (SideBarSize.width+TimeLineMargin.left + TimeLineMargin.right) + "," + (TimeLineMargin.top) + ")");
          
	}

//--------------------------------------------------------------------------------------------------
     function loadPatientDataDisplay(msg) {
          console.log("==== loadPatientDataDisplay");
       	d = new Date();
       	now = d.getTime();
		console.log("load data started: " , now - then);
		then = now;

		$('select[name="AlignOptions"] option[value="--"]').attr('selected', 'selected');
		$('select[name="OrderOptions"] option[value="--"]').attr('selected', 'selected');

		  Events = msg.payload.events;
		  ptList = msg.payload.pts;
		  EventTypes = msg.payload.eventTypes;
	  
          console.log("Event count: " + Events.length);
          console.log("Patient count: " + ptList.length);
          console.log("Category count: " + EventTypes.length);
               
		  function  separateDates(event){ 
				event.date = new Date(event.date);
				event.ptID = pt;
				if(event.eventOrder== "single")     Events[event.eventID].Fields.date = event.date;
				else if(event.eventOrder== "start") Events[event.eventID].Fields.date[0] = event.date;
				else if(event.eventOrder== "end")   Events[event.eventID].Fields.date[1] = event.date;
		  }
                    
          var i = 0; ptOrderArray = [];
          for(var pt in ptList){
        		ptList[pt].showPatient = true;  ptList[pt].PatientHeight=1;  
            	ptList[pt].offset = 0;          ptList[pt].orderVal=i;
				ptOrderArray.push(pt); i++;
				ptList[pt].dateEvents.forEach(separateDates);
		  }
		  
		  for(var event in EventTypes){		EventTypes[event].disabled = false;		  }

       	d = new Date();
       	now = d.getTime();
		console.log("Load data finished: ", now - then);		then = now;
	  
		loadDataMenus();
        redrawSVG();
          
}
//--------------------------------------------------------------------------------------------------
	function loadDataMenus(){
			  console.log("======== load.Menu") ;               

		  var dateEvents = [];
		  for(var name in EventTypes){
		  	if(EventTypes[name].dateIndicator) { dateEvents.push(name);} 
		  }
		  
		  $(".plotCategoryOptions").empty(); $(".plotValueOptions").empty();
		  $("#AlignOptions").empty(); 		 $("#AlignOptions").append("<option value='--' selected='selected'>--</option>");
		  $(".OrderByDateOptions").empty();  $(".OrderByValueOptions").empty();
		  
		  for(var elem in dateEvents){
			   $("#AlignOptions").append(" <option>"+dateEvents[elem]+"</option>");
  			   $(".OrderByDateOptions").append(" <option class='OrderByDate'>"+dateEvents[elem]+"</option>");
			             
               $("#Event1").append("<option value='"+ dateEvents[elem] +"'>"+ dateEvents[elem] +"</option>");
               $("#Event2").append("<option value='"+ dateEvents[elem] +"'>"+ dateEvents[elem] +"</option>");
		  }
		  var CalculatedEvents = ptList[ptOrderArray[0]].calcEvents;
		  for(var ev in CalculatedEvents){
			   $(".OrderByValueOptions").append(" <option>"+CalculatedEvents[ev].name+"</option>");
			   $(".plotValueOptions").append(" <option>"+CalculatedEvents[ev].name+"</option>");
		  }
	  
	}
//--------------------------------------------------------------------------------------------------
	function loadLegend(){
          legend = svg.append("g")
                          .attr("class", "legend")
                          .attr("transform", "translate(" + (SideBarSize.width+2* TimeLineMargin.left + TimeLineMargin.right) + "," + (0) + ")")
         			      .selectAll(".legend")
                          .data(TimeLineColor.domain().filter(function(d){
                                return Object.keys(EventTypes).indexOf(d) !== -1; })  )
                          .enter().append("g")
                            .attr("transform", function(d, i) { 
                                  return "translate(" + i*TextOffSet(d) + ",0)" ;})
                          ;
          legend.append("rect")
                .attr("rx", 2)
                .attr("ry", 2)
                .attr("width", 10)
                .attr("height", 10)
                .style("fill", function(d) { return TimeLineColor(d);})
                .on("click", ToggleVisibleEvent);

          legend.append("text")
                .attr("y", 9)
                .attr("x", 12)
                .style("font-size", "12px")
                .text(function(d) { return d; });
                
          legend[0].forEach(function(d){
        	if(EventTypes[d.textContent].disabled)
        		d.children[0].style.opacity = 0.2
          })
	}
 //--------------------------------------------------------------------------------------------------     
     function ToggleVisibleEvent(d){
         
         EventTypes[d].disabled = !EventTypes[d].disabled;
         if(EventTypes[d].disabled)
           d3.select(this).style("opacity", 0.2);
         else
           d3.select(this).style("opacity", 1);

          plotTimelines();
     }

//--------------------------------------------------------------------------------------------------
        function updateDisplayAlignment(){
			AlignEvents(); 
			plotTimelines();
        }
//--------------------------------------------------------------------------------------------------
        function updateDisplayOrder(){
			var OrderOp = document.getElementById("OrderOptions");
			var OrderBy = OrderOp.options[OrderOp.selectedIndex].text;

			 if(OrderBy === "+Add"){
//				console.log("== changing OrderBy with ", OrderBy);
//				OpenDialogForAddedEvents("OrderBy");
			 }else{
				console.log("== changing OrderBy " + OrderBy);
				OrderEvents();      
				plotTimelines();
				plotSideBar();
			 }        
        }
//--------------------------------------------------------------------------------------------------
        function updateDisplaySidePlot(){
			var SideOp = document.getElementById("SideBarOptions");
			var SideBy = SideOp.options[SideOp.selectedIndex].text;

				 if(SideBy === "+Add"){
			//		console.log("== changing SideBar with ", SidePlotEvent);
			//		OpenDialogForAddedEvents("SidePlot");
				 } else{ 
					console.log("== changing SideBar", SideBy);
					plotSideBar();
				 }
        
        }

//--------------------------------------------------------------------------------------------------
        function getTimelineXoptions(){
				var AlignOp = document.getElementById("AlignOptions");
				var AlignBy = AlignOp.options[AlignOp.selectedIndex].text;

               if(AlignBy === "--"){ 
                  x = d3.time.scale().range([0, TimeLineSize.width]); 
                  TimeScale =1;
                  Xtitle="Year";
                  xAxis = d3.svg.axis().scale(x).orient("bottom");
               } else{
                  x =  d3.scale.linear().range([0, TimeLineSize.width]);
                  TimeScale = OneDay;
                  Xtitle = "Days";
                  xAxis = d3.svg.axis().scale(x).orient("bottom")
                            .ticks(10)
                            .tickFormat(function (d) { 
                               var Dir = (d<0 ? -1 : 1); 
                               return Math.round(Dir * (Math.pow(2, (Math.abs(d)))-1) *100)/100;
                            });
//                            .attr("width", 1440);
               }
            return {AlignBy: AlignBy, scale: x, timescale: TimeScale, title: Xtitle, axis: xAxis};
        }

//--------------------------------------------------------------------------------------------------
		function plotTimelines(){

               console.log("======== DisplayPatients.TimeLineDisplay");
      	d = new Date();
       	now = d.getTime();
		console.log("plot Timelines start: ",now - then);		then = now;

 		TimeLine.selectAll("g").remove();

			//------  Define Ranges
                var y = d3.scale.linear().range([TimeLineSize.height, 0]), 
                    yAxis = d3.svg.axis().scale(y).orient("left").ticks(0);
            
				var X = getTimelineXoptions();  //scale,TimeScale, title, axis

				var EventMin= null, EventMax = null;
				var allEvents = [];
				ptOrderArray.filter(function(id){ return ptList[id].showPatient }).forEach(function(d){  //return d.showPatient && !d.disabled;}), 
					var activeEvents = ptList[d].dateEvents.filter(function(event){ return !EventTypes[event.name].disabled; });
					if(activeEvents.length >0){
  					   allEvents = allEvents.concat(activeEvents);
  					   var first = (X.AlignBy == "--" ? activeEvents[0].date :                       LogTime((activeEvents[0].date - ptList[d].offset), X.TimeScale));
  					   var last  = (X.AlignBy == "--" ? activeEvents[activeEvents.length-1].date :   LogTime((activeEvents[activeEvents.length-1].date - ptList[d].offset), X.TimeScale));
					   if(EventMin === null || EventMin > first) EventMin = first;
					   if(EventMax === null || EventMax < last ) EventMax = last;
					}
                });  

               X.scale.domain([EventMin, EventMax]);
               y.domain([-2, ptOrderArray.length+1]);


			//------  Set axes
			   			
               TimeLine.append("g")
                       .attr("class", "x axis").attr("transform", "translate(0," + TimeLineSize.height + ")").call(X.axis)
                       .append("text").style("font-size", "12px").text(X.title);
               TimeLine.append("g")
                       .attr("class", "y axis").call(yAxis)
                       .append("text").attr("transform", "rotate(-90)").attr("y", 2).attr("dy", "-.71em")
                       .style("text-anchor", "end").style("font-size", "12px").text("Patients");
               var PixelScale = Math.max(Math.min(y(0)-y(1), 20), 3);
               console.log(PixelScale);
				// y domain doesn't filter by showPatient or event disabled - showPatient set to false when lacks AlignBy element so has blank row in timeline
 

			//------  Add mouse Features
               var Hoverbar = TimeLine.append("g").attr("class", "hoverbar");

               				  
               TimeLined3PlotBrush = d3.svg.brush().x(X.scale).y(y)
                                       .on("brushend", identifyEntitiesInCurrentSelection);
               TimeLine.call(TimeLined3PlotBrush);

                            
			//------ Define Event plot styles
				
				var openEventStack = [], eventPathAttr = [];
	
	            	function rect_eventParams(prior, event){
					if( typeof prior == "undefined" || typeof event == "undefined")
					  console.log("ERROR: event dates not properly specified", prior, event);
					var x = (X.AlignBy == "--" ? X.scale(prior.date) : X.scale(LogTime((prior.date - ptList[prior.ptID].offset), X.TimeScale)) ),
						x2 =(X.AlignBy == "--" ? X.scale(event.date) : X.scale(LogTime((event.date - ptList[event.ptID].offset), X.TimeScale)) ),
					    Y = y(ptOrderArray.indexOf(prior.ptID)) + PixelScale/(ptList[prior.ptID].PatientHeight+1),
					    width = x2-x,
					    height = PixelScale/ptList[event.ptID].PatientHeight,
					    fill = d3.rgb(TimeLineColor(prior.name)),
					    eventIDs = openEventStack.concat([event]),
					    id = event.ptID;
    			    if(width<3) width= 3;
					return {id:id,x:x, y:Y, height:height, width:width, fill:fill, eventIDs: eventIDs};
	  		    }
  
  				var prior;
                allEvents.forEach(function(event){
                     if(event.eventOrder == "single"){
                        eventPathAttr.push(rect_eventParams(event, event));
                    } else if(event.eventOrder == "start"){ 
                        if(openEventStack.length > 0) 						//start draw at end of interval (not beginning of line)
                       	    eventPathAttr.push(rect_eventParams(prior, event)); 
                       	prior  = event; 
                        openEventStack.push(event); 
                    } else if(event.eventOrder == "end"){
	                    	openEventStack = openEventStack.filter(function(ev){ return ev.eventID != event.eventID; }) ; //remove all matching eventID from stack
							eventPathAttr.push(rect_eventParams(prior, event));	   
							prior = event;
                    }
                });

			//------ plot Events in Timeline
                 var TimeSeries = TimeLine.append("g").selectAll("rect");

                 TimeSeries.data(eventPathAttr).enter().append("rect").attr("class", "rect")                 
                    	 .attr("x",      function(d) { return d.x; })
                    	 .attr("rx",     function(d) { return 5;})
                    	 .attr("ry",     function(d) { return 5;})
                    	 .attr("width",  function(d) { return d.width; })
                    	 .attr("y",      function(d) { return d.y; })
                    	 .attr("height", function(d) { return d.height; })
                    	 .attr("stroke", function(d) { return d.fill; })
                    	 .attr("border-radius", "20px")
                    	 .attr("fill", function(d){ 
                    	 	if(d.eventIDs.length >1)
                    	 		return "url(#diagonalHatch)";
                    	 	return d.fill; 
                    	 })
//	                     .attr("stroke-width", function(d){return d.strokeWidth;})
                         .on("mouseover", function(d,i){
                             Hoverbar.append("rect")
                                .attr("x", (0 - 2*SideBarSize.width ))
                                .attr("y", function(){return y(ptOrderArray.indexOf(d.id))+ PixelScale/(ptList[d.id].PatientHeight+1);})
                                .attr("width", TimeLineSize.width + 2*SideBarSize.width +TimeLineMargin.left)
                                .attr("height", function(){return PixelScale;})
                                .style("fill", "grey").style("opacity", 0.3);    
							 
							 tooltip.style("left", function(){ 
							 			var tipOffset = $(window).width() - (d3.event.pageX +400) ;
							 			tipOffset = (tipOffset < 0 ? tipOffset : 0);
							 			var tipOffsetString = (d3.event.pageX + tipOffset) + "px";
							 			return tipOffsetString; })		
							 		.style("top", (d3.event.pageY+5) + "px")
							 		.style("height", "250px").style("width", "350px");	
							 tooltip.html(function(){
								var EventsString = "<span ><b>" + Events[d.eventIDs[0].eventID].PatientID + ": </b>("+Events[d.eventIDs[0].eventID].study +")<br/>"; 
								for(i=0;i<d.eventIDs.length; i++){
									var Fields = Events[d.eventIDs[i].eventID].Fields;
									EventsString = EventsString + "<br/><b>"+ Events[d.eventIDs[i].eventID].Name + "</b><br/>";
									for(var f in Fields) { 
										if(f == "date"){
											if(Fields[f].length >1){
												EventsString = EventsString + f + ": " + getFormattedDate(Fields[f][0]) + ", "+ getFormattedDate(Fields[f][1]) + "<br/>"; 
											}else{
												EventsString = EventsString + f + ": " + getFormattedDate(Fields[f]) + "<br/>"; 
											}
										}else{    		
											EventsString = EventsString + f + ": " + Fields[f] + "<br/>"; }
										}
								}
			                    return EventsString + "</span>"; });
			                     $("#tooltipDiv").removeClass("eventNoHover").addClass("eventHover");})
                         .on("mouseout", function(d){
                            Hoverbar.select("rect").remove();
							setTimeout(function () {
								 $("#tooltipDiv").removeClass("eventHover").addClass("eventNoHover");}, 500);
                            })
                         .on("mousemove", function(){
                            return tooltip.style("top",(d3.event.pageY+5)+"px")
                            		.style("left",function(){ 
							 			var tipOffset = $(window).width() - (d3.event.pageX +400) ;
							 			tipOffset = (tipOffset < 0 ? tipOffset : 0);
							 			var tipOffsetString = (d3.event.pageX + tipOffset) + "px";
							 			return tipOffsetString; });  });
//                         .attr("data-legend",function(d) { return d.name;});

  	hub.enableTab(thisModulesOutermostDiv);

      	d = new Date();
       	now = d.getTime();
		console.log("plot Timelines finished: ", (now - then));		then = now;


	}  

//--------------------------------------------------------------------------------------------------
	function plotSideBar(){

		console.log("======== plotSideBar");
   			
   		SidePlot.selectAll("g").remove();
 
		   var x     = d3.scale.linear().range([0, SideBarSize.width]),
			   y     = d3.scale.linear().range([SideBarSize.height, 0]), 
			   xAxis = d3.svg.axis().scale(x).orient("bottom"),
			   yAxis = d3.svg.axis().scale(y).orient("left").ticks(0),
			   xTitle = ""
			   ;
			
               y.domain([-2, ptOrderArray.length+1]);
		   var PixelScale = d3.max([d3.min([y(0)-y(1), 20]), 3]);
		   console.log("PixelScale", PixelScale);
															
		   var barAttr = [];

			var SideOp = document.getElementById("SideBarOptions");
			var SideSel = SideOp.options[SideOp.selectedIndex];
			var SideplotVal = SideSel.text;
		
	   		if(SideSel.parentNode.label == "Category"){
			} else if(SideSel.parentNode.label == "Value"){
				var calc = ptList[ptOrderArray[0]].calcEvents;
				var typeNum = -1;
				for(var k=0;k<calc.length;k++){ 
					if(calc[k].name == SideplotVal){ typeNum = k; break; }
				}
				if(typeNum !== -1){
					barAttr =  getHorizontalBarSize(typeNum); 
					xTitle = barAttr[0].timeScale;
				}
			}

		   x.domain([d3.min([d3.min(barAttr, function(d){return d.width;}),d3.min(barAttr, function(d){return d.xBar;})]),
							 d3.max(barAttr, function(d){ return d.xBar + d.width;})]).nice();

		   SidePlot.append("g").attr("class", "x axis")
				   .attr("transform", "translate(0," +SideBarSize.height + ")").call(xAxis)
				   .selectAll("text").style("text-anchor", "end")
				   .style("font-size", "12px")
				   .attr("dy", ".55em").attr("dx", "-.45em")
				   .attr("transform", function(d) {return "rotate(-75)"; });
		   SidePlot.append("g").append("text")
				   .attr("transform", "translate(0," +SideBarSize.height + ")")
				   .style("font-size", "12px").text(xTitle);
		   SidePlot.append("g").attr("class", "y axis").call(yAxis)
				   .append("text").attr("transform", "rotate(-90)")
				   .attr("y", 2).attr("dy", "-.71em")
				   .style("font-size", "12px").style("text-anchor", "end")
				   .text(SideplotVal);
	
		   var BarPlot_Horiz = SidePlot.append("g").selectAll("rect")
				   .data(barAttr).enter().append("rect")
					 .attr("x", function(d)     { return x(d.xBar);  })
					 .attr("y", function(d)     { return y(d.yBar) + PixelScale/(ptList[d.id].PatientHeight+1); })   // rectangles draw from top down
					 .attr("width", function(d) { return Math.abs(x(d.width) - x(0));  })
					 .attr("height", function(d){ return PixelScale; }) 
					 .attr("fill", function(d){ 
						  var ColorShade =  d3.rgb("gray"); 
//						  if(EventTypes.keys().indexOf(SidePlotEvent) !== -1) { ColorShade = d3.rgb(TimeLineColor(SidePlotEvent)); }
						  return ColorShade;  })
					 .on("mouseover", function(d,i){
  						 tooltip.style("top",(d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");
  						 tooltip.style("height", "100px").style("width", "150px");
                         tooltip.text(d.id + ": " + d.info);
                         $("#tooltipDiv").removeClass("eventNoHover").addClass("eventHover");})
                     .on("mouseout", function(){
						 setTimeout(function () { $("#tooltipDiv").removeClass("eventHover").addClass("eventNoHover"); }, 500); })  //
					 .on("mousemove", function(){
                              return tooltip.style("top",(d3.event.pageY-50)+"px").style("left",(d3.event.pageX+10)+"px");})
;
	}
//--------------------------------------------------------------------------------------------------     
     function getHorizontalBarSize(Valtype){
     // ~~ is shortcut for Math.floor()
     
       var BarSizes = [];
		for(var i=0; i<ptOrderArray.length; i++){
			var calcEvent = ptList[ptOrderArray[i]].calcEvents[Valtype];
               var xBar = 0; var barWidth = calcEvent.value;
               if(typeof calcEvent.value === "undefined") barWidth = 0;
               if(calcEvent.value < 0){ xBar = calcEvent.value; barWidth = Math.abs(calcEvent.value);  }
               BarSizes.push( {id: ptOrderArray[i], info: calcEvent.value, xBar: xBar, yBar: i,  width: barWidth, timeScale: calcEvent.units});
       }
       return BarSizes;
     }

//--------------------------------------------------------------------------------------------------
     function updatePtOrderArray(enterIDs, exitIDs){

		var tempArray = ptOrderArray.filter(function(pt){ return exitIDs.indexOf(pt) === -1;});
		enterIDs.forEach(function(id){ 
 			tempArray = insertAscending(id, tempArray);
		});
		ptOrderArray = tempArray;
	 }
//--------------------------------------------------------------------------------------------------
     function setOrderByVal(id){
		var OrderOp = document.getElementById("OrderOptions");
		var OrderSel = OrderOp.options[OrderOp.selectedIndex];
		var OrderBy = OrderSel.text;
		
		ptList[id].orderVal = null;
		
   		if(OrderSel.parentNode.label == "Date"){
        	var dateEvents = ptList[id].dateEvents;
            for(var i=0;i<dateEvents.length; i++){
            	if(dateEvents[i].name == OrderBy){
            		ptList[id].orderVal = dateEvents[i].date;
            		break; 
            	}
            }
        	
    	} else if(OrderSel.parentNode.label == "Value"){
    		calcEvents = ptList[id].calcEvents;
    		for(var j=0;j<calcEvents.length; j++){
            	if(calcEvents[j].name == OrderBy){
					ptList[id].orderVal = calcEvents[j].value;
            		break; 
            	}
            }    
    	}

		return ptList[id].orderVal;

	}

//--------------------------------------------------------------------------------------------------
     function OrderEvents(){
     
		var OrderOp = document.getElementById("OrderOptions");
		var OrderBy = OrderOp.options[OrderOp.selectedIndex].text;
		
		var tempArray = [];
		for(var i=0;i<ptOrderArray.length;i++){
			setOrderByVal(ptOrderArray[i]);
			tempArray = insertAscending(ptOrderArray[i], tempArray);
		}
		ptOrderArray = tempArray;
	 }
//--------------------------------------------------------------------------------------------------
     function AlignEvents(){
     
		var AlignOp = document.getElementById("AlignOptions");
		var AlignBy = AlignOp.options[AlignOp.selectedIndex].text;

		var enterPts = [], removePts = [];  
        console.log("========Align Event: "+ AlignBy);
        
        for(var pt in ptList){ 
          	if(AlignBy == "--"){
          		ptList[pt].offset = 0; 
				ptList[pt].showPatient=true;
				setOrderByVal(pt);
//				if(ptOrderArray.indexOf(pt) === -1) enterPts.push(pt);
          	}else{
				ptList[pt].offset = null; 
				ptList[pt].showPatient=false;
		  
				var dateEvents = ptList[pt].dateEvents;
				for(var i=0;i<dateEvents.length; i++){
					if(dateEvents[i].name == AlignBy){
						ptList[pt].showPatient=true;
						ptList[pt].offset = dateEvents[i].date;
//						if(ptOrderArray.indexOf(pt) === -1) enterPts.push(pt);
						break; 
					}
				}
//				if(!ptList[pt].showPatient) {removePts.push(pt);}
			}
 		}
//		updatePtOrderArray(enterPts, removePts);
     }     

//--------------------------------------------------------------------------------------------------
   
   return{
          init: function(){
                hub.addOnDocumentReadyFunction(initializeUI);
                hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
                hub.addMessageHandler("sendSelectionTo_Timelines", handleIncomingIDs);
                hub.addMessageHandler("DisplayPatientTimeLine", loadPatientDataDisplay);
                hub.addMessageHandler("TimelinesHandlePatientIDs", handlePatientIDs);
                hub.addMessageHandler("datasetSpecified", datasetSpecified);
          },
     };

}); // TimeLineModule
//----------------------------------------------------------------------------------------------------
PatientTimeLine = TimeLineModule();
PatientTimeLine.init();


//----------------------------------------------------------------------------------------------------
// move these all back inside module scope when debugging is done

var cwMarkers;
var markersTester;

//----------------------------------------------------------------------------------------------------
var markersAndTissuesModule = (function () {

  var statusDiv; 
  var cyDiv;
  var searchBox;
  var hideEdgesButton, showEdgesButton, showAllEdgesButton, clearSelectionButton, sfnButton;
  var markersFitViewButton, markersHideEdgesButton, markersShowEdgesButton, markersZoomSelectedButton;

  var nodeRestriction = [];
  var subSelectButton;
  var helpButton;
  var infoMenu;
  var zoomMode = "Spread";
  var initialZoom;
  var oldZoom;
  var edgeTypeSelector;
  var mouseOverReadout;
  var graphOperationsMenu;
  var tumorCategorizationsMenu;
  var tumorCategorizationsMenuTitle = "Tumor Groups...";
  var sendSelectionsMenu;
  var layoutMenu;
  var thisModulesName = "MarkersAndPatients";
  var thisModulesOutermostDiv = "markersAndPatientsDiv";
  var userID = "NA";

     // assigned on first load, used when tumor groups are cleared
  var defaultPatientNodeColor = "black";  

      // sometimes a module offers multiple selection destinations.
      // usually there is just one:

  var selectionDestinations = [thisModulesName];


  var sendSelectionsMenuTitle = "Send selection...";

     // the user may specify that only certain tumors, and/or certain genes
     // are to be used in any subsequent network operations -- especially
     // "show edges from selected nodes"
     // to experiment with this capability, there are two new net ops menu
     // options, which assign zero or more selected nodes to these variables,
     // which are then used (if defined) to limit the subsequent network
     // operation


//--------------------------------------------------------------------------------------------
function initializeUI ()
{

  cyDiv = $("#cyMarkersDiv");
  statusDiv = $("#markersAndPatientsStatusDiv");

  sendSelectionsMenu = hub.configureSendSelectionMenu("#cyMarkersSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                      sendSelectionsMenuTitle);

  markersFitViewButton = $("#markersFitViewButton");
  markersFitViewButton.click(function(){cwMarkers.fit(50);});
  
  markersZoomSelectedButton = $("#markersZoomSelectedButton");
  markersZoomSelectedButton.click(zoomSelected);

  markersHideEdgesButton = $("#markersHideEdgesButton");
  markersHideEdgesButton.click(hideAllEdges);
  hub.disableButton(markersHideEdgesButton);
  
  markersShowEdgesFromButton = $("#markersShowEdgesFromSelectedButton");
  markersShowEdgesFromButton.click(showEdgesFromSelectedNodes);
  hub.disableButton(markersShowEdgesFromButton);

  //$("#markersFitViewButton").click(function(){cwMarkers.fit();});
  //$("#markersHideEdgesButton").click(hideAllEdges);
  //$("#markersShowEdgesFromSelectedButton").click(showEdgesFromSelectedNodes);

  tumorCategorizationsMenu = $("#cyMarkersTumorCategorizationsMenu");
  tumorCategorizationsMenu.empty();
  tumorCategorizationsMenu.append("<option>" + tumorCategorizationsMenuTitle + "</option>");
  tumorCategorizationsMenu.change(requestTumorCategorization);

  graphOperationsMenu = $("#cyMarkersOperationsMenu");
  graphOperationsMenu.change(doGraphOperation);
  graphOperationsMenu.empty();
  graphOperationsMenu.append("<option>Network Operations...</option>");

  var operations = ["Show All Edges",
                    "Show Edges from Selected Nodes",
                    "Hide All Edges",
                    //"Connect to First Neighbors",
                    "Invert Node Selection",
                    "Clear Selections",
                    "Select All Connected Nodes",
                    "Select All Nodes with Selected Edges",
                    "Hide Unselected Nodes",
                    "Show All Nodes",
                    "Restrict Next Ops to Selected Nodes"];

  for(var i=0;i< operations.length; i++){
     var optionMarkup = "<option>" + operations[i] + "</option>";
     graphOperationsMenu.append(optionMarkup);
     } // for 


   layoutMenu = $("#markerLayouts");
   layoutMenu.change(performLayout);

   showEdgesButton = $("#cyMarkersShowEdgesButton");
   showEdgesButton.click(showEdges);
   
   showAllEdgesButton = $("#cyMarkersShowAllEdgesButton");
   showAllEdgesButton.click(showAllEdges);

   sfnButton = $("#cyMarkersSFNButton");
   sfnButton.click(selectFirstNeighbors);
   clearSelectionButton = $("#cyMarkersClearSelectionButton");
   clearSelectionButton.click(clearSelection);

   hideEdgesButton = $("#cyMarkersHideEdgesButton");
   hideEdgesButton.click(hideAllEdges);


   searchBox = $("#markersAndTissuesSearchBox");

   edgeTypeSelector = $("#markersEdgeTypeSelector");
   edgeTypeSelector.chosen();

   mouseOverReadout = $("#markersAndTissuesMouseOverReadout");
   configureCytoscape();
   $(window).resize(handleWindowResize);

   subSelectButton = $("#markersSubSelectButton");
   subSelectButton.click(subSelectNodes);

   setInterval(buttonAndMenuStatusSetter, 500);
      
   hub.disableTab(thisModulesOutermostDiv);
 
} // initializeUI
//----------------------------------------------------------------------------------------------------
// some buttons and menu are live or disabled depending on the presence of e.g., selected nodes
// or visible (non-chromosome) edges.   check those things and set their states appropriately

function buttonAndMenuStatusSetter()
{
   var selectedNodes = cwMarkers.nodes("node:selected");
   var selectedNodeCount = selectedNodes.length;
   $("#markersSelectionCountReadout").val(selectedNodeCount);
   
   var selectedPatientNodes = cwMarkers.nodes("node[nodeType='patient']:selected");
   var selectedPatientNodeCount = selectedPatientNodes.length;
   
   if(selectedNodeCount === 0){
      hub.disableButton(sendSelectionsMenu);
      hub.disableButton(markersShowEdgesFromButton);
      hub.disableButton(markersZoomSelectedButton);
      }
   else{
      hub.enableButton(sendSelectionsMenu);
      hub.enableButton(markersShowEdgesFromButton);
      hub.enableButton(markersZoomSelectedButton);
      }
      
      // the Subselect button is only on if a primary selection has been made
   var categories = selectedPatientNodes.map(function(e) {return e.data().category;});
   var categoriesPresent = categories.filter(function(e){return e;}).length > 0;  // undefined & null filtered out

   if(selectedPatientNodeCount > 0 & categoriesPresent)
      hub.enableButton(subSelectButton);
   else
      hub.disableButton(subSelectButton);
   

   var visibleEdges = cwMarkers.edges().fnFilter(function(e){return(e.visible());})
                                       .fnFilter(function(e){return(e.data("edgeType") != "chromosome");}).length;
   if(visibleEdges > 0)
       hub.enableButton(markersHideEdgesButton);
   else
       hub.disableButton(markersHideEdgesButton);

} // buttonAndMenuStatusSetter
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function configureLayoutsMenu(layoutMenu){

   console.log("--- configureLayoutsMenu");
   layoutMenu.append("<option>Layouts...</option>");
   layoutMenu.append("<option> Save Current</option>");

   var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
          var result = {id:n.id(), position:n.position()};
          return (result);  
          }) // map
       ); // stringify

   localStorage.markersDefault = defaultLayout;

   var existingLayouts = Object.keys(localStorage);
   for(var i=0; i < existingLayouts.length; i++){
      if(existingLayouts[i].match("markers") !== null){
        layoutMenu.append("<option>" + existingLayouts[i] + "</option>");
        }
      } // for i

} // configureLayoutsMenu
//----------------------------------------------------------------------------------------------------
function performLayout(event){

  var chosenLayoutName = layoutMenu.val();

  if(chosenLayoutName == "Save Current"){
     var uniqueNumber = Math.floor(new Date().getTime()/1000);   // number of seconds since 1970
     newName = "markers." + (uniqueNumber - 1420414900);    // since today, very roughly
     var positions = cwMarkers.nodes().map(function(n){
           var result = {id:n.id(), position:n.position()};
           return(result);
           }); // map
     currentLayout = JSON.stringify(positions);
     localStorage[newName] = currentLayout;
     layoutMenu.append("<option>" + newName + "</option>");
     layoutMenu.val(newName);
     return;
     } // if "Save Current"

  if(Object.keys(localStorage).indexOf(chosenLayoutName) >= 0){
     var newLayout;
     newLayout = JSON.parse(localStorage[chosenLayoutName]);
     cwMarkers.nodes().positions(function(i, node){
        return{x: newLayout[i].position.x, y:newLayout[i].position.y};
         });
     } // if requested layout name is recognized
  
  layoutMenu.val("Layouts...");   // restore the title

} // performLayout
//--------------------------------------------------------------------------------------------
function sendSelection()
{
   destinationModule = sendSelectionsMenu.val();
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }
   metadata = {};
   sendSelectionToModule(destinationModule, nodeNames, metadata);
   sendSelectionsMenu.val("Send Selection...");

} // sendSelectionsMenuChanged
//--------------------------------------------------------------------------------------------
function configureCytoscape ()
{
  cwMarkers = $("#cyMarkersDiv");
  cwMarkers.cytoscape({
     hideEdgesOnViewport: false,
     hideLabelsOnViewport: false,
     boxSelectionEnabled: true,
     showOverlay: false,
     minZoom: 0.001,
     maxZoom: 1000.0,
     layout: {
       name: "preset",
       fit: true
       },
   ready: function() {
      console.log("cwMarkers ready");
      cwMarkers = this;
      initialZoom = cwMarkers.zoom();
      var debouncedSmartZoom = debounce(smartZoom, 20);
      cwMarkers.on('zoom', debouncedSmartZoom);
      cwMarkers.on('pan', debouncedSmartZoom);

      cwMarkers.on('mouseover', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val(node.id());
         });
      cwMarkers.on('mouseout', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val("");
         });
      cwMarkers.on('mouseover', 'edge', function(evt){
         var edge = evt.cyTarget;
         var d = edge.data();
         var msg = d.edgeType + ": " + d.source + " - " + d.target;
         var mutation = d.mutation;
         if(typeof(mutation) == "string")
            msg = mutation + " " + msg;
         mouseOverReadout.val(msg);
         });

      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      searchBox.keydown(doSearch);

      console.log("cwMarkers.reset");
      cwMarkers.reset();
      handleWindowResize();
      cwMarkers.edges().selectify(); // this seems to hold through session, visibility notwithstanding
      //hideAllEdges();
      configureLayoutsMenu(layoutMenu);
      cwMarkers.fit(50);
      }, // cwMarkers.ready
     }); // .cytoscape

} // configureCytoscape
//----------------------------------------------------------------------------------------------------
function handleWindowResize ()
{
   cyDiv.width(0.95 * $(window).width());
   cyDiv.height(0.8 * $(window).height());
   cwMarkers.resize();
   cwMarkers.fit(50);

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate)
{
   var timeout;
   return function() {
      var context = this, args = arguments;
      var later = function() {
         timeout = null;
         if (!immediate) func.apply(context, args);
          };
       var callNow = immediate && !timeout;
       clearTimeout(timeout);
       timeout = setTimeout(later, wait);
       if (callNow) func.apply(context, args);
       };
}
//----------------------------------------------------------------------------------------------------
// expand node size and display node labels when:
//   1) the user's coordinate space, due to zooming, has shrunk to < 600 pixels
//   2) the zoom factor is so large relative to the initial zoom (a global variable, set on startup)
// 
function smartZoom(event)
{
   //console.log("smartZoom");
   var queuedEvents = $("#cyMarkersDiv").queue();
   
   var zoomRatio = cwMarkers.zoom()/initialZoom;
   console.log("zoomRatio: " + zoomRatio);

   if(zoomRatio < 1.0){
      defaultStyle();
      return;
      }
      
   var visibleCoords = cwMarkers.extent();
   var visibleOnScreen = function(node){
      if(node.data("landmark"))
         return(false);
      //var x = node.position().x;
      //var y = node.position().y;
      var bbox = node.boundingBox();
      var visibleX = (bbox.x1 >= visibleCoords.x1 && bbox.x1 <= visibleCoords.x2) |
                     (bbox.x2 >= visibleCoords.x1 && bbox.x2 <= visibleCoords.x2);
      if(!visibleX)
        return false;
      var visibleY = (bbox.y1 >= visibleCoords.y1 && bbox.y1 <= visibleCoords.y2) |
                     (bbox.y2 >= visibleCoords.y1 && bbox.y2 <= visibleCoords.y2);
      return(visibleY);
      //return(x >= visibleCoords.x1 && x <= visibleCoords.x2 &&
      //       y >= visibleCoords.y1 && y <= visibleCoords.y2);
      };
      
   //console.log("starting calculation of visibleNodes");
   var visibleNodes = cwMarkers.nodes().fnFilter(function(node){return(visibleOnScreen(node));});		
   console.log("visibleNode count: " + visibleNodes.length);
   if(visibleNodes.length > 400){
      defaultStyle();
      //console.log("returning, visibleNode count: " + visibleNodes.length);
      return;
      }
   //console.log("need to smartZoom, setting hanlder off to discard queued events");
   //cwMarkers.off(zoom', smartZoom);

   //console.log(event);
   var newZoom = 1.0 + cwMarkers.zoom() - oldZoom;
   oldZoom = cwMarkers.zoom(); // keep this for next time

   //console.log("complete");

      // TODO: these two ratios might be reduced to just one
      
   var windowRatio = cwMarkers.width()/cwMarkers.extent().h;
   
   var fontSize = cwMarkers.extent().h/60;
   if(fontSize < 0.6)
     fontSize = 0.6;
     
   var fontSizeString = fontSize + "px";
   var borderWidthString = cwMarkers.extent().h/600 + "px";
   //console.log("--- new fontsize: " + fontSizeString);
   //console.log("--- new borderWidth: " + borderWidthString);
   cwMarkers.edges().style({"width": borderWidthString});
   
   var newWidth, newHeight, id;
   var factor = 1.5; // 3
   cwMarkers.batch(function(){
      visibleNodes.map(function(node){
         newWidth = factor *  node.data("trueWidth") / zoomRatio;
         newHeight = factor *  node.data("trueHeight") / zoomRatio;
         id = node.id();
         node.data({zoomed: true});
         node.style({width: newWidth, height: newHeight, label: id, "font-size": fontSizeString,
                    "border-width": borderWidthString});
         });
       });

  //console.log("visibleNode mapping complete, adding smartZoom handler back");
  //cwMarkers.on('zoom', smartZoom);


} // smartZoom
//----------------------------------------------------------------------------------------------------
function defaultStyle()
{
   var zoomedNodes = cwMarkers.nodes("[zoomed]");
   // console.log("restoring default style, zoomed node count: " + zoomedNodes.length);
   cwMarkers.edges().style({"width": "1px"});
   
   zoomedNodes.map(function(node){node.style({width: node.data('trueWidth'),
                                              height: node.data('trueHeight'),
                                              zoomed: false,
                                             'border-width': "1px",
                                             'font-size': "3px"});});

} // defaultStyle
//----------------------------------------------------------------------------------------------------
// tumor (patient, sample) nodes can be categorized, usually based upon independent biology,
// expressed in simple named tables included in each data package.  Each sample group in these
// tables is assigned a color for distinctive display.
// here we present a simple dialog so that one or more categories within the current selection
// can be subselected
//
function subSelectNodes()
{
  var selectedPatientNodes = cwMarkers.nodes("node[nodeType='patient']:selected");
  var categories = jQuery.unique(selectedPatientNodes.map(function(e){return e.data("category");}));

  var colors = jQuery.unique(selectedPatientNodes.map(function(node){return (node.style("background-color"));}));

  var content = "<form action=''>";
  for(i=0; i < categories.length; i++){
     var category = categories[i];
     var color = colors[i];
     var selector = "[category='" + category + "']:selected";
     var count = cwMarkers.nodes(selector).length;
     var id = "cb" + i;
     var e = "<html><body><input id='" + id + "' type='checkbox' class='markersSubSelectRadioButton' name='" + category + "'" +
             " style='background':'" + color + "'" + " checked> " +
             "<label for='" + id + "' style='color:" + color + "'>" + category + " (" + count + ")</label><br></body></html>";
     content = content + e;
     }
  content = content + "</form>";
  button = "<br><br><button id='markersSubSelectCloseButton'>Close</button>";

  content = content + button;

  var dialog = $('<div id="markersSubSelectDialog" />').html(content).dialog({title:"Subselect by Sample Category",
                                                                              width: "500px"});

  $("#markersSubSelectCloseButton").click(function(){
     console.log("about to remove subselect dialog");
     $("#markersSubSelectDialog").remove();
     });

  $(".markersSubSelectRadioButton").click(function(e) {
      var category = this.name;
      var doSelectNodes = this.checked;
      var subsetNodes = selectedPatientNodes.filterFn(function(e){return(e.data("category") === category);});
      if(doSelectNodes)
         subsetNodes.select();
      else
         subsetNodes.unselect();
      }); // radio button click

} // subSelectNodes
//----------------------------------------------------------------------------------------------------
// patient (sample, tumor) nodes sometimes get category data attached: the tumorCategorizationsMenu
// initiates that process.  the server supplies (nodeID, cluster|group, color) triples, one for
// each categorized tumor.  we place the group into a category field in the node's data, and collapse
// all the color/category assignments down into a few style rules.
// in this function, all of that (possibly) present information is stripped out.
function clearTumorCategoriesAndCategoryStyles()
{
   var patientNodes = cwMarkers.nodes("node[nodeType ='patient']");
   cwMarkers.batch(function(){
      patientNodes.map(function(e){if("category" in e.data()) delete e.data().category;});
      });
      
   var oldStyle = cwMarkers.style().json();
   var newStyle = oldStyle.filter(function(e){return(e.selector.indexOf("node[category"));});
   cwMarkers.style(newStyle);
  postStatus("clearTumorCategoryStyles complete");

} // clearTumorCategoriesAndCategoryStyles
//----------------------------------------------------------------------------------------------------
function requestTumorCategorization()
{
  var allCategoryNames = tumorCategorizationsMenu.children().map(function() {return $(this).val();}).get();
  var menuTitle = allCategoryNames[0];
  var categorizationName = tumorCategorizationsMenu.val();

  console.log("--- requestTumorCategorization, name: " + categorizationName);

  if(categorizationName === menuTitle || categorizationName === "Clear"  || categorizationName === null){
     clearTumorCategoriesAndCategoryStyles();
     return;
     } // clear
     
  console.log("apply " + categorizationName);
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "request", "");

  var msg = {cmd: "getSampleCategorization", callback: "markersApplyTumorCategorization",
             status: "request", payload: categorizationName};

  hub.send(JSON.stringify(msg));

} // requestTumorCategorization
//----------------------------------------------------------------------------------------------------
function applyTumorCategorization(msg)
{
   console.log("=== applyTumorCategorization");
   var tumorsInGraph = cwMarkers.nodes("[nodeType='patient']");
   var tumorsInTable = msg.payload.rownames;
   var tbl = msg.payload.tbl;
   var categoryRules = {};
   tbl.forEach(function(row){categoryRules[row[0]] = row[1];});


        /* jshint ignore:start */
	//debugger;
	/* jshint ignore:end */

   categoryRuleNames = Object.keys(categoryRules);
   categoryRuleNames.filter(function(name){return name !== "null";});
   categoryRuleNames.filter(function(name){return name !== null;});
   var newRules = [];

   categoryRuleNames.forEach(function(name){
      var selector = "node[category='" + name + "']";
      color=categoryRules[name];
      console.log(selector + ": " + color);
      newRules.push({"selector": selector, "style": {"background-color": color}});
      var selector2 = selector + ":selected";
      newRules.push({"selector": selector2, "style": {"border-color": "red",
                                                      "background-color": color,
                                                      "border-width": "10px"}});
      });

      // category=unassigned nodes are rendered in grey
   newRules.push({"selector": "node[category='unassigned']",
                     style: {"background-color": "lightgray"}});

     // but get the standard treatment when selected
   newRules.push({"selector": "node[category='unassigned']:selected",
                     style: {"border-color": "red",
                             "background-color": "lightgray",
                             "border-width": "10px"}});

   hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "data received", "");

   console.log("starting tumorsInGraph.forEach");
   cwMarkers.batch(function() {
      tumorsInGraph.forEach(function(node, index){
        var nodeID = node.id();  // our convention is that this is the tumor name, eg, "TCGA.02.0014"
        var indexInTable = tumorsInTable.indexOf(nodeID);
        if(indexInTable >= 0){
           var cluster = tbl[indexInTable][0];
           var color = tbl[indexInTable][1];
           node.data({category: cluster});
           }
        else{
           node.data({category: "unassigned"});
           }
         }); // forEach
       }); // batch

  console.log("ending tumorsInGraph.forEach");

  var oldStyle = cwMarkers.style().json();
     // remove any pre-existing node category rules
  var oldStyleClean = oldStyle.filter(function(e){return(e.selector.indexOf("node[category"));});

  var newStyle = oldStyleClean.concat(newRules);
  cwMarkers.style(newStyle);
  
  postStatus("applyTumorCategorization complete");
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "node category assigned", "");

} // applyTumorCategorization
//----------------------------------------------------------------------------------------------------
function doGraphOperation()
{
   var operation = graphOperationsMenu.val();

   switch(operation){
      case "Show All Edges":
         showAllEdges();
         break;
      case "Show Edges from Selected Nodes":
         //showEdgesFromSelectedNodes();
         showEdgesFromSelectedNodes();
         break;
      case "Hide All Edges":
         hideAllEdges();
         break;
      case "Invert Node Selection":
         invertSelection();
         break;
      case "Clear Selections":
         cwMarkers.filter('node:selected').unselect();
         break;
      case "Select All Connected Nodes":
         selectAllConnectedNodes();
         break;
      case "Select All Nodes with Selected Edges":
        selectAllNodesConnectedBySelectedEdges();
        break;
      case "Hide Unselected Nodes":
         cwMarkers.filter("node:unselected").hide();
         break;
      case "Show All Nodes":
         cwMarkers.filter('node:hidden').show();
         break;
      case "Restrict Next Ops to Selected Nodes":
         restrictNextOpsToSelectedNodes();
         break;
      default:
         console.log("unrecoginized graph operation requested from menu: " + operation);
      } // switch

      // restore menu to initial condition, with only title showing
   graphOperationsMenu.val("Network Operations...");

} // doGraphOperation
//----------------------------------------------------------------------------------------------------
function clearSelection ()
{
   cwMarkers.elements().unselect();
}
//----------------------------------------------------------------------------------------------------
function selectFirstNeighbors ()
{
  selectedNodes = cwMarkers.filter('node:selected');
  showEdgesForNodes(cwMarkers, selectedNodes);
}
//----------------------------------------------------------------------------------------------------
function invertSelection ()
{
   selected = cwMarkers.filter("node:selected");
   unselected = cwMarkers.filter("node:unselected");
   selected.unselect();
   unselected.select();
}
//----------------------------------------------------------------------------------------------------
function hideAllEdges ()
{
     // hide all edges besides chromsome edges
  cwMarkers.edges().fnFilter(function(edge) {
     return(edge.data("edgeType") != "chromosome");
     }).hide();

} // hideAllEdges
//----------------------------------------------------------------------------------------------------
function showAllEdges ()
{
   var edgeTypesToDisplay = edgeTypeSelector.val();

   console.log("edgeTypeToDisplay: " + edgeTypesToDisplay);

   if(edgeTypesToDisplay === null){
      return;
      }

   for(var e=0; e < edgeTypesToDisplay.length; e++){
      var type =  edgeTypesToDisplay[e];
      selectionString = '[edgeType="' + type + '"]';
      //console.log(" showAllEdges selection string: " + selectionString);
      cwMarkers.edges(selectionString).show();
      } // for e

} // showAllEdges
//----------------------------------------------------------------------------------------------------
function zoomSelected()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 100);
}
//----------------------------------------------------------------------------------------------------
function handleIncomingIdentifiers(msg)
{
   console.log("Module.markers, handleIncomingIdentifiers");
      // expect 3 payload fields: value, count, source
   var ids = msg.payload.value; 
   if(typeof(ids) == "string")
      ids = [ids];
   //intersectingIDs = hub.intersectionOfArrays(ids, nodeNames())
   intersectingIDs = hub.intersectionOfArrays(ids, nodeIDs());
   console.log("found ids: " + intersectingIDs.length);

   if(intersectingIDs.length > 0){
      selectNodesByID(intersectingIDs);
      }
   else{
      errorMessage = "No overlap with genes or tissue sample IDs:  <br><br>" +
                      ids.join(", ");
      title = ids.length + " unrecognized identifiers";
      console.log("+++++++++++ creating error div");
      $('<div id="markersIncomingIdentifiersErrorDialog" />').html(errorMessage).dialog({title: title, width:600, height:300});
      }

   console.log("about to post status from incoming identifiers");
   postStatus("incoming identifiers: " + ids.length);

   hub.raiseTab(thisModulesOutermostDiv);

} // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
  // run all that should happen when this module receives an incoming selection of patientIDs
function demoMarkersIncomingSelectionOfIDs()
{

   names = ["TCGA.06.0210", "TCGA.02.0106", "TCGA.02.0111",
            "TCGA.06.0194", "TCGA.06.0164", "TCGA.06.0409", "TCGA.02.0004",
            "TCGA.02.0051", "TCGA.08.0390", "TCGA.02.0025", "TCGA.08.0392",
            "TCGA.02.0079", "TCGA.12.0620", "TCGA.08.0373", "TCGA.06.0645",
            "TCGA.06.0192", "TCGA.12.0776", "TCGA.12.0778", "TCGA.06.0750",
            "TCGA.06.0878", "TCGA.14.0789", "TCGA.06.0881", "BCL11A",
            "BRCA1", "MDM2", "PIK3R1", "ABCA1", "CDK6", "CNTRL", "FH",
            "IFNA1", "LMO2", "PRKCA", "RELA", "STK11", "ZEB1", "CCNB1IP1",
            "CREB3L1", "GDF2", "OR4K2", "PRKCH", "WAS"];

   subset = [];
   for(var i=0; i < 10; i++)
     subset.push(names[getRandomInt(0, names.length -1)]);

   selectNodes(subset);

} // demoIncomingSelectionOfPatientIDs
//----------------------------------------------------------------------------------------------------
function allNodeIDs()
{
   ids = [];
   allNodes = cwMarkers.nodes();

   for(i=0; i < allNodes.length; i++)
       ids.push(allNodes[i].data("id"));

   return(ids);

} // allNodeIDs
//----------------------------------------------------------------------------------------------------
function showEdges()
{
   hideAllEdges();   // is this wise?

   var edgeTypesToDisplay = edgeTypeSelector.val();
   if(edgeTypesToDisplay === null){
      hideAllEdges();
      return;
      }

   var selectedNodes = selectedNodeIDs(cwMarkers);

   //console.log(" newEdgeTypeSelection (" + edgeTypesToDisplay.length + 
   //            "), selectedNodes: " + selectedNodes.length);

   if(selectedNodes.length > 0) { // show edges to and from all selected nodes
     showEdgesForNodes(cwMarkers, selectedNodes);
     }

} // showEdges
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 50);
}
//----------------------------------------------------------------------------------------------------
function selectedNodeIDs(cw)
{
   ids = [];
   noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     ids.push(noi[n].data('id'));
     }
  return(ids);

} // selectedNodeIDs
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }

  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
function showEdgesFromSelectedNodes()
{
   
   var targets = nodeRestriction;
   var selectedNodes = cwMarkers.nodes("node:selected");
   var neighbors = selectedNodes.neighborhood();
   var candidateEdges = neighbors.filterFn(function(e){
       if(e.isEdge()) return (e);
       });

   candidateEdges = candidateEdges.fnFilter(function(edge){
      return(edgeTypeSelector.val().indexOf(edge.data("edgeType")) >= 0);
      });

   if(targets.length === 0){
      candidateEdges.show();
      postStatus("showEdgesFromSelectedNodes");
      return;
      }

   function intersects(array1, array2){
      var size = array1.filter(function(n) {return (array2.indexOf(n) != -1);}).length;
      return(size > 0);
      }

   candidateEdges.filterFn(function(edge){
      var actual=edge.connectedNodes().map(function(node){return node.id();});
      return(intersects(actual, targets));
       }).show();

   postStatus("showEdgesFromSelectedNodes");

} // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function selectSourceAndTargetNodesOfEdges(cw, edges)
{
  //var eoi = cwMarkers.filter('edge:visible');
  var notChromosomal = function(edge){return(edge.data("edgeType") !== "chromosome");};
  eoi = edges.filterFn(notChromosomal);

  var filterStrings = [];

  for(var i=0; i < eoi.length; i++){
     edge = eoi[i];
     targetID = edge.target().data("id");
     sourceID = edge.source().data("id");
     var sourceFilterString = '[id="' + sourceID + '"]';
     var targetFilterString = '[id="' + targetID + '"]';
     filterStrings.push(sourceFilterString);
     filterStrings.push(targetFilterString);
     } // for i

   var nodesToSelect = cw.nodes(filterStrings.join());
   nodesToSelect.select();

} // selecteSourceAndTargetNodesOfEdge
//----------------------------------------------------------------------------------------------------
// todo: massive inefficiencies here
function showEdgesForNodes(cw, nodes)
{

  var edgeTypes = edgeTypeSelector.val();
  console.log("=== showEdgesForNodes, edgeType count: " + edgeTypes.length);
  //console.log(edgeTypes);

  if(edgeTypes.length === 0)
      return;

  var filterStrings = [];

  setTimeout(function(){
     for(var e=0; e < edgeTypes.length; e++){
        var edgeType = edgeTypes[e];
        for(var n=0; n < nodes.length; n++){
          var nodeID = nodes[n].data("id");
          var sourceFilterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
          var targetFilterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
          filterStrings.push(sourceFilterString);
          filterStrings.push(targetFilterString);
          } // for n
        } // for e

      //console.log("filterString count: " + filterStrings.length);
      filter = filterStrings.join();
      //console.log("filter created, about to apply...");
      var existingEdges = cw.edges(filter);
      //console.log("filtering complete");
      if(existingEdges.length > 0) {
         //console.log("about to show edges");
         existingEdges.show();
         //console.log("edges shown...");
         }
     }, 0); // setTimeout

} // showEdgesForNodes
//----------------------------------------------------------------------------------------------------
function selectAllConnectedNodes()
{
    var selectedEdges = cwMarkers.filter("edge:visible");
    selectedEdges = selectedEdges.filterFn(function(e){return (e.data("edgeType") !== "chromosome");});
    if(selectedEdges.length > 0)
       selectSourceAndTargetNodesOfEdges(cwMarkers, selectedEdges);

} // selectAllConnectedNodes
//----------------------------------------------------------------------------------------------------
function selectAllNodesConnectedBySelectedEdges()
{
    edges = cwMarkers.filter("edge:selected");
    console.log(" selected edge count: " + edges.length);
    if(edges.length === 0)
      return;
    for(var e=0; e < edges.length; e++){
       selectNodes(edges[e].target().data("name"));
       selectNodes(edges[e].source().data("name"));
       } // for e

} //selectAllNodesConnectedBySelectedEdges
//----------------------------------------------------------------------------------------------------
function showEdgesForSelectedNodes(cw, edgeTypes)
{
   var nodeIDs = selectedNodeIDs(cw);
   for(var n=0; n < nodeIDs.length; n++){
      nodeID = nodeIDs[n];
      for(var e=0; e < edgeTypes.length; e++){
         edgeType = edgeTypes[e];
         filterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         filterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         } // for e
      } // for n

} // showEdgesForSelectedNodes
//----------------------------------------------------------------------------------------------------
function restrictNextOpsToSelectedNodes()
{
  var nodes = cwMarkers.nodes("node:selected"); // .filter("[nodeType='gene']");
  if(nodes.length === 0){
     nodeRestriction = [];
     }
  else{
     nodeRestriction = nodes.map(function(node){return (node.id());});
     }

} // restrictNextOpsToSelectedNodes
//----------------------------------------------------------------------------------------------------
function nodeNames()
{
  var nodes = cwMarkers.filter("node:visible");
  var result = [];
  for(var i=0; i < nodes.length; i++){
    result.push(nodes[i].data().label);
    } // for i

  return(result);

} // nodeNames
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
   return(cwMarkers.nodes().map(function(node){return (node.id());}));
}
//----------------------------------------------------------------------------------------------------
function upperCaseNodeIDs()
{
   return(nodeIDs().map(function(node){return(node.toUpperCase());}));
}
//----------------------------------------------------------------------------------------------------
// todo: build up the filter string first, then send it all at once
function selectNodes(nodeNames)
{
  console.log("Module.markers::selectNodes");
  //console.log(nodeNames);

  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  var allNodes = cwMarkers.nodes().map(function(n){return (n.id());});
  var allNodesUpperCase = allNodes.map(function(name){return (name.toUpperCase());});

  for(var i=0; i < nodeNames.length; i++){
    var nodeName = nodeNames[i].toUpperCase();  // depends upon this conv
    var index = allNodesUpperCase.indexOf(nodeName);
    if(index >= 0){
      var actualNodeID = allNodes[index];
      var s = "cwMarkers.filter('node[id=\"" + actualNodeID + "\"]').select()";
       //console.log("markers selectNodes: " + s);
       eval (s);
       } // if found, index >= 0
    } // for i

   postStatus("nodes selected: " + allNodes.length);

} // selectNodes
//----------------------------------------------------------------------------------------------------
   // todo: build up the filter string first, then send it all at once
function selectNodesByID(nodeIDs) {

  if(typeof(nodeIDs) == "string")   // trap scalar, but expect and support arrays
     nodeIDs = [nodeIDs];

  console.log("about to select nodes by id: " + nodeIDs.length);
  console.log(nodeIDs);

  for(var i=0; i < nodeIDs.length; i++){
    s = "cwMarkers.filter('node[id=\"" + nodeIDs[i] + "\"]').select()";
    console.log(s);
    eval (s);
    } // for i

} // selectNodesByID
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
   var keyCode = e.keyCode || e.which;

   if (keyCode == 13) {
      var searchString = searchBox.val().toUpperCase();
      if(searchString.length === 0)
         return;
      console.log("searchString: " + searchString);
      var idsActual = nodeIDs();
      var idsUpper = upperCaseNodeIDs();
      var hits = idsUpper.filter(function(id) {return(id.indexOf(searchString) === 0);});
      var hitIndices = hits.map(function(hit) {return(idsUpper.indexOf(hit));});
      var hitsActual = hitIndices.map(function(hit) {return(idsActual[hit]);});
      selectNodes(hitsActual);
      } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function displayMarkersNetwork(msg)
{
   console.log("--- Module.markers: displayMarkersNetwork");
	var messageText = "Loading Network...(may take 10-20 seconds)"; 
    var el = document.getElementById("loadingDatasetMessage");
	el.innerHTML = messageText;
		
   hub.logEventOnServer(thisModulesName, "display markers network", "data received", "");
  
   if(msg.status == "success"){
         var json = JSON.parse(msg.payload);

   window.setTimeout(function(){
         console.log("nchar(network): " + msg.payload.length);
         cwMarkers.batch(function(){
           cwMarkers.remove(cwMarkers.edges());
           cwMarkers.remove(cwMarkers.nodes());
           console.log(" after JSON.parse, json.length: " + json.length);
           console.log("  about to add json.elements");
           cwMarkers.add(json.elements);
           // map current node degree into a node attribute of that name
       });
      
   }, 100);	

	window.setTimeout(function(){
		messageText ="Mapping Edges...";
		el.innerHTML = messageText;

		  cwMarkers.batch(function(){
			   cwMarkers.style(json.style);
			   cwMarkers.edges().hide();
			   cwMarkers.nodes().unselect();
		  });
        
        cwMarkers.nodes().map(function(node){node.data({degree: node.degree(), trueWidth: node.width(), trueHeight: node.height()});});
        cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
        cwMarkers.filter("edge[edgeType='chromosome']").show();

		  var edgeTypes = hub.uniqueElementsOfArray(cwMarkers.edges().map(function(edge){
									  return(edge.data("edgeType"));}
									  ));
			 updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
		  var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
											 return({id:n.id(), position:n.position()});}));
		  localStorage.markersDefault = defaultLayout;
		  defaultPatientNodeColor = cwMarkers.nodes("[nodeType='patient']").style("background-color");

		  hub.logEventOnServer(thisModulesName, "display markers network", "complete", "");

			//postStatus("markers network displayed");  // deferred; set when the category menu is configured

		  hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames", "request", "");

		 cwMarkers.resize();
		 cwMarkers.fit(50);

     var msg2 = {cmd: "getSampleCategorizationNames", callback: "configureSampleCategorizationMenu",
                  status: "request", payload: ""};
      hub.send(JSON.stringify(msg2));

    }, 100);	
      }
   else{
     console.log("displayMarkersNetwork error: " + msg.payload);
     }


} // displayMarkersNetwork
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// ensure that only edgeTypes in current network are offered in the selection widget
function updateEdgeSelectionWidget(edgeTypes)
{
     // loop over currently offered edge types
     //             <option value="mutation" class="btn-info" selected>Mut</option>

   var edgeTypeMenu = $("#markersEdgeTypeSelector");
   edgeTypeMenu.find('option').remove();
   edgeTypeMenu.trigger("chosen:updated");
   
   edgeTypes = edgeTypes.filter(function(e){return(e !== "chromosome");});

   for(var i=0; i < edgeTypes.length; i++){
      var name = edgeTypes[i];
      var optionMarkup =  "<option value='" + name + "' class='btn-info' selected>" + name + "</option>";
      $("#markersEdgeTypeSelector").append(optionMarkup);
      }
      
   $("#markersEdgeTypeSelector").trigger("chosen:updated");

} // updateEdgeSelectionWidget
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the g.markers.json network from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

   hub.logEventOnServer(thisModulesName, "display markers network", "request", "");

   var newMsg = {cmd: "getMarkersNetwork",  callback: "displayMarkersNetwork", status: "request", payload: datasetName};
   hub.send(JSON.stringify(newMsg));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function configureSampleCategorizationMenu(msg)
{
   console.log("=== configureSampleCategorizationMenu");
   //console.log(msg.payload);
   tumorCategorizationsMenu.empty();
   var categorizations = msg.payload;

   if(typeof categorizations == "string") 
   	 categorizations = [categorizations];

   var titleOption = "Tumor Groups...";

   tumorCategorizationsMenu.append("<option>" + titleOption + "</option>");
   tumorCategorizationsMenu.append("<option>Clear</option>");

   for(var i=0; i < categorizations.length; i++){
     tumorCategorizationsMenu.append("<option>" + categorizations[i] + "</option>");
     } // for i

   tumorCategorizationsMenu.val(titleOption);
   hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames",  "complete", "");
   
   hub.enableTab(thisModulesOutermostDiv);
   postStatus("markers network displayed");

} // configureSampleCategorizationMenu
//----------------------------------------------------------------------------------------------------

 return{
     init: function(){
        hub.addMessageHandler("sendSelectionTo_MarkersAndPatients", handleIncomingIdentifiers);
        hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
        hub.addMessageHandler("datasetSpecified", datasetSpecified);
        hub.addMessageHandler("displayMarkersNetwork", displayMarkersNetwork);
        hub.addMessageHandler("configureSampleCategorizationMenu", configureSampleCategorizationMenu);
        hub.addMessageHandler("markersApplyTumorCategorization", applyTumorCategorization);
        hub.addOnDocumentReadyFunction(initializeUI);
       }
     };

   }); // markersAndTissuesModule
//----------------------------------------------------------------------------------------------------
markersModule = markersAndTissuesModule();
markersModule.init();

//----------------------------------------------------------------------------------------------------
var cyGbm;   // keep this public so that the tabsApp can see it, reset on tab activate
var expressionData = [];   // consists of a gene list, a tissue list, and the data (a list of 
                           // gene/value pairs, each list named by a tissue (patient) id
var cnvData = [];
var mutationData = [];

var gbmPathwaysModule = (function () {

  var cyGbmDiv;
  var statusDiv; 
  var viewAbstractsButton, zoomSelectedButton;
  var tissueMenu, movieButton;
  var movieButtonOriginalColor, movieButtonDisabledColor = "lightGray";
  var selectLabel;

  var slowerMovieButton, fasterMovieButton;
  var currentMovieSpeed = 750;
  var movieSpeedReadout;
  var movieIntervalID;

  var searchBox;
  var edgeAbstractsOn = false;

  var moviePlaying = false;

  var infoMenu;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";

  var thisModulesName = "gbmPathways";
  var thisModulesOutermostDiv = "gbmPathwaysDiv";
  var selectionDestinations = [thisModulesName];
  var outermostDiv;
  var controlsDiv;

  var errorDialogBox;

  //--------------------------------------------------------------------------------------------
function initializeUI(network, vizmap)
{
   outermostDiv = $("#gbmPathwaysDiv");

   cyGbmDiv = $("#cyGbmPathwaysDiv");
   statusDiv = $("#gbmPathwaysStatusDiv");
   controlsDiv = $("#gbmPathwaysButtonDiv");

   selectLabel = $("#gbmPathwaysSelectLabel");
   selectLabel.css("color", "lightgray");   // not functional until some tissueIDs have been been added
   viewAbstractsButton = $("#gbmViewAbstractsButton");
   viewAbstractsButton.button();
   viewAbstractsButton.click(toggleEdgeSelection);

   zoomSelectedButton  = $("#gbmZoomSelectedButton");
   zoomSelectedButton.button()
   zoomSelectedButton.click(zoomSelection);

   tissueMenu = $("#gbmPathwaysSampleSelector");
   tissueMenu.change(tissueSelectorChanged);

   movieButton = $("#gbmPathwaysMovieButton");
   movieButton.button();
   movieButtonOriginalColor = movieButton.css("color");
   movieButton.prop("disabled", true);
   movieButton.css("color", movieButtonDisabledColor);

   slowerMovieButton = $("#gbmPathwaysSlowerMovieButton");
   slowerMovieButton.button();
   fasterMovieButton = $("#gbmPathwaysFasterMovieButton");
   fasterMovieButton.button();

   movieSpeedReadout = $("#gbmPathwaysMovieSpeedReadout");
   movieSpeedReadout.text(Number(currentMovieSpeed/1000).toFixed(2));

   fasterMovieButton.click(function() {changeMovieSpeed(-250);})
   slowerMovieButton.click(function() {changeMovieSpeed(250);})
   
   movieButton.text("Play Movie");
   movieButton.click(togglePlayMovie);
   searchBox = $("#gbmPathwaysSearchBox");


   sendSelectionsMenu = hub.configureSendSelectionMenu("#gbmPathwaysSendSelectionMenu",
                                                       [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

   sendSelectionsMenu.attr("disabled", true);

   loadNetwork();
   $(window).resize(handleWindowResize);

   hub.disableTab(thisModulesOutermostDiv)


 }; // initializeUI
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }
  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cyGbm);
   if(nodeNames.length == 0){
      console.log("no nodes selected!")
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function identifyEntitiesInCurrentSelection()  // defunct, not quite yet ready to del
{  
   var names = [];
   var noi = cyGbm.filter('node:selected'); 
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }
  return(names);

} // identifyEntitiesInCurrentSelection
//--------------------------------------------------------------------------------------------
function loadNetwork()
{

    cyGbm = $("#cyGbmPathwaysDiv");
    cyGbm.cytoscape({
       boxSelectionEnabled: true,
       showOverlay: false,
       minZoom: 0.01,
       maxZoom: 8.0,
       layout: {
         name: "preset",
         fit: true
         },
     ready: function() {
        console.log("cyGbm ready");
        cyGbm = this;

        cyGbm.on('select', 'edge', function(evt){
           var edge = evt.cyTarget;
           console.log("selected edge");
           if(edgeAbstractsOn){
              var pmid = edge.data().pmid;
              var url = "http://www.ncbi.nlm.nih.gov/pubmed/?term=" + pmid;
              var replaceAnyExistingPopup = true;
              hub.openCenteredBrowserWindow(url, "pubmed abstract", 800, 600, replaceAnyExistingPopup)
              }
           });

        cyGbm.on('select', 'node', function(evt){
           var disable = identifyEntitiesInCurrentSelection().length == 0;
           sendSelectionsMenu.attr("disabled", disable);
           });
        cyGbm.on('unselect', 'node', function(evt){
           var disable = identifyEntitiesInCurrentSelection().length == 0;
           sendSelectionsMenu.attr("disabled", disable);
           });

        searchBox.keydown(doSearch);

        cyGbm.edges().unselectify();
        console.log("cyGbm.reset");
        cyGbm.reset();
        handleWindowResize();
        } // cy.ready
       })
    .cytoscapePanzoom({ });   // need to learn about options

} // loadNetwork
//----------------------------------------------------------------------------------------------------
function displayPathway(msg)
{
   console.log("--- Module.gbmPathways: displayPathway");
   if(msg.status == "success"){
      console.log("nchar(network): " + msg.payload.length);
      s = msg.payload;
      XXX = msg.payload;
      console.log("      1:40: " + s.substring(1, 40));
      var json = JSON.parse(msg.payload);
      cyGbm.remove(cyGbm.edges());
      cyGbm.remove(cyGbm.nodes());
      console.log(" after JSON.parse, json.length: " + json.length);
      console.log("  about to add json.elements");
      cyGbm.add(json.elements);
      console.log("  about to add  json.style");
      cyGbm.style(json.style);
      cyGbm.nodes().unselect();
        // map current node degree into a node attribute of that name
      cyGbm.nodes().map(function(node){node.data({degree: node.degree()})});

      var edgeTypes = hub.uniqueElementsOfArray(cyGbm.edges().map(function(edge){
                               return(edge.data("edgeType"))}
                               ));
      //updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
      cyGbm.resize();
      cyGbm.fit(50);
      console.log("concluding displayPathway in Module.gbmPathways");
      cyGbm.edges().show();
        // on load there are no selections.  make sure the menu is disabled.
      sendSelectionsMenu.prop({"disabled": true}); 
      hub.enableTab(thisModulesOutermostDiv);
      handleWindowResize();
//      postStatus("gbm pathway loaded");
      }
   else{
     console.log("displayPathway error: " + msg.payload);
     }

} // displayPathway
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
   outermostDiv.width(0.95 * $(window).width());
   outermostDiv.height(0.95 * $(window).width());

   controlsDiv.width(0.95 * $(window).width());
   controlsDiv.height(80);
  
   cyGbmDiv.width(0.95 * $(window).width());
   cyGbmDiv.height(0.8 * $(window).height());

   cyGbm.resize();
   cyGbm.fit(50);

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cyGbm.fit(cyGbm.$(':selected'), 50)

}
//----------------------------------------------------------------------------------------------------
function toggleEdgeSelection ()
{
  if(edgeAbstractsOn){
     edgeAbstractsOn = false;
     viewAbstractsButton.button("option", "label", "Enable Abstracts");
     }
   else{
     edgeAbstractsOn = true;
     viewAbstractsButton.button("option", "label", "Disable Abstracts");
     }

} // toggleEdgeSelection
//----------------------------------------------------------------------------------------------------
function transformMatrixToPatientOrientedNamedList(mtx) {

     // geneNames are repeated in each element; grab them from the first one
   var geneNames = Object.keys(mtx[0]);
     // the last element was originally (in R) the row name -- the tissue
     // gene1: expression, gene2: expession, ... rowname: 0445.T.1
   geneCount = geneNames.length - 1;
   geneNames = geneNames.slice(0,geneCount);
   var tissueNames = [];
   max = mtx.length;
   namedList={};

   for(var r=0; r < max; r++){
      row = mtx[r]
      tissueName = row["rowname"][0];
      tissueNames.push(tissueName);
      namedList[tissueName] = row;
      } // for r

   result = {genes: geneNames, tissues: tissueNames, values: namedList};
   return(result);

} // transformMatrixToPatientOrientedNamedList
//----------------------------------------------------------------------------------------------------
// policy: incoming ids will not always be only patientIDs, but may be geneIDs also
// a) if none of the incoming ids are recognized, their full list is displayed
//    in the body of an error dialog explaining the problem
// b) if there are any geneIDs present, we ignore all patientIDs, and select the geneIDs
// c) if there are only patientIDs, then they are used to load molecular data for
//    those patients, and to setup for running a gene/data movie across those patients
function handleIncomingIdentifiers(msg){

   console.log("=== entering handleIncomingIdentifiers for gbm");
   console.log("status: " + msg.status);

   var incomingIds = msg.payload.value;
   if(typeof(incomingIds) == "string")
      incomingIds = [incomingIds];

   var status = "gbm pathway received " + incomingIds.length + " identifiers";
   postStatus(status);
   console.log(status);
   console.log(JSON.stringify(incomingIds));

   var idsUpperCase = incomingIds.map(function(id){return(id.toUpperCase())});
   //var ourGenes = cyGbm.filter("node[nodeType='gene']").map(function(node){return(node.id())});
   var ourGenes = cyGbm.nodes().map(function(node){return(node.id())});
   var recognizedGenes = ourGenes.filter(function(gene){return(idsUpperCase.indexOf(gene) >= 0)});

   if(recognizedGenes.length > 0){
      hub.raiseTab("gbmPathwaysDiv");
      console.log(" incoming ids matched " + recognizedGenes.length + " gene names");
      console.log(JSON.stringify(recognizedGenes));
      selectNodes(recognizedGenes);
      }
   else{
     alert("None of the selected ids are recognized by the GBM Pathways tab.");
     }

     // todo: make this conditional, and post alert error message when there are no overlaps
     // todo: such that it appears on the sending page

    /**************
   for(var i=0; i < incomingIds.length; i++){
     if(ourGeneNames.indexOf(incomingIds[i]) >= 0)
        recognizedGeneNames.push(incomingIds[i]);
     } // for i

   if(recognizedGeneNames.length > 0){
      }
   else{
     alert("None of the selected nodes recogized by destination tab.");
     }
     // with no recognized genes, we may have recognized tissueIDs.
     // ask the server to check, providing a callback that will 
     // request loading the molecular data for those tissue ids
     // which are recognized
   //else{ 
   //   msg = {cmd:"getOverlappingIdentifiers",
   //          callback: "gbmPathwaysHandleOverlappingTissueIdentifiers",
   //          status:"request",
   //          payload: {idType:"entities", signature:"mRNA", ids:incomingIds}
   //          };
   //  msg.json = JSON.stringify(msg);
   // hub.send(msg.json);
   //  } // else: possibly some tissue (patient) ids 

   ********/

   } // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
function handleIdentifyOverlappingTissueIdentifiers(msg)
{ 
    console.log("=== Module.gbmPathways handleOverlappingTissueIdentifiers");
    payload = JSON.parse(msg.payload)
    recognizedIDs = payload.recognized;
    if(typeof(recognizedIDs) == "string")  // promote scalar to 1-element array
      recognizedIDs = [recognizedIDs];
    unrecognizedIDs = payload.unrecognized;
    if(typeof(unrecognizedIDs) == "string")  // promote scalar to 1-element array
      unrecognizedIDs = [unrecognizedIDs];

      // if any are recognized, ignore the others, request load of molecular data
      // allowing data movie to be run across these samples
    if(recognizedIDs.length > 0){
       request_mRNA_data(recognizedIDs, geneSymbols());   // entities: patient, tissue or sample ids
       request_cnv_data(recognizedIDs, geneSymbols());
       request_mutation_data(recognizedIDs, geneSymbols());
       }
    else if(unrecognizedIDs.length > 0) {
       errorMessage = "No overlap with pathway genes or tissue sample IDs:  <br><br>" +
                       unrecognizedIDs.join(", ");
       title = unrecognizedIDs.length + " unrecognized identifiers";
       $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
       } // else: only unrecognized identifiers

} // handleIdentifyOverlappingTissueIdentifiers
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
  nodes = cyGbm.filter("node:visible");
  result = [];
  for(var i=0; i < nodes.length; i++){
    id = nodes[i].data()['id'];
    result.push(id);
    } // for i
  return(result)

} // nodeIDs
//----------------------------------------------------------------------------------------------------
   function nodeNames() {

     nodes = cyGbm.nodes();
     //nodes = cyGbm.filter("node:visible");
     result = [];
     for(var i=0; i < nodes.length; i++){
       result.push(nodes[i].data().label)
       } // for i
     return(result)
     } // nodeNames

//----------------------------------------------------------------------------------------------------
function geneSymbols() {

  nodes = cyGbm.filter("node");
  result = [];
  for(var i=0; i < nodes.length; i++){
    sym = nodes[i].data().geneSymbol
    if(typeof(sym) != "undefined")
       result.push(sym)
    } // for i
  return(result)
  } // geneSymbols

//----------------------------------------------------------------------------------------------------
function selectNodes(nodeNames)
{
  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  for(var i=0; i < nodeNames.length; i++){
     s = "cyGbm.filter('node[name=\"" + nodeNames[i] + "\"]').select()";
     //console.log("markers selectNodes: " + s);
     eval (s);
     } // for i

} // selectNodes
//----------------------------------------------------------------------------------------------------
   function changeMovieSpeed(delta) {

      if((currentMovieSpeed + delta) < 0)
         return;

      console.log("currentMovieSpeed: " + currentMovieSpeed);
      currentMovieSpeed += delta;
      console.log("currentMovieSpeed: " + currentMovieSpeed);
      movieSpeedReadout.text(Number(currentMovieSpeed/1000).toFixed(2));
      if(moviePlaying){
         clearInterval(movieIntervalID);
         movieIntervalID = setInterval(oneFrame, currentMovieSpeed);
         }
      } // changeMovieSpeed

   //----------------------------------------------------------------------------------------------------
   function togglePlayMovie() {


    allCurrentTissues = tissueMenu.children().map(function() {return $(this).val();}).get();
    currentTissueIndex = 0;

     oneFrame = function(){
        tissueIndex = currentTissueIndex  % allCurrentTissues.length;
        tissueName =  allCurrentTissues[tissueIndex]
        //console.log(" movie about to display frame " + tissueIndex + ", " + tissueName);
        currentTissueIndex = currentTissueIndex + 1;
        tissueMenu.val(tissueName);
        tissueSelectorChanged()
        } // oneFrame

     if(moviePlaying){
        moviePlaying = false;
        clearInterval(movieIntervalID);
        movieButton.text("Play Movie");
        }
     else{
        moviePlaying = true;
        movieButton.text("Stop Movie");
        movieIntervalID = setInterval(oneFrame, currentMovieSpeed);
        }
   

    } // togglePlayMovie
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
  var keyCode = e.keyCode || e.which;

  //console.log("Module.gbmPathway doSearch, keyCode: " + keyCode);

  if (keyCode == 13) {
     searchString = searchBox.val();
     //console.log("searchString: " + searchString);
     names = nodeNames()
     matches = []
     for(var i=0; i < names.length; i++){
        if(names[i].beginsWith(searchString)) {
           //console.log(searchString + " matched " + names[i]);
           selectNodes([names[i]]);
           } // if searchString matched beginning of node
        } // for i
     } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function request_mRNA_data(entities, features) {

  msg = {cmd:"get_mRNA_data",
          callback: "handle_gbmPathways_mRNA_data",
          status:"request",
          payload:{entities: entities, features: features}
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);
   }

//----------------------------------------------------------------------------------------------------
function request_cnv_data(entities, features) {

  msg = {cmd:"get_cnv_data",
          callback: "handle_gbmPathways_cnv_data",
          status:"request",
          payload:{entities: entities, features: features}
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);
   }

//----------------------------------------------------------------------------------------------------
function request_mutation_data(entities, features) {

  msg = {cmd:"get_mutation_data",
          callback: "handle_gbmPathways_mutation_data",
          status:"request",
          payload:{entities: entities, features: features}
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);
   }

//----------------------------------------------------------------------------------------------------
function addTissueIDsToSelector (tissueIDs) {
  tissueMenu.empty();
  if(tissueIDs.length == 0) {
     alert("gbmPathways received empty tissueIDs list")
     return;
     }
  
  // every set of tissueIDs needs a neutral (no data) pseudo-tissue

  tissueIDs.unshift("neutral");

  for(var i=0; i < tissueIDs.length; i++){
     tissueName = tissueIDs[i]
     optionMarkup = "<option>" + tissueName + "</option>";
     tissueMenu.append(optionMarkup);
     } // for i

 } // addTissueIDsToSelector
//----------------------------------------------------------------------------------------------------
function handle_mRNA_data(msg) {

   console.log("handling mRNA data");
   hub.raiseTab("gbmPathwaysDiv");
   if(msg.status == "success"){
      var mtx = JSON.parse(msg.payload.mtx);
      expressionData = transformMatrixToPatientOrientedNamedList(mtx);
      console.log("handle_mRNA_data, success, rows: " + expressionData.length);
      addTissueIDsToSelector(expressionData.tissues);
      movieButton.prop("disabled", false);
      movieButton.css("color", movieButtonOriginalColor)
      selectLabel.css("color", "black");
      } // success
   else{
      expressionData = [];
      console.log("handle_mRNA_data, failure, rows: " + expressionData.length);
      } // failure
   } // handle_mRNA_data

//----------------------------------------------------------------------------------------------------
function handle_cnv_data(msg) {

   console.log("handling cnv data");
   if(msg.status == "success"){
     var mtx = JSON.parse(msg.payload.mtx);
     cnvData = transformMatrixToPatientOrientedNamedList(mtx);
     }
   else{
     cnvData = []
     }
   } // handle_mRNA_data

//----------------------------------------------------------------------------------------------------
function handle_mutation_data(msg) {

   console.log("handling mutation data");
   if(msg.status == "success"){
     var mtx = JSON.parse(msg.payload.mtx);
     mutationData = transformMatrixToPatientOrientedNamedList(mtx);
     }
   else{
     mutationData = [];
     }
   } // handle_mRNA_data

//----------------------------------------------------------------------------------------------------
function tissueSelectorChanged() {

   tissueID = tissueMenu.val()
   displayTissue(tissueID);

   } // tissueSelectorChanged

//----------------------------------------------------------------------------------------------------
function setInfoNodeLabel (newLabel)
{
   infoNodeID = cyGbm.filter('node[canonicalName="info.node"]').data("id")
   noa = {};
   noa[infoNodeID] = {label: newLabel};
   cyGbm.batchData(noa);
}
//----------------------------------------------------------------------------------------------------
function displayTissue(tissueID)
{
   setInfoNodeLabel(tissueID);

   var noa = {};

   if(tissueID == "neutral") {
      console.log(" will display neutral values of expression, copynumber, mutation");
      ids = [];
      allNodes = cyGbm.nodes();
      for(i=0; i < allNodes.length; i++){
         node = allNodes[i];
         id = node.data("id");
         if(Object.keys(node.data()).indexOf("geneSymbol") >= 0){
            geneSymbol = node.data("geneSymbol");
            ids.push(id);
            noa[id] = {score:0, label: geneSymbol, copyNumber:0}
            } // if node has geneSymbol attribute
         } // for i
      cyGbm.batchData(noa);
      return;
      } // neutral pseudo-tissue

   if(expressionData.tissues.indexOf(tissueID) < 0){
      alert(tissueId + " not found in current expressionData");
      return;
      }

   mRNA = expressionData.values
   genes = expressionData.genes;
   tissues = expressionData.tissues;

   noa = {};  // new node attributes to assign in the network

   for(var g=0; g < genes.length; g++){
      gene = genes[g];

      newScore = mRNA[tissueID][gene][0];
      filterString = '[geneSymbol="' + gene + '"]'
      nodeID = cyGbm.nodes(filterString)[0].data("id");
      noa[nodeID] = {score: newScore};
      } // for g

   cyGbm.batchData(noa);

   cnv = cnvData.values
   genes = cnvData.genes;
   tissues = cnvData.tissues;

   noa = {};  // new node attributes to assign in the network

   for(var g=0; g < genes.length; g++){
     gene = genes[g];
     newCopyNumber = cnv[tissueID][gene][0];
     filterString = '[geneSymbol="' + gene + '"]'
     nodeID = cyGbm.nodes(filterString)[0].data("id");
     noa[nodeID] = {copyNumber: newCopyNumber};
     } // for g

   cyGbm.batchData(noa);

   mut = mutationData.values

   noa = {};  // new node attributes to assign in the network


   for(var g=0; g < genes.length; g++){
     gene = genes[g];
     newMutation = mut [tissueID][gene][0];
        // identify the node (by id) whose geneSymbol attribute is gene
        // the label attribute changes, but geneSymbol remains
     filterString = 'node[geneSymbol="' + gene  + '"]';
     nodeID = cyGbm.filter(filterString).id();
        // set label and nodeType for every gene
     if(newMutation == null){
        newGeneLabel = gene;
        newNodeType = "gene";
        }
     else{
        newGeneLabel = gene + " (" + newMutation + ")";
        newNodeType = "mutation";
        }
     noa[nodeID] = {label: newGeneLabel, nodeType: newNodeType};
     } // for g, mutations
   cyGbm.batchData(noa);

} // displayTissue
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose only one
// as their current working dataset.
// this module uses the dataset name to request the g.gbmPathways.json network from the server
function datasetSpecified (msg)
{
   console.log("Module.gbm datasetSpecified");
   console.log(msg.payload);

   var manifestInfo = msg.payload;
   var variableNames = manifestInfo.rownames;

   var pathway = "gbmPathways.json.RData";
   if($.inArray(pathway, variableNames) >= 0){
      var newMsg = {cmd: "getPathway",  callback: "displayGbmPathway",
                    status: "request", payload: "g.gbmPathways.json"};
      hub.send(JSON.stringify(newMsg));
      } // if pathway available

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  console.log("posting new status to gbmPathway status div: " + msg);
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function SetModifiedDate()
{
   msg = {cmd:"getModuleModificationDate",
          callback: "DisplayGbmPathwaysModifiedDate",
          status:"request",
          payload:"gbmPathways"
          };
   msg.json = JSON.stringify(msg);
   hub.send(msg.json);

} // setModifiedData
//----------------------------------------------------------------------------------------------------
function DisplayGbmPathwaysModifiedDate(msg)
{
   document.getElementById("gbmPathwaysDateModified").innerHTML = msg.payload;
}
//----------------------------------------------------------------------------------------------------
return{
  init: function(){
     hub.addMessageHandler("DisplayGbmPathwaysModifiedDate", DisplayGbmPathwaysModifiedDate);
     hub.addMessageHandler("handle_gbmPathways_mRNA_data", handle_mRNA_data);
     hub.addMessageHandler("handle_gbmPathways_cnv_data",  handle_cnv_data);
     hub.addMessageHandler("handle_gbmPathways_mutation_data",  handle_mutation_data);
     //hub.addMessageHandler("gbmPathwaysHandlePatientIDs", handlePatientIDs);
     hub.addMessageHandler("gbmPathwaysHandleOverlappingTissueIdentifiers",
                            handleIdentifyOverlappingTissueIdentifiers)

     hub.addMessageHandler("sendSelectionTo_gbmPathways", handleIncomingIdentifiers);
     hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
     hub.addMessageHandler("datasetSpecified", datasetSpecified);
     hub.addMessageHandler("displayGbmPathway", displayPathway);
     hub.addOnDocumentReadyFunction(initializeUI);
     } // init
  }; 

//----------------------------------------------------------------------------------------------------
}); // gbmPathwaysModule
//----------------------------------------------------------------------------------------------------
gbmPathway = gbmPathwaysModule()
gbmPathway.init();

//------------------------------------------------------------------------------------------------------------------------
    // observers used in QUnit testing
  var datasetsStatusObserver = null;
  var gbmPathwaysStatusObserver = null;


var GbmPathwayTestModule = (function () {

//------------------------------------------------------------------------------------------------------------------------
function initializeUI()
{
   console.log("Test.gbmPathway intializeUI")

} // initializeUI
//------------------------------------------------------------------------------------------------------------------------
runTests = function(show)
{
   if(show) showTests();

   testLoadDataSetThenLoadPathways();

} // runTests
//------------------------------------------------------------------------------------------------------------------------
showTests = function()
{
   $("#qunit").css({"display": "block"});

} // show
//------------------------------------------------------------------------------------------------------------------------
hideTests = function()
{
   $("#qunit").css({"display": "none"});

} // hide
//------------------------------------------------------------------------------------------------------------------------
function testLoadDataSetThenLoadPathways()
{
   var testTitle = "testLoadDataSet";
   console.log(testTitle);
   hub.raiseTab("gbmPathwaysDiv")
     
     // we could use the datasets tab menu to select the dataset, then click the button.
     // easier and quite adequate for our purposes is to simply send out the message which
     // these ui actions create

   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload: "DEMOdz"};
      // when our module receives the 'datasetSpecified' msg, which is accompanied by the dataset's manifest
      // it looks for the gbmPathways data object in the manifest, requests it be sent if it is there
      // when that data is loaded and ready, the module updates the status div; we watch for that, then
      // check that a reasonable number of nodes are contained in the loaded graph.

   var target = document.querySelector("#gbmPathwaysStatusDiv");

   if(gbmPathwaysStatusObserver == null){
      gbmPathwaysStatusObserver = new MutationObserver(function(mutations) {
      mutation = mutations[0];
      gbmPathwaysStatusObserver.disconnect();
      gbmPathwaysStatusObserver = null;
      var id = mutation.target.id;
      var msg = $("#gbmPathwaysStatusDiv").text();
      QUnit.test("gbmPathways loaded", function(assert) {
         var nodeCount = cyGbm.nodes().length;
         var edgeCount = cyGbm.edges().length;
         console.log("gbmPathway loaded, with " + nodeCount + " nodes and " + edgeCount + " edges.");
         assert.ok(nodeCount > 150);
         assert.ok(edgeCount > 200);
         testMakeSelections();
         })
      }); // new MutationObserver
      }

   var config = {attributes: true, childList: true, characterData: true};
   gbmPathwaysStatusObserver.observe(target, config);

   hub.send(JSON.stringify(msg));

}; // testLoadDataSetThenLoadPathways
//------------------------------------------------------------------------------------------------------------------------
function testMakeSelections()
{
   var selectedNodes = cyGbm.filter("node:selected").map(function(node){ return node.id();});
   console.log("--- testMakeSelections, selected node count: " + selectedNodes.length);
   console.log(JSON.stringify(selectedNodes));
   console.log("   menu disabled? " + $("#gbmPathwaysSendSelectionMenu").prop("disabled"));

   QUnit.test("gbmPathways selections", function(assert){
     assert.equal(cyGbm.filter("node:selected").length, 0);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), true);
     cyGbm.$("#GAB1").select()  // effectively instantaneous results?
     assert.equal(cyGbm.filter("node:selected").length, 1);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), false);
     });

   QUnit.test("gbmPathways direct cyjs search", function(assert){
       // use setTimeout to ensure a brief delay between 
       // calls to cyjs and results appearing on the cyjs canvas
     var done1 = assert.async();
     var done2 = assert.async();
     var done3 = assert.async();
     var done4 = assert.async();
     var done5 = assert.async();
     assert.expect(5);
     cyGbm.filter("node:selected").unselect();
     setTimeout(function(){
        var selectedNodeCount = cyGbm.filter("node:selected").length;
        console.log(" testing  unselect: " + selectedNodeCount);
        assert.equal(selectedNodeCount, 0); done1();
        var menuDisabled = $("#gbmPathwaysSendSelectionMenu").prop("disabled")
        console.log(" testing  unselect, menu disabled?: " + menuDisabled);
        assert.equal(menuDisabled, true); done2();
          // with this test complete, setup the next one
        cyGbm.$("#GAB1").select();  // effectively instantaneous results?
        }, 1000);
     setTimeout(function(){
        var selectedNodes = cyGbm.filter("node:selected").map(function(node){ return node.id();});
        assert.equal(selectedNodes.length, 1); done3();
        console.log("selected node: " + selectedNodes[0]);
        assert.equal(selectedNodes[0], "GAB1"); done4();
        assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), false); done5();
        testSearchBox();
        }, 1000);
      }); // gbmPathways direct cyjs search

} // testMakeSelections
//------------------------------------------------------------------------------------------------------------------------
function testSearchBox()
{
   cyGbm.filter("node:selected").unselect();

   QUnit.test("gbmPathways searchBox", function(assert){
     assert.equal(cyGbm.filter("node:selected").length, 0);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), true);
     var box = $("#gbmPathwaysSearchBox");
     box.val("pik");  // user lower case to test case insensitivity
     box.trigger(jQuery.Event("keydown", {which: 13}))
     assert.equal(cyGbm.filter("node:selected").length, 9);
     assert.equal($("#gbmPathwaysSendSelectionMenu").prop("disabled"), false);
     testZoomSelected();
     });


} // testSearchBox
//------------------------------------------------------------------------------------------------------------------------
function testZoomSelected()
{
   console.log("--- testZoomSelected");

   QUnit.test("gbmPathways zoom selected", function(assert){
     assert.ok(cyGbm.filter("node:selected").length > 0);
     var zoomBefore = cyGbm.viewport().zoom();
     $("#gbmZoomSelectedButton").click();
     var zoomAfter = cyGbm.viewport().zoom();
     console.log("zoomBefore: " + zoomBefore);
     console.log("zoomAfter: " + zoomAfter);
     assert.ok(zoomAfter > zoomBefore);
     console.log("pause zoomed in before calling testHandleIncomingSelections");
     setTimeout(function(){testHandleIncomingSelections()}, 1000);
     });

} // testZoomSelected
//------------------------------------------------------------------------------------------------------------------------
function testHandleIncomingSelections()
{
     // start out with network zoomed out, and no selected nodes
   console.log("--- testHandleIncomingSelections")

   cyGbm.filter("node:selected").unselect();
   cyGbm.fit(50);
 
   var cmd = "sendSelectionTo_gbmPathways";
   var payload = {value: ["GRB2", "PDGFRB"]};  // two nodes at top center of network
   var msg = {cmd: cmd, callback: "", status: "request", payload: payload};

   var target = document.querySelector("#gbmPathwaysStatusDiv");

   if(gbmPathwaysStatusObserver == null){
      gbmPathwaysStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        gbmPathwaysStatusObserver.disconnect();
        gbmPathwaysStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#gbmPathwaysStatusDiv").text();
        QUnit.test("gbmPathways incoming identifiers received", function(assert) {
           assert.equal(cyGbm.filter("node:selected").length, 2)        
           })
        setTimeout(testSendSelectionsViaGUI, 2000);
        }); // new MutationObserver
      } // if null observer

   var config = {attributes: true, childList: true, characterData: true};
   gbmPathwaysStatusObserver.observe(target, config);
   hub.send(JSON.stringify(msg));
   
} // testHandleIncomingSelections
//------------------------------------------------------------------------------------------------------------------------
function testSendSelectionsViaGUI()
{
   console.log("--- testSendSelectionsViaGUI");

     // start out with network zoomed out, and no selected nodes
   cyGbm.filter("node:selected").unselect();
   cyGbm.fit(50);
 
   cyGbm.$("#IRS1").select();
   cyGbm.$("#GAB1").select();

   setTimeout(function(){
      $("#gbmPathwaysSendSelectionMenu").val("blankTab");
      $("#gbmPathwaysSendSelectionMenu").trigger("change");
      }, 200);

   setTimeout(function(){
      QUnit.test("gbmPathways send selection via GUI", function(assert) {
        assert.ok($("#blankTabOutputDiv").text().indexOf("IRS1") >= 0);
        assert.ok($("#blankTabOutputDiv").text().indexOf("GAB1") >= 0);
        //testEdgeSelectionAndAbstractDisplay();
        })}, 1000)
    
   setTimeout(function(){hub.raiseTab("gbmPathwaysDiv")}, 2000);

   console.log("--- testSendAndReceiveSelectionsViaGUI, sent selections?");

} // testSendSelectionsViaGUI
//------------------------------------------------------------------------------------------------------------------------
function testEdgeSelectionAndAbstractDisplay()
{
  console.log("--- testSendSelectionsViaGUI");
  $("#gbmViewAbstractsButton").trigger("click");
  cyGbm.edges()[0].select();
    // edge is not visually selected
    // don't know how to detect for an actually opened window...


} // testEdgeSelectionAndAbstractDisplay
//------------------------------------------------------------------------------------------------------------------------

return{
   init: initializeUI,
   run: runTests,
   show: showTests,
   hide: hideTests
   }; // module return value

//------------------------------------------------------------------------------------------------------------------------
}); // GbmPathwayTestModule

gbt = GbmPathwayTestModule();
//gbt.run(true);

"user strict";
//----------------------------------------------------------------------------------------------------
var SurvivalModule = (function () {

  var currentDataSet;
  var statusDiv;

  var survivalCurveDiv;
  var survivalImageArea;

  var thisModulesName = "survival";
  var thisModulesOutermostDiv = "survivalDiv";
  var selectionDestinationsOfferedHere = ["survival"];

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
   survivalCurveDiv = $("#survivalCurveDiv");
   survivalImageArea = $("#survivalImageArea");
   statusDiv = $("#survivalStatusDiv");
   $("#survivalCurveDiv").css("display", "none");
   $(window).resize(handleWindowResize);
   handleWindowResize();
   hub.disableTab(thisModulesOutermostDiv);

}  // initializeUI
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
   //console.log("survivalCurveDiv window resize: " + $(window).width() + ", " + $(window).height());

   var newHeight = $(window).height() * 0.8;
   var newWidth = $(window).width() * 0.95;

   survivalCurveDiv.width(newWidth);
   survivalCurveDiv.height(newHeight);
   survivalImageArea.width(newWidth);
   survivalImageArea.height(newHeight);
  
} // handleWindowResize
//--------------------------------------------------------------------------------------------------     
     function handlePatientIDs(msg){
  
		if(msg.status == "success"){
             var patientIDs = msg.payload;            
 			  analyzeSelectedTissues(patientIDs, "");
         } else{
             console.log("survival handlePatientIDs about to call alert: " + msg);
             alert(msg.payload);
         }

	} //handlePatientIDs
//--------------------------------------------------------------------------------------------------     
     function handleIncomingIDs(msg){
          
	   var ids = msg.payload.value;
	   var count = msg.payload.count;
	   var source = msg.payload.source;  

	   if(typeof(ids) == "string")
    	  ids = [ids];

	   console.log("Survival module, " + msg.cmd + " count: " + count);
       msg = {cmd: "canonicalizePatientIDsInDataset", callback: "survivalHandlePatientIDs", status: "request", 
                    payload: ids};
             hub.send(JSON.stringify(msg));
     } // handlePatientIDs

//----------------------------------------------------------------------------------------------------
function analyzeSelectedTissues(patientIDs, title)
{
   console.log("Survival module, hub.send 'calculateSurvivalCurves' for %d patientIDs",
               patientIDs.length);

   $("#survivalInstructions").css("display", "none");
   $("#survivalCurveDiv").css("display", "block");

   var payload = {sampleIDs: patientIDs, title: title};
   var msg = {cmd:"calculateSurvivalCurves", callback: "displaySurvivalCurves", status: "request", 
              payload: payload};

   hub.send(JSON.stringify(msg));

} // analyzeSelectedTissues
//----------------------------------------------------------------------------------------------------
function getSurvivalPlot(msg)
{
   console.log("create Survival Plot for: ", msg);
   var payload = JSON.parse(msg.payload);
   var storage = [];

   for(var i=0;i<Object.keys(payload).length;i++){
      var patient = Object.keys(payload)[i];
      storage.push({ID: patient, value: payload[patient]});
      }

} // getSurvivalPlot
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function displaySurvivalCurves(msg)
{
   //console.log("about to add survival curve image to survivalCurve div");
   var encodedImage = msg.payload;
   document.getElementById("survivalImageArea").src = encodedImage;
   hub.raiseTab(thisModulesOutermostDiv);
   postStatus("image loaded");
   // survivalImageArea.src = encodedImage;

} // displaySurvivalCurves
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset(datasetName)
{
   console.log("Module.survival, specifyCurrentDataset: " + datasetName);

   var msg = {cmd: "specifyCurrentDataset",  callback: "survivalDatasetSpecified", 
              status: "request", payload: datasetName};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   console.log("--- Module.survival, datasetSpecified: " + msg.payload);
   hub.enableTab(thisModulesOutermostDiv)
   document.getElementById("survivalImageArea").src = ""

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function demoPatientSet()
{
   var longSurvivors = ["TCGA.06.6693", "TCGA.12.1088", "TCGA.02.0113", "TCGA.02.0114", "TCGA.08.0344"];

   var firstFortyGbmPatients = ["TCGA.02.0001", "TCGA.02.0003", "TCGA.02.0006", "TCGA.02.0007",
                                "TCGA.02.0009", "TCGA.02.0010", "TCGA.02.0011", "TCGA.02.0014",
                                "TCGA.02.0021", "TCGA.02.0024", "TCGA.02.0027", "TCGA.02.0028",
                                "TCGA.02.0033", "TCGA.02.0034", "TCGA.02.0037", "TCGA.02.0038",
                                "TCGA.02.0043", "TCGA.02.0046", "TCGA.02.0047", "TCGA.02.0052",
                                "TCGA.02.0054", "TCGA.02.0055", "TCGA.02.0057", "TCGA.02.0058",
                                "TCGA.02.0060", "TCGA.06.0875", "TCGA.06.0876", "TCGA.06.0877",
                                "TCGA.06.0878", "TCGA.06.0879", "TCGA.06.0881", "TCGA.06.0882",
                                "TCGA.12.0670", "TCGA.12.0818", "TCGA.12.0819", "TCGA.12.0820",
                                "TCGA.12.0821", "TCGA.12.0822", "TCGA.12.0826", "TCGA.12.0827"];

   firstFortyGbmPatients.push(longSurvivors);
   return (firstFortyGbmPatients);

} // demoPatientSet
//----------------------------------------------------------------------------------------------------
// the standalone-test
function sat(maxReps)
{
   if(typeof(maxReps) == "undefined")
      maxReps = 3;

     // might need to code defensively here, waiting for this request to return before proceeding
   specifyCurrentDataset("TCGAgbm");

   var pool = demoPatientSet();

   var maxIndex = pool.length - 1;
   
   var worker = function(randomIDs){
      console.log("survival on %d randomIDs", randomIDs.length);
      analyzeSelectedTissues(randomIDs, "");
      };

   for(var reps=0; reps < maxReps; reps++){
     var randomIDs = [];
     var count = hub.getRandomInt(4, maxIndex+1);   // get between 4 and ~40 patient ids
     for(var i=0; i < count; i++){
       randomIDs.push(pool[hub.getRandomInt(0, maxIndex)]);
       }
    analyzeSelectedTissues(randomIDs, "rep " + reps);
    }  // for reps

} // sat
//----------------------------------------------------------------------------------------------------
return{
   init: function(){
      hub.addOnDocumentReadyFunction(initializeUI);
      hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
	  hub.addMessageHandler("datasetSpecified", datasetSpecified);
      hub.addMessageHandler("survivalDatasetSpecified", datasetSpecified);
      hub.addMessageHandler("displaySurvivalCurves", displaySurvivalCurves);
      hub.addMessageHandler("sendSelectionTo_survival", handleIncomingIDs);
      hub.addMessageHandler("survivalHandlePatientIDs", handlePatientIDs);
      
      },
   sat: sat   // standalone test
   };

}); // SurvivalModule
//----------------------------------------------------------------------------------------------------
var survival = SurvivalModule();
survival.init();

//----------------------------------------------------------------------------------------------------

var PCAModule = (function () {

  var currentPatientIDs = null;
  var pcaScores;
  var pcaSelectedRegion;    // from brushing
    // by default, all patients (aka 'samples') in the current dataset are used for
    // all pca analyses.
    // but if a group of patientIDs arrived here as an incoming selection (via a 'handlePatientIDs' 
    // message) then that list is used until it is
    //   - replaced by another incoming set of ids
    //   - the "use all patientIDs in dataset" button is clicked


  var pcaDisplay;
  var d3pcaDisplay;
  var d3PlotBrush;
  var svg;
  var patientClassification;
  var firstTime = true;
  var pcaTextDisplay, pcaScreeDiv, pcaScoresDiv;

  var testResultsOutputDiv;

  var patientMenu;

  var pcaSendSelectionMenu;

  var thisModulesName = "PCA";
  var thisModulesOutermostDiv = "pcaDiv";
  var tempTest;
  var clearSelectionButton;
  var calculatePcaButton;
  var useAllSamplesInCurrentDatasetButton;
  var geneSetMenu;
  var expressionDataSetMenu;
  var currentIdentifiers = [];
  var infoMenu;

  var sendSelectionsMenuTitle = "Send selection...";
  var selectionDestinationsOfferedHere = ["PCA", "PCA (highlight)"];


  var currentExpressionDataSet;
  var pcaMsg; 
  var highlightIndex = [];
//----------------------------------------------------------------------------------------------------
function initializeUI ()
{
  pcaDisplay = $("#pcaDisplay");
  d3pcaDisplay = d3.select("#pcaDisplay");
  pcaHandleWindowResize();
  testResultsOutputDiv = $("#pcaTestingOutputDiv");

  $(window).resize(pcaHandleWindowResize);

  clearSelectionButton = $("#pcaClearSelectionButton");
  clearSelectionButton.button();
  clearSelectionButton.click(clearSelection);

  calculatePcaButton = $("#pcaCalculateButton");
  calculatePcaButton.button();
  $("#pcaOutputDiv").css("display", "none");
  calculatePcaButton.click(calculate);
  useAllSamplesInCurrentDatasetButton = $("#pcaUseAllSamplesButton");
  useAllSamplesInCurrentDatasetButton.button();
  useAllSamplesInCurrentDatasetButton.click(useAllSamplesInCurrentDataset);
  hub.disableButton(useAllSamplesInCurrentDatasetButton);

  expressionDataSetMenu = $("#pcaExpressionDataSetSelector");
   
   $(".pcaExpMenu").click( function(){  $(".pcaExpMenu .dropdown").slideToggle();}   );

   $("#pcaExpressionDataSetSelector .flexcontainer").width($(window).width()/1.2);

  geneSetMenu = $("#pcaGeneSetSelector");
  geneSetMenu.change(function(){
     console.log("gene set is now " + geneSetMenu.val());
     //msg = {payload: {ids:currentIdentifiers}, status: "success"}
     //handlePatientIDs(msg)
     });  // ASSUMES success and requires use of GLOBAL variable storing identifiers WITHOUT passing through WS

  pcaTextDisplay = $("#pcaTextDisplayDiv");

  pcaSendSelectionMenu = hub.configureSendSelectionMenu("#pcaSendSelectionsMenu", 
                                                        selectionDestinationsOfferedHere, sendSelections,
                                                        sendSelectionsMenuTitle);
/// BUG FIX NECESSARY:		
//  $("#pcaSendSelectionsMenu").css("display", "none")                                                     
///
  hub.disableTab(thisModulesOutermostDiv);
 
} // initializeUI
//----------------------------------------------------------------------------------------------------
function showLegend(){

  var text = $("#PCALegend").html();
  var title = "PCA Legend";
  $("<div>").html(text).dialog({title: title, width:600, height:600});

} // showHelp
//----------------------------------------------------------------------------------------------------
function getPatientClassification ()
{
   payload = "";
   msg = {cmd: "getPatientClassification", callback: "handlePatientClassification", 
          status: "request", payload: payload};
   hub.send(JSON.stringify(msg));

} // getPatientClassification
//----------------------------------------------------------------------------------------------------
function handlePatientClassification (msg)
{
   if(msg.status == "success"){
      patientClassification = msg.payload;
      console.log("got classification, length " + patientClassification.length);
      }
   else{
     alert("error!" + msg.payload);
     }

   //drawLegend()

} // handlePatientClassification
//----------------------------------------------------------------------------------------------------
function requestGeneSetNames()
{
   console.log("=== requestGeneSetNames");

   callback = "pcaHandleGeneSetNames";

   msg = {cmd:"getGeneSetNames",
          callback: callback,
          status:"request",
          payload:""};

   hub.send(JSON.stringify(msg));

} // requestGeneSetNames
//----------------------------------------------------------------------------------------------------
function requestSampleNames()
{
   console.log("=== requestSampleNames");

   callback = " ";

   msg = {cmd:"canonicalizePatientIDsInDataset",
          callback:callback ,
          status:"request",
          payload:""};

   hub.send(JSON.stringify(msg));

} // requestSampleNames
//----------------------------------------------------------------------------------------------------
function handleGeneSetNames(msg)
{
   console.log("=== handleGeneSetNames");

   newNames = msg.payload;
   addGeneSetNamesToMenu(newNames);

} // handleGeneSetNames
//----------------------------------------------------------------------------------------------------
function addGeneSetNamesToMenu (geneSetNames)
{
   console.log("Module.pca:addGetSetNamesToMenu");

   geneSetMenu.empty();

   if(geneSetNames.length === 0) {
     postStatus("addGeneSetNamesToMenu: geneSetNames.length == 0");
     return;
     }
    
   if(typeof geneSetNames == "string") 
   	 geneSetNames = [geneSetNames]; 
 
      
   for(var i=0; i < geneSetNames.length; i++){
     optionMarkup = "<option>" + geneSetNames[i] + "</option>";
     geneSetMenu.append(optionMarkup);
     } // for i

  postStatus("addGeneSetNamesToMenu: complete");
  hub.enableTab(thisModulesOutermostDiv);

} // addGeneSetNamesToMenu
//----------------------------------------------------------------------------------------------------
function requestExpressionDataSetNames()
{
   console.log("=== requestExpressionDataNames");

   callback = "pcaHandleExpressionDataSetNames";

   msg = {cmd:"getExpressionDataSetNames",
          callback: callback,
          status:"request",
          payload:""};

   hub.send(JSON.stringify(msg));

} // requestExpressionDataSetNames
//----------------------------------------------------------------------------------------------------
function updateExpressionData()
{
  currentExpressionDataSet = $(this).siblings("td").andSelf("td").eq(0).text();
  var changedText = currentExpressionDataSet;
  $(".pcaExpMenu a").eq(0).text(changedText);
} // updateExpressionData
//----------------------------------------------------------------------------------------------------
function handleExpressionDataSetNames(msg)
{
   console.log("=== handleExpressionDataSetNames");
   $(".pcaExpMenu .dropdown table").empty();
   $(".pcaExpMenu a").eq(0).text("Choose Expression Data");
   expManifest = msg.payload.mtx;
   var expNames = [];
   for(var i=0; i < expManifest.length; i++){
     expNames.push(expManifest[i][0]);
   }

   expManifestCols = msg.payload.colnames;
   $(".pcaExpMenu .dropdown table").append("<tr id='pcaExpManiCols'></tr>");
   for(i=0; i<expManifestCols.length; i++){
      var singleRecord = "<th class='strong'>" + expManifestCols[i]+
                         "</th>";
      $("#pcaExpManiCols").append(singleRecord);
   }
   addExpressionDataSetNamesToMenu(expManifest);
} // handleExpressionDataSetNames
//----------------------------------------------------------------------------------------------------
function addExpressionDataSetNamesToMenu (expressionDataSetNames)
{
   console.log("Module.pca:addExpressionDataSetNamesToMenu");
 
    //expressionDataSetMenu.empty();
 
    if(expManifest.length === 0) {
      postStatus("addExpressionDataSetNamesToMenu: expManifest.length == 0");
      return;
      }
     
    if(typeof expManifest === "string") 
      expressionDataSetNames = [expManifest][0]; 
    
    var singleRecord;
       
    for(var i=0; i<expManifest.length; i++){
      $(".pcaExpMenu .dropdown table").append("<tr class='pcaExpClickable' id='pcaExpMani" + i + "'></tr>");
      for(var j=0; j<expManifest[i].length; j++){
          singleRecord = '<td><a href="#" style="text-decoration:none">' + expManifest[i][j] + '</a></td>';
          $("#pcaExpMani" + i).append(singleRecord);
        } // for j
      } // for i
    $(".pcaExpMenu .pcaExpClickable td").click(updateExpressionData);

// default: pre-select first dataset
    $("tr#pcaExpMani0 td")[0].click()
    $(".pcaExpMenu").click()
  
   postStatus("addExpressionDataSetNamesToMenu: complete");
   hub.enableTab(thisModulesOutermostDiv);

} // addExpressionDataSetNamesToMenu
//----------------------------------------------------------------------------------------------------
function useAllSamplesInCurrentDataset()
{
  currentPatientIDs = null;
  hub.disableButton(useAllSamplesInCurrentDatasetButton);

}  // useAllSamplesInCurrentDataset
//----------------------------------------------------------------------------------------------------
function changePCAids(msg)
{
   patientIDs = [];
   selections = msg.payload;
   d3.values(selections).forEach(function(d){ d.patientIDs.forEach(function(id){patientIDs.push(id);});});
   sendSelectionToModule("PCA", patientIDs);

} // changePCAids
//----------------------------------------------------------------------------------------------------
function drawLegend ()
{
  if(typeof(patientClassification) == "undefined")
     return;

  for(var i=0; i<patientClassification.length; i++){
    if(patientClassification[i].gbmDzSubType[0] === null | patientClassification[i].gbmDzSubType[0] === ""){
      patientClassification[i].gbmDzSubType[0]= "undefined";
      } // if
    } // for i

  var classifications = d3.nest()
                          .key(function(d) { return d.gbmDzSubType[0]; })
                          .map(patientClassification, d3.map);

  var LegendLabels = d3.values(classifications.keys());
 
  var Legendsvg = d3.select("#pcaLegend").append("svg")
                      .attr("id", "pcaLegendSVG")
                      .attr("width", $("#pcaDisplay").width())
                      .attr("height", 50);
  
   var TextOffset =  [0, 87, 87, 87, 87, 87, 87];
   var TextOffSet = d3.scale.ordinal()
                      .range(TextOffset)
                      .domain(classifications.keys());
        
   var legend = Legendsvg.append("g")
                         .attr("class", "legend")
                         .attr("transform", "translate(" + 10 + "," + 10 + ")")  
                         .selectAll(".legend")
                         .data(LegendLabels)
                         .enter().append("g")
                         .attr("transform", function(d, i) { 
                             return "translate(" + i*TextOffSet(d) + ",0)"; 
                             });

    var text = legend.append("text")
                      .attr("y", 10)
                      .attr("x", 0)
                      .style("font-size", 12)
                      .text(function(d) { return d;})
                      .attr("transform", function(d, i) { 
                          return "translate(" + 15 + ",0)";
                           });

    legend.append("circle")
          .attr("cx", 0)
          .attr("cy", 5)
          .attr("r", function(d) { return 6;})
          .style("fill", function(d)   { if(d=="undefined") return "white"; return classifications.get(d)[0].color[0];})
          .style("stroke", function(d) { if(d=="undefined") return "black"; return classifications.get(d)[0].color[0];});
 
} // drawLegend
//----------------------------------------------------------------------------------------------------
function pcaHandleWindowResize () 
{
  pcaDisplay.width($(window).width() * 0.95);
  pcaDisplay.height($(window).height() * 0.80);

  if(!firstTime){
    d3PcaScatterPlot(pcaScores);
    }

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function pointsInBrushedRegion()
{
  x1=pcaSelectedRegion[0][0];
  y1=pcaSelectedRegion[0][1];
  x2=pcaSelectedRegion[1][0];
  y2=pcaSelectedRegion[1][1];

  var selectedIDs = [];

  for(var i=0; i < pcaScores.length; i++){
    px = pcaScores[i][0];
    py = pcaScores[i][1];
    if(px >= x1 & px <= x2 & py >= y1 & py <= y2){
      console.log(" selected: " + currentIdentifiers[i]);
      selectedIDs.push(currentIdentifiers[i]);
      }
    } // for i

  return(selectedIDs);

} // pointsInBrushedRegion
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
  var destination = pcaSendSelectionMenu.val();

  var selectedIDs = pointsInBrushedRegion();
       
   if(selectedIDs.length > 0){
      var cmd = "sendSelectionTo_" + destination;
      payload = {value: selectedIDs, count: selectedIDs.length, source: "PCA module"};
      var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};
      pcaSendSelectionMenu.val(sendSelectionsMenuTitle);
      hub.send(JSON.stringify(newMsg));
      }
   else{
     alert("No selections to send...");
     }

} // sendSelections
//----------------------------------------------------------------------------------------------------
function pcaPlot (msg)
{
   if(msg.status == "success"){
      pcaScores = msg.payload.scores;
      var geneSet = msg.payload.geneSetName;
      currentIdentifiers = msg.payload.ids;
      //capture message and store to a global variable for testing purpose
      pcaMsg = {selectedIDs:currentIdentifiers, pcaScores:pcaScores, geneSet:geneSet};
      pcaMsg.selectedIDs = currentIdentifiers;
      pcaMsg.pcaScores = pcaScores;
      pcaMsg.geneSet = geneSet;

      //for(var i = 0; i < pcaMsg.selectedIDs.length; i++) { pcaMsg.selectedIDs[i] = pcaMsg.selectedIDs[i].slice(0, 12);}
      d3PcaScatterPlot(pcaScores);

      var pcaData = msg.payload.importance;
      var PC1var = 100 * msg.payload["importance.PC1"];
      var PC2var = 100 * msg.payload["importance.PC2"];
      var pcaText = $("#pcaTextDisplayDiv").html("");
      pcaText.append("Proportion of Variance: ");
      pcaText.append("PC1: "+PC1var.toFixed(2) + "%, PC2: "+PC2var.toFixed(2)+"%");
        
      //if(!firstTime){  // first call comes at startup.  do not want to raise tab then.
      hub.raiseTab(thisModulesOutermostDiv);
      postStatus("pcaPlot: success");
      //  }
      }// if success
    else{
      errorMessage = msg.payload;
      $("<div/>").html(errorMessage).dialog({title: "pcaPlot error", width:600, height:300});
      postStatus("pcaPlot: error");
      }
     firstTime = false;
}
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  $("#pcaStatusDiv").text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function highlightPatientIDs(msg)
{
   hub.raiseTab(thisModulesOutermostDiv);

   var candidates = msg.payload.value;
   //pcaMsg.selectedIDs = candidates;
     // with currentIdentifiers (local shorter sample IDs) first, they
     // are returned:
     //   hub.intersectionOfArrays(currentIdentifiers, candidates)  ->    
     //      ["TCGA.02.0114", "TCGA.12.1088"]
     // rather than
     //    hub.intersectionOfArrays(candidates, currentIdentifiers) ->  
     //      ["TCGA.02.0114.01", "TCGA.12.1088.01"]
   if(currentIdentifiers.length === 0){
     title = "PCA plot not calculated";
     errorMessage = "Please calculate PCA plot before sending identifiers for highlighting.";
     $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
     return; 
   }
   var intersection = hub.intersectionOfArrays(candidates, currentIdentifiers);
   // debugger;
   console.log("=== Module.pca, highlightPatientIDs, intersection:");
   console.log(JSON.stringify(intersection));

   if(intersection.length === 0){
     count = candidates.length;
     errorMessage = "None of the incoming ids were recognized: ";
     for(var i=0; i < count; i++){
       errorMessage += candidates[i] + " ";
       }
     title = "Unrecognized Identifiers";
     $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
     postStatus("intersection.length === 0");
     } // if intersection
   else{
     selectPoints(intersection, true);
     //postStatus("intersection.length !== 0");
   }
} // highlightPatientIDs
//----------------------------------------------------------------------------------------------------
function selectPoints(ids, clearIDs)
{
   console.log("=== module.pca: selectPoints");
   console.log("    incoming ids count: " + ids.length);
   //console.log(ids);
   
   if(true){
     d3.selectAll("circle")
       .filter(function(d, i){
         //console.log("examining currentIdentifier " + i + ": " + currentIdentifiers[i]);
         if(typeof(d) == "undefined")
           return(false);
         match = ids.indexOf(currentIdentifiers[i]);
         //highlightIndex.push(match);
         //console.log("match: " + match);
         return (match >= 0);
       }) // filter
       .classed("highlighted", true)
       .transition()
       .attr("r", 7)
       .duration(500);
   }
   //pcaMsg.highlightIndex = highlightIndex;
   setTimeout(function(){
            console.log("*****Module.js within selectPoints before qunit");
            console.log("***** Date time: ", Date());
            postStatus("selectPoints are highlighted"); 
   }, 5000);
 } // selectPoints
//----------------------------------------------------------------------------------------------------
function clearSelection()
{
   d3.selectAll("circle")
     .classed("highlighted", false)
     .attr("r", 3);

  d3PlotBrush.clear();
  svg.selectAll('.brush').call(d3PlotBrush);
  pcaHandleWindowResize();

} // clearSelection
//----------------------------------------------------------------------------------------------------
function calculate()
{
   var currentGeneSet = geneSetMenu.val();
   var payload = {genes: currentGeneSet, expressionDataSet: currentExpressionDataSet};

   if(currentPatientIDs !== null)
       payload.samples = currentPatientIDs;
       //payload["samples"] = currentPatientIDs;


   msg = {cmd: "calculatePCA", callback: "pcaPlot", status: "request", payload: payload};
   hub.send(JSON.stringify(msg));
   $("#pcaInstructions").css("display", "none");
   $("#pcaOutputDiv").css("display", "block");
} // calculate
//----------------------------------------------------------------------------------------------------
function handlePatientIDs(msg)
{
   console.log("Module.pca: handlePatientIDs");

   if(msg.status !== "error"){   // sometimes "success" from a prior call, sometimes "request"
     var currentGeneSet = geneSetMenu.val();
     var selectedPatientIdentifiers = msg.payload.value;
     currentPatientIDs = msg.payload.value;
     var payload = {samples: currentPatientIDs, genes: currentGeneSet,  expressionDataSet: currentExpressionDataSet};

     msg = {cmd: "calculatePCA", callback: "pcaPlot", status: "request", payload: payload};
     hub.send(JSON.stringify(msg));

     hub.enableButton(useAllSamplesInCurrentDatasetButton);
     $("#pcaInstructions").css("display", "none");
     $("#pcaOutputDiv").css("display", "block");

     }
   else{
     alert("Module.pca handlePatientIDs error: " + JSON.stringify(msg));
     }

} // handlePatientIDs
//----------------------------------------------------------------------------------------------------
function d3PlotBrushReader ()
{
     //console.log("plotBrushReader 1037a 22jul2014");
  pcaSelectedRegion = d3PlotBrush.extent();
  console.log("region: " + pcaSelectedRegion);

  x0 = pcaSelectedRegion[0][0];
  x1 = pcaSelectedRegion[1][0];

  width = Math.abs(x0-x1);

  console.log("width: " + width);
  if(width > 0.001 &   pointsInBrushedRegion().length > 0){
    console.log("enabling pcaSendSelectionMenu");
    pcaSendSelectionMenu.prop("disabled",false);
    }
  else{
    console.log("disabling pcaSendSelectionMenu");
    pcaSendSelectionMenu.prop("disabled",true);
    }

} // d3PlotBrushReader
//----------------------------------------------------------------------------------------------------
function chooseColor(d)
{
  /********
  var id = d.id;
  for(var i=0; i<patientClassification.length; i++){
    var patientID = patientClassification[i]._row;
      // "TCGA.02.0047.01".indexOf("TCGA.02.0047") -> 0
      // using this strategy for partial match allows patient/tumor/sample multiplicity to be mapped
      // to patient classification
    if(id.indexOf(patientID) == 0){
       result = patientClassification[i].color;
       return(result)
       } // if match
    } // for i
 
   *********/
   return("black");

} // chooseColor
//----------------------------------------------------------------------------------------------------
function d3PcaScatterPlot(dataset)
{
   var padding = 50;
   var width = $("#pcaDisplay").width();
   var height = $("#pcaDisplay").height();

   var xMax = d3.max(dataset, function(d) { return +d[0];} );
   var xMin = d3.min(dataset, function(d) { return +d[0];} );
   var yMax = d3.max(dataset, function(d) { return +d[1];} );
   var yMin = d3.min(dataset, function(d) { return +d[1];} );
 
       // todo:  after finding min and max, determine largest of each axis in abs value
       // todo:  then find next larger even number, use that throughout
     
   xMax = xMax * 1.1;
   xMin = xMin * 1.1;
   yMax = yMax * 1.1;
   yMin = yMin * 1.1;

     //console.log("xMax: " + xMax);   console.log("xMin: " + xMin);
     //console.log("yMax: " + yMax);   console.log("yMin: " + yMin);

   d3pcaDisplay.select("#pcaSVG").remove();  // so that append("svg") is not cumulative
 
   var xScale = d3.scale.linear()
                  .domain([xMin,xMax])
                  .range([padding, width - padding]);

   var yScale = d3.scale.linear()
                  .domain([yMin, yMax])
                  .range([height - padding, padding]); // note inversion 
  pcaMsg.xScale = xScale;
  pcaMsg.yScale = yScale; 
   var xTranslationForYAxis = xScale(0);
   var yTranslationForXAxis = yScale(0);

   var xAxis = d3.svg.axis()
                 .scale(xScale)
                 .orient("top")
                 .ticks(5);

   var yAxis = d3.svg.axis()
                 .scale(yScale)
                 .orient("left")
                 .ticks(5);

   var tooltip = d3pcaDisplay.append("div")
                             .attr("data-toggle", "tooltip")
                             .style("position", "absolute")
                             .style("z-index", "10")
                             .style("visibility", "hidden")
                             .text("a simple tooltip");

   d3PlotBrush = d3.svg.brush()
                   .x(xScale)
                   .y(yScale)
                   .on("brushend", d3PlotBrushReader);

   svg = d3pcaDisplay.append("svg")
                         .attr("id", "pcaSVG")
                         .attr("width", width)
                         .attr("height", height)
                         .call(d3PlotBrush);

    svg.append("g")
       .attr("class", "x axis")
       .attr("transform", "translate(0, " + yTranslationForXAxis + ")")
       .call(xAxis)
       .append("text")
       .style("font-size", 14)
       .text("PC1");

   svg.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(" + xTranslationForYAxis + ", 0)")
      .call(yAxis)
      .append("text")
      .attr("y", 10)
      .attr("dy", ".71em")
      .style("font-size", 14)
      .style("text-anchor", "end") //start, middle
      .text("PC2");       
   var circle = svg.append("g").selectAll("circle")
                   .data(dataset)
                   .enter()
                   .append("circle")
                   .attr("cx", function(d,i) {return xScale(d[0]);})
                   .attr("cy", function(d,i) {return yScale(d[1]);})
                   .attr("r", function(d) { return 3;})
                   .style("fill", function(d) {
                        var color = chooseColor(d[0]);
                        if(color === "") return "white";
                        return color;})
                   .style("stroke", function(d) {
                        var color = chooseColor(d[0]);
                        if(color === "") return "black";
                        return color;})
                   .on("mouseover", function(d,i){
                         tooltip.text(currentIdentifiers[i]);
                         return tooltip.style("visibility", "visible");
                         })
                   .on("mousemove", function(){return tooltip.style("top",
                           (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");})
                   .on("mouseout", function(){return tooltip.style("visibility", "hidden");});
} // d3PcaScatterPlot
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   console.log("=== datasetSpecified");
   console.log(msg);

   var dataPackageName = msg.payload.datasetName;
   var dataElementNames = msg.payload.rownames;

      // for now, and very temporarily, use the first match (if any are found)
   var hits = dataElementNames.map(function(name) {if(name.indexOf("mtx.mrna") >= 0) return(name);});
   hits = hits.filter(function(n){ return (n !== undefined); });

   var matrixName = null;
   if(hits.length > 0){
        // for now always grab the first (last!) hit, remove the trailing .RData
        // the PCA constructor wants both dataPacakgeName & a matrix name
        // our convention is that the maniftest rowname is the same as
        // its name, with ".RData" appended
        // TODO: this needs to be a user menu selection (29 jun 2015)
      var lastHit = hits.length - 1;
      matrixName = hits[lastHit].replace(".RData", "");
      //matrixName = expressionDataSetMenu.val();
    }else{
      alert("No mtx.mrna in dataset '" + dataPackageName + "'");
      hub.disableButton(calculatePcaButton);
      return;
      }
   currentExpressionDataSet = matrixName;
   console.log("***** currentExpressionDataSet is ", currentExpressionDataSet);
   console.log("== calling createPcaObjectOnServer");
   createPcaObjectOnServer(dataPackageName, matrixName);
   
   d3pcaDisplay.select("#pcaSVG").remove();  // so that old layouts aren't mistaken for new dataset
   $("#pcaInstructions").css("display", "block");
   $("#pcaOutputDiv").css("display", "none");

} // datasetSpecified
//--------------------------------------------------------------------------------------------
function createPcaObjectOnServer(dataPackageName, matrixName)
{
  console.log("create PCA on server " + dataPackageName + ": " + matrixName);
  payload = {dataPackage: dataPackageName, matrixName: matrixName};

  msg = {cmd: "createPCA", callback: "pcaObjectCreated", status: "request", payload: payload};

  msg.json = JSON.stringify(msg);
  hub.send(msg.json);

} // createPcaObjectOnServer
//--------------------------------------------------------------------------------------------
function pcaObjectCreated(msg)
{
   console.log("=== pcaObjectCreated");
   console.log(msg);

   if(msg.status == "response"){
      requestGeneSetNames();
      requestExpressionDataSetNames();
   }else{
      alert("PCA module failed to create PCA object on server");
   }

} // pcaObjectCreated
//--------------------------------------------------------------------------------------------
// a simple test.  can be called from the console in global scope
demoPCAHighlight = function ()
{
   ids = ["TCGA.06.0192", "TCGA.12.0775", "TCGA.14.0789"];
   selectPoints(ids, true);

}; // demoHighlight
//----------------------------------------------------------------------------------------------------
demo = function ()
{
  msg = {cmd: "specifyCurrentDataset", callback: "pcaCurrentDataSetSpecified",
         status: "request", payload: "DEMOdz"};

  hub.send(JSON.stringify(msg));

}; // demo
//----------------------------------------------------------------------------------------------------
function demoPcaCalculateAndDraw(msg)
{
  if(msg.status != "success"){
     alert("demoPCA failed: " + msg.payload);
     return;
     }

  var currentGeneSet = geneSetMenu.val();
  if(currentGeneSet === null)
      currentGeneSet = "tcga.GBM.classifiers";

  console.log("demoPCA, currentGeneSet: " + currentGeneSet);
  payload = {ids: "", geneSet: currentGeneSet};
  msg = {cmd: "calculate_mRNA_PCA", callback: "pcaPlot", status: "request", payload: payload};
  hub.send(JSON.stringify(msg));

} // demoPcaCalculateAndDraw
//----------------------------------------------------------------------------------------------------

function runTests()
{
  // the test does not currently depend upon any other tabs, but we want to add some
  // real world complexity to the situation, so we use tabs, including cpa (of course)
  // and the usual introcutory "Datasets" tab.  make sure it is there.
  // tests depend upon the presence of 2 tabs in addition to the present one.

  var datasetsTabPresent = $("#datasetsDiv").length > 0;

  if(!datasetsTabPresent){
     alert("Datasets tab needed for QUnit testing");
     return;
     } // check for other needed tabs

   testResultsOutputDiv.css({display: "block"});
   testLoadDataset();

} // runTests
//--------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
//
function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserId",  callback: "pcaAssessUserIdForTesting",
              status: "request", payload: ""};

   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate 
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   var userID = msg.payload;

   if(userID.indexOf("autoTest") === 0){
      console.log("pca/Module.js running tests for user " + userID);
      for(var i=0; i < 3; i++)
          runTests();
      } // if autoTest

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
function ModuleMsg(){
  console.log("***** in ModuleMsg, pcaMsg.selectedID.length is ", pcaMsg.selectedIDs.length);
  return pcaMsg;
}
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.addOnDocumentReadyFunction(initializeUI);
   hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
   hub.addMessageHandler("datasetSpecified", datasetSpecified);
   hub.addMessageHandler("sendSelectionTo_PCA", handlePatientIDs);
   hub.addMessageHandler("sendSelectionTo_PCA (highlight)", highlightPatientIDs);
   hub.addMessageHandler("pcaObjectCreated", pcaObjectCreated);
   hub.addMessageHandler("pcaHandleGeneSetNames", handleGeneSetNames);
   hub.addMessageHandler("pcaHandleExpressionDataSetNames", handleExpressionDataSetNames);
   hub.addMessageHandler("pcaPlot", pcaPlot);
   hub.addMessageHandler("demoPcaCalculateAndDraw", demoPcaCalculateAndDraw);
   hub.addMessageHandler("pcaAssessUserIdForTesting", assessUserIdForTesting);

   //hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);

   //hub.addMessageHandler("handlePatientClassification", handlePatientClassification)
   // hub.addSocketConnectedFunction(getPatientClassification);

} // initializeModule
//----------------------------------------------------------------------------------------------------
return{
  init: initializeModule,
  demo: demo,
  ModuleMsg: ModuleMsg
  };
    
}); // PCAModule
//----------------------------------------------------------------------------------------------------
pca = PCAModule();
pca.init();

var plsrXXX;
//----------------------------------------------------------------------------------------------------
var PLSRModule = (function () {

  var plsrDisplay;
  var d3plsrDisplay;
  var statusDiv; 

  var geneLoadings = [];
  var geneNames = [];
  var vectors = [];
  var vectorNames = [];

  var firstTime = true;
  var sendSelectionMenu;

      // these are reported by the server, from an inspection of the data
  var ageAtDxMin=0, ageAtDxMax=1000, survivalMin=0, survivalMax=1000;

      // 4 sliders and their readout
  var ageAtDxSlider, ageAtDxMinSliderReadout, ageAtDxMaxSliderReadout;
  var survivalSlider, survivalMinSliderReadout, survivalMaxSliderReadout;

      // the current values specifying the subsets
      // set as 1/3 from min and max initially, subsequently read
      // from the sliders
  var ageAtDxMinThreshold, ageAtDxMaxThreshold, survivalMinThreshold, survivalMaxThreshold;

  var calculateButton;
  var clearSelectionButton;
  var d3brush;
  var currentlySelectedRegion;
  var thisModuleName = "PLSR";
  var geneSetMenu;
  var expressionDataSetMenu;

  var thisModulesName = "PLSR";
  var thisModulesOutermostDiv = "plsrDiv";
  var testResultsOutputDiv;
  var currentAbsoluteMaxValue; // most recent max value, used for scaling

  var sendSelectionsMenuTitle = "Send selection...";
  var selectionDestinationsOfferedHere = ["PLSR (highlight)"];
 
  var expressionDataSetName = "";
  var currentExpressionDataSet;
  var plsrMsg = {}; 

//--------------------------------------------------------------------------------------------
function initializeUI () 
{
   plsrDisplay = $("#plsrDisplay");
   d3plsrDisplay = d3.select("#plsrDisplay");

   statusDiv = $("#plsrStatusDiv");

   ageAtDxSlider = $("#plsrAgeAtDxSlider");
   ageAtDxMinSliderReadout = $("#plsrAgeAtDxMinSliderReadout");
   ageAtDxMaxSliderReadout = $("#plsrAgeAtDxMaxSliderReadout");

   survivalSlider = $("#plsrSurvivalSlider");
   survivalMinSliderReadout = $("#plsrSurvivalMinSliderReadout");
   survivalMaxSliderReadout = $("#plsrSurvivalMaxSliderReadout");

   calculateButton = $("#plsrCalculateButton");
   calculateButton.button();
   calculateButton.click(requestPLSRByOnsetAndSurvival);
   hub.disableButton(calculateButton);

   geneSetMenu = $("#plsrGeneSetSelector");
   expressionDataSetMenu = $("#plsrExpressionDataSetSelector");
   
   $(".plsrExpMenu").click(	 function(){$(".plsrExpMenu .dropdown").slideToggle();	 }   );

   $("#plsrExpressionDataSetSelector .flexcontainer").width($(window).width()/1.2);
   clearSelectionButton = $("#plsrClearSelectionButton");
   clearSelectionButton.button();
   clearSelectionButton.click(clearSelection);
   hub.disableButton(clearSelectionButton);

   sendSelectionMenu = hub.configureSendSelectionMenu("#plsrSendSelectionsMenu", 
                                                        selectionDestinationsOfferedHere,
                                                        sendSelections,
                                                        sendSelectionsMenuTitle);
   
   testResultsOutputDiv = $("#plsrTestingOutputDiv");

   $(window).resize(handleWindowResize);
   handleWindowResize();
   
   hub.disableTab(thisModulesOutermostDiv);
   
} // initializeUI
//--------------------------------------------------------------------------------------------
function addGeneSetNamesToMenu (geneSetNames)
{
   geneSetMenu.empty();
   if(geneSetNames.length === 0) {
      return;
      }
   
  if(typeof geneSetNames == "string") 
   	 geneSetNames = [geneSetNames];

      
   for(var i=0; i < geneSetNames.length; i++){
      optionMarkup = "<option>" + geneSetNames[i] + "</option>";
      geneSetMenu.append(optionMarkup);
      } // for i

} // addGeneSetNamesToMenu
//--------------------------------------------------------------------------------------------
function getAgeAtDxAndSurvivalInputRanges()
{
   msg = {cmd: "summarizePLSRPatientAttributes", callback: "handleAgeAtDxAndSurvivalRanges", 
          status: "request", payload: ["AgeDx", "Survival"]};

   hub.send(JSON.stringify(msg));

} // getAgeAtDxAndSurvivalInputRanges
//----------------------------------------------------------------------------------------------
function handleAgeAtDxAndSurvivalRanges(msg)
{
   console.log("=== Module.plsr, handleAgeAtDxAndSurvivalRanges");

   if(msg.status != "success"){
    //error message should be issued 
    return;
  }
   ageAtDxMin = Math.floor(msg.payload.AgeDx[0]/365.24);
   ageAtDxMax = Math.floor(msg.payload.AgeDx[4]/365.24);
   survivalMin = Math.floor(msg.payload.Survival[0]/365.24);
   survivalMax = Math.floor(msg.payload.Survival[4]/365.24);
   console.log("***** ageAtDxMin: ", ageAtDxMin);

   plsrMsg.ageAtDxMin = msg.payload.AgeDx[0];
   plsrMsg.ageAtDxMax = msg.payload.AgeDx[4];
   plsrMsg.survivalMin = msg.payload.Survival[0];
   plsrMsg.survivalMax = msg.payload.Survival[4];
  

   //ageAtDxMin = Math.floor(msg.payload.AgeDx[0])-1;
   //ageAtDxMax = Math.floor(msg.payload.AgeDx[4])+1;
   //survivalMin = Math.floor(msg.payload.Survival[0])-1;
   //survivalMax = Math.floor(msg.payload.Survival[4])+1;
   setupSliders();

     // now that sliders are set up, setup the geneSetName selector
   requestGeneSetNames();
   requestExpressionDataSetNames();

} // handleAgeAtDxAndSurvivalRanges 
//--------------------------------------------------------------------------------------------------
function sendSelections()
{
  var destination = sendSelectionMenu.val();
  selectedIDs = identifyEntitiesInCurrentSelection();

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: selectedIDs, count: selectedIDs.length, source: "plsr module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------------
function updateExpressionData()
{
  console.log("***** within updateExpressionData");
  currentExpressionDataSet = $(this).siblings("td").andSelf("td").eq(0).text();
	console.log("***** currentExpressionDataSet is ", currentExpressionDataSet);
  var changedText = currentExpressionDataSet;
  $(".plsrExpMenu a").eq(0).text(changedText);
}
//--------------------------------------------------------------------------------------------------
function requestPLSRByOnsetAndSurvival()
{
  ageAtDxMinThreshold = Number(ageAtDxMinSliderReadout.val()) * 365.24;
  ageAtDxMaxThreshold = Number(ageAtDxMaxSliderReadout.val()) * 365.24;
  survivalMinThreshold = Number(survivalMinSliderReadout.val()) * 365.24; 
  survivalMaxThreshold = Number(survivalMaxSliderReadout.val()) * 365.24;

  var currentGeneSetName = geneSetMenu.val();
  
  factor1 = {name: "AgeDx", 
             low: ageAtDxMinThreshold, 
             high: ageAtDxMaxThreshold};

  factor2 = {name: "Survival", 
             low: survivalMinThreshold,
             high: survivalMaxThreshold};
  
  payload = {genes: currentGeneSetName, 
             expressionDataSet: currentExpressionDataSet,
             factorCount: 2, 
             factors: [factor1, factor2]};
  console.log("***** requestPLSRByOnsetAndSurvival payload: ", payload);
  msg = {cmd: "calculatePLSR", callback: "handlePlsrResults", status: "request", payload: payload};
  msg.json = JSON.stringify(msg);

  hub.send(msg.json);
  $("#plsrInstructions").css("display", "none");
  $("#plsrDisplay").css("display", "block");
}  // requestPLSRByOnsetAndSurvival
//--------------------------------------------------------------------------------------------------
function setupSliders()
{
   var ageAtDxSpan = ageAtDxMax - ageAtDxMin;
   var survivalSpan = survivalMax - survivalMin;

   ageAtDxMinThreshold = Math.floor(ageAtDxMin + (ageAtDxSpan/3));
   ageAtDxMaxThreshold = Math.floor(1 + ageAtDxMax - (ageAtDxSpan/3));
   survivalMinThreshold = Math.floor(survivalMin + (survivalSpan/3));
   survivalMaxThreshold = Math.floor(1 + survivalMax - (survivalSpan/3));
 
   ageAtDxSlider.slider({
      range: true,
      slide: function(event, ui) {
          if(ui.values[0] > ui.values[1]){
            return false;
         }          
         ageAtDxMin = Number(ui.values[0]);
         ageAtDxMinSliderReadout.text (ui.values[0]);
         ageAtDxMax = Number(ui.values[1]);
         ageAtDxMaxSliderReadout.text (ui.values[1]);
         },
      min: ageAtDxMin,
      max: ageAtDxMax,
      values: [ageAtDxMinThreshold.toFixed(0), ageAtDxMaxThreshold.toFixed(0)]
      });
     ageAtDxMinSliderReadout.text(ageAtDxMinThreshold);
     ageAtDxMaxSliderReadout.text(ageAtDxMaxThreshold);

   survivalSlider.slider({
      range: true,
      slide: function(event, ui) {
         if(ui.values[0] > ui.values[1]){
            return false;
         }          
         survivalMin = ui.values[0];
         survivalMinSliderReadout.text(survivalMin);
         survivalMax = ui.values[1];
         survivalMaxSliderReadout.text(survivalMax);
         },
      min: survivalMin,
      max: survivalMax,
      //step: 0.1,
      values: [survivalMinThreshold, survivalMaxThreshold]
      });
   survivalMinSliderReadout.text(survivalMinThreshold);
   survivalMaxSliderReadout.text(survivalMaxThreshold);

} // setupSliders
//--------------------------------------------------------------------------------------------------
function handlePlsrResults (msg)
{
   firstTime = false;
   if(msg.status == "error"){
      alert(msg.payload);
      return;
      }

   var payload = msg.payload;

   var absMaxValue = payload.maxValue;
   vectors = payload.vectors;
   vectorNames = payload.vectorNames;
   geneLoadings = payload.loadings;
   geneNames = payload.loadingNames;
   console.log("****** handlePlsrResults vectors: ", vectors);
   console.log("****** handlePlsrResults vectorNames: ", vectorNames);
   console.log("****** geneLoadings: ", geneLoadings);
   console.log("****** geneNames: ", geneNames);
   currentAbsoluteMaxValue = absMaxValue; // most recent max value, used for scaling
   plsrMsg.genes = geneLoadings;
   plsrMsg.geneNames = geneNames;
   plsrMsg.vectors = vectors;
   plsrMsg.vectorNames = vectorNames;
   svg = d3PlsrScatterPlot(geneLoadings, geneNames, vectors, vectorNames, absMaxValue);
   postStatus("scatterplot complete");

} // handlePlsrResults
//--------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function d3PlotBrushReader () {

  currentlySelectedRegion = d3brush.extent();
  x0 = currentlySelectedRegion[0][0];
  x1 = currentlySelectedRegion[1][0];
  width = Math.abs(x0-x1);
  selectedIDs = identifyEntitiesInCurrentSelection();

  console.log("=== plsr d3PlotBrushReader");
  console.log("  selectedIDs: " + selectedIDs.length);
  console.log("   destinations: " + sendSelectionMenu.children().length);

  //hub.disableButton(sendSelectionMenu);

  //if(selectedIDs.length === 0) 
  //   hub.disableButton(sendSelectionMenu);
  //else{
  //   if(sendSelectionMenu.children().length > 1)  // always at least one entry, the menu title
  //    hub.disableButton(sendSelectionMenu);
  //  }

} // d3PlotBrushReader
//-------------------------------------------------------------------------------------------
function d3PlsrScatterPlot(genes, geneNames, vectors, vectorNames, absMaxValue)
{
   var padding = 70;
   var width = plsrDisplay.width();
   var height = plsrDisplay.height();

   d3plsrDisplay.select("#plsrSVG").remove();  // so that append("svg") is not cumulative

   geneDataset = genes;

   absMaxValue = 1.2 * absMaxValue;
   var negAbsMaxValue = -1.0 * absMaxValue;

   var xScale = d3.scale.linear()
                  .domain([negAbsMaxValue, absMaxValue])
                  .range([padding, width - padding * 2]);

   var yScale = d3.scale.linear()
                  .domain([negAbsMaxValue, absMaxValue])
                  .range([height - padding, padding]); // note inversion 
   
   plsrMsg.xScale = xScale;
   plsrMsg.yScale = yScale; 

   var xAxis = d3.svg.axis()
                 .scale(xScale)
                 .orient("bottom")
                 .ticks(5);

   var yAxis = d3.svg.axis()
                 .scale(yScale)
                 .orient("left")
                 .ticks(5);

   d3brush = d3.svg.brush()
                   .x(xScale)
                   .y(yScale)
                   .on("brushend", d3PlotBrushReader);

   function transform(d) {
      return "translate(" + xScale(d.Comp1) + "," + yScale(d.Comp2) + ")";
      } //transform

   var assignColor = d3.scale.ordinal()
                             .domain(["gene",     "vector"])
                             .range (["gray",     "red"]);

   var svg = d3plsrDisplay.append("svg")
               .attr("id", "plsrSVG")
               .attr("width", width)
               .attr("height", height)
               .call(d3brush);
               //.append("g");
               //.attr("transform", "translate(" + padding + "," + padding + ")");

   var tooltip = d3plsrDisplay.append("div")
                              .attr("data-toggle", "tooltip")
                              .style("position", "absolute")
                              .style("z-index", "10")
                              .style("visibility", "hidden")
                              .text("a simple tooltip");


        // draw the genes

   var circle= svg.selectAll("circle")
                  .data(geneDataset)
                  .enter()
                  .append("circle")
                  .attr("cx", function(d,i) {return xScale(d[0]);})
                  .attr("cy", function(d,i) {return yScale(d[1]);})
                  .attr("r",  function(d)   {return 3;})
                  .text(function(d,i){
                     return(geneNames[i]);
                     })
                  .style("fill", function(d) { return assignColor(d.category); })
                  .on("mouseover", function(d,i){
                     tooltip.text(geneNames[i]);
                     return tooltip.style("visibility", "visible");
                     })
                  .on("mousemove", function(){
                      return tooltip.style("top", (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");})
                  .on("mouseout", function(){return tooltip.style("visibility", "hidden");});

   var line = svg.selectAll("line")
                 .data(vectors)
                 .enter().append("line")
                         .attr("class", "line")
                         .style("stroke-width", 1)
                         .style("stroke", "red")
                         .attr("x1", xScale(0))
                         .attr("y1", yScale(0))
                         .attr("x2", function(v) { return xScale(v[0]); })
                         .attr("y2", function(v) { return yScale(v[1]); });

   var text = svg.selectAll("text")
                 .data(vectors)
                 .enter().append("text")
                         .attr("class", "text")
                         .attr("x", function(v) { return xScale(v[0]); })
                         .attr("y", function(v) { return yScale(v[1]); })
                         .text( function(v, i) {return vectorNames[i];})
                         .attr("text-anchor", "middle")
                         .style("fill", "black") ;
   return(svg);

} // d3PlsrScatterPlot
//--------------------------------------------------------------------------------------------
function handleWindowResize ()
{
   plsrDisplay.width($(window).width() * 0.95);
   plsrDisplay.height($(window).height() * 0.75);

   if(!firstTime)  // easiest way to handle resize: redraw from scratch
      d3PlsrScatterPlot(geneLoadings, geneNames, vectors, vectorNames, currentAbsoluteMaxValue);

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function identifyEntitiesInCurrentSelection ()
{
   x1 = currentlySelectedRegion[0][0];
   y1 = currentlySelectedRegion[0][1];
   x2 = currentlySelectedRegion[1][0];
   y2 = currentlySelectedRegion[1][1];
   ids = [];
   for(var i=0; i < geneLoadings.length; i++){
     x = geneLoadings[i][0];
     y = geneLoadings[i][1];
     geneSymbol = geneNames[i];
     if(x >= x1 & x <= x2 & y >= y1 & y <= y2)         
       ids.push(geneSymbol);
      } // for i

   return(ids);
    
} // identifyEntitiesInCurrentSelection
//--------------------------------------------------------------------------------------------
function selectPoints(ids, clearIDs)
{
   d3.selectAll("circle")
     .filter(function(d,i){
         match = ids.indexOf(geneNames[i]);
         if(match >= 0){
            console.log("PLSR select match: " + geneNames[i]);
            }
         return (match >= 0);
         }) // filter
     .classed("highlighted", true)
     .transition()
     .attr("r", 20)
     .style("fill", "red")
     .duration(500);

  hub.enableButton(clearSelectionButton);
  //pcaMsg.highlightIndex = highlightIndex;
   setTimeout(function(){
            console.log("***** Module.js within selectPoints before qunit");
            console.log("***** Date time: ", Date());
            postStatus("selectPoints are highlighted"); 
   }, 6000);
} // selectPoints
//----------------------------------------------------------------------------------------------------
function clearSelection()
{

  d3.selectAll("circle")
    .classed("highlighted", false)
    .attr("r", 3);

  d3brush.clear();
  svg.selectAll('.brush').call(d3brush);
  handleWindowResize();

} // clearSelection
//----------------------------------------------------------------------------------------------------
function highlightGenes(msg)
{
   hub.raiseTab(thisModulesOutermostDiv);

   var candidates = msg.payload.value;
   console.log("PLSR highlight genes, candidates: " + candidates.length);
   console.log("                  currently held: " + geneNames.length);

   var intersection = hub.intersectionOfArrays(candidates, geneNames);
   console.log("                    intersection: " + intersection.length);
   console.log(JSON.stringify(intersection));

   if(intersection.length === 0){
     count = candidates.length;
     errorMessage = "None of the incoming ids were recognized: ";
     for(var i=0; i < count; i++){
       errorMessage += candidates[i] + " ";
       }
     title = "Unrecognized Identifiers";
     $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
     } // if intersection
   else
     selectPoints(candidates, true);

} // highlightGenes
//----------------------------------------------------------------------------------------------------
function requestGeneSetNames()
{
   callback = "plsrHandleGeneSetNames";

   msg = {cmd:"getGeneSetNames",
          callback: callback,
          status:"request",
          payload:""};

   hub.send(JSON.stringify(msg));

} // requestGeneSetNames
//--------------------------------------------------------------------------------------------
function handleGeneSetNames(msg)
{
   newNames = msg.payload;
   addGeneSetNamesToMenu(newNames);
   hub.enableButton(calculateButton);
   hub.enableTab(thisModulesOutermostDiv);

   postStatus("plsr ui now configured");

} // handleGeneSetNames
//--------------------------------------------------------------------------------------------
function requestExpressionDataSetNames()
{
   console.log("=== requestExpressionDataNames");

   callback = "plsrHandleExpressionDataSetNames";

   msg = {cmd:"getExpressionDataSetNames",
          callback: callback,
          status:"request",
          payload:""};

   hub.send(JSON.stringify(msg));

} // requestExpressionDataSetNames
//----------------------------------------------------------------------------------------------------
function handleExpressionDataSetNames(msg)
{
   console.log("=== handleExpressionDataSetNames");
   $(".plsrExpMenu .dropdown table").empty();
   $(".plsrExpMenu a").eq(0).text("Choose Expression Data");
   expManifest = msg.payload.mtx;
   console.log("***** after grabbing manifest matrix: ", expManifest);
   var expNames = [];
   for(var i=0; i < expManifest.length; i++){
     expNames.push(expManifest[i][0]);
   }

   expManifestCols = msg.payload.colnames;
   $(".plsrExpMenu .dropdown table").append("<tr id='plsrExpManiCols'></tr>");
   for(i=0; i<expManifestCols.length; i++){
      var singleRecord = "<th class='strong'>" + expManifestCols[i]+
                         "</th>";
      $("#plsrExpManiCols").append(singleRecord);
   }
   console.log("***** expression dataset Names are: ", expNames);
   //addExpressionDataSetNamesToMenu(expNames);
   addExpressionDataSetNamesToMenu(expManifest);

} // handleExpressionDataSetNames
 //----------------------------------------------------------------------------------------------------
 function addExpressionDataSetNamesToMenu (expManifest)
 {
    console.log("Module.plsr:addExpressionDataSetNamesToMenu");
 
    //expressionDataSetMenu.empty();
 
    if(expManifest.length === 0) {
      postStatus("addExpressionDataSetNamesToMenu: expManifest.length == 0");
      return;
      }
     
    if(typeof expManifest === "string") 
      expressionDataSetNames = [expManifest][0]; 
    
    var singleRecord;
       
    for(var i=0; i<expManifest.length; i++){
      $(".plsrExpMenu .dropdown table").append("<tr class='plsrExpClickable' id='plsrExpMani" + i + "'></tr>");
      for(var j=0; j<expManifest[i].length; j++){
          singleRecord = '<td><a href="#" style="text-decoration:none">' + expManifest[i][j] + '</a></td>';
          $("#plsrExpMani" + i).append(singleRecord);
          console.log("***** single Records in plsr", singleRecord);
        } // for j
      } // for i
    $(".plsrExpMenu .plsrExpClickable td").click(updateExpressionData);

// default: pre-select first dataset
    $("tr#plsrExpMani0 td")[0].click()
    $(".plsrExpMenu").click()

  
   postStatus("addExpressionDataSetNamesToMenu: complete");
   hub.enableTab(thisModulesOutermostDiv);

 
 } // addExpressionDataSetNamesToMenu
//----------------------------------------------------------------------------------------------------
// when a dataset is specified, this module 
//  1) extracts the name of the dataset from the payload of the incoming msg
//  2) (for now) extracts the name of the matrices, from the manifest (also in the payload
//     of the incoming msg, chooses the first mtx.mrna entry it finds
//  3) sends a "createPLSR" message to the server, with dataset & matrix name specified
//  4) asks that the server, upon successful completion of that createPLSR request, callback
//     here so that the sliders can be set
function datasetSpecified(msg)
{
   console.log("==== Module.plsr, datasetSpecified");
   console.log(msg);

   plsrXXX = msg;
   var dataPackageName = msg.payload.datasetName;
 
       // ["mtx.cn.RData", "history.RData", "mtx.mrna.RData", "mtx.mrna.ueArray.RData", 
       // "mtx.mut.RData", "mtx.prot.RData", "mtx.meth.RData", "markers.json.RData", 
       // "genesets.RData", "g.markers.json"]
   var dataElementNames = msg.payload.rownames;

      // for now, and very temporarily, use the first match (if any are found)
   var hits = dataElementNames.map(function(name) {if(name.indexOf("mtx.mrna") >= 0) return(name);});
   hits = hits.filter(function(n){ return (n !== undefined); });

   var matrixName = null;

   if(hits.length > 0){
        // for now always grab the last hit, remove the trailing .RData
        // the PLSR constructor wants both dataPacakgeName & a matrix name
        // our convention is that the maniftest rowname is the same as
        // its name, with ".RData" appended
      var lastHit = hits.length - 1;
      matrixName = hits[lastHit].replace(".RData", "");
      }
   else{
      alert("No mtx.mrna in dataset '" + dataPackageName + "'");    
      hub.disableButton(calculateButton);
      return;
      }
   d3plsrDisplay.select("#plsrSVG").remove();  // so that old layouts aren't mistaken for new dataset
      
   createPlsrObjectOnServer(dataPackageName, matrixName);

} // datasetSpecified
//--------------------------------------------------------------------------------------------
function createPlsrObjectOnServer(dataPackageName, matrixName)
{
  console.log("create PLSR on server " + dataPackageName + ": " + matrixName);
  payload = {dataPackage: dataPackageName, matrixName: matrixName};

  msg = {cmd: "createPLSR", callback: "plsrObjectCreated", status: "request", payload: payload};

  msg.json = JSON.stringify(msg);
  hub.send(msg.json);

} // createPlsrObjectOnServer
//--------------------------------------------------------------------------------------------
function requestSliderRanges(msg)
{
   console.log("--- requestSliderRanges");
   console.log(msg);
   msg = {cmd: "summarizePLSRPatientAttributes",
          callback: "handleAgeAtDxAndSurvivalRanges",
          status: "request", payload: ["AgeDx", "Survival"]};

   hub.send(JSON.stringify(msg));

} // requestSliderRanges
//--------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
/*function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserId",  callback: "plsrAssessUserIdForTesting",
              status: "request", payload: ""};

   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   var userID = msg.payload;

   if(userID.indexOf("autoTest") === 0){
      console.log("plsr/Module.js running tests for user " + userID);
      var plsrTester = PlsrTestModule();
      plsrTester.run();
      } // if autoTest

} // assessUserIdForTesting*/
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.addOnDocumentReadyFunction(initializeUI);
   hub.registerSelectionDestination(selectionDestinationsOfferedHere, thisModulesOutermostDiv);
   hub.addMessageHandler("plsrHandleExpressionDataSetNames", handleExpressionDataSetNames);
   hub.addMessageHandler("plsrHandleGeneSetNames", handleGeneSetNames);
   hub.addMessageHandler("handlePlsrResults", handlePlsrResults);
   hub.addMessageHandler("handleAgeAtDxAndSurvivalRanges", handleAgeAtDxAndSurvivalRanges);
   hub.addMessageHandler("datasetSpecified", datasetSpecified);
   hub.addMessageHandler("sendSelectionTo_PLSR (highlight)", highlightGenes);
   hub.addMessageHandler("plsrObjectCreated", requestSliderRanges);
   //hub.addMessageHandler("plsrAssessUserIdForTesting", assessUserIdForTesting);
   //hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);

} // initializeModule
//--------------------------------------------------------------------------------------------
function ModuleMsg(){
  return plsrMsg;
}
//----------------------------------------------------------------------------------------------------
return{
   init: initializeModule,
   ModuleMsg: ModuleMsg
   };

}); // PLSRModule
//----------------------------------------------------------------------------------------------------
plsr = PLSRModule();
plsr.init();
"user strict";
//----------------------------------------------------------------------------------------------------
var OncoprintModule = (function () {
  var statusDiv; 
//  var sendSelectionsMenu;

  var thisModulesName = "Oncoprint";
  var thisModulesOutermostDiv = "oncoprintDiv";

//  var sendSelectionsMenuTitle = "Send selection...";

      // sometimes a module offers multiple selection destinations
      // but usually just the one entry point
  var selectionDestinations = [thisModulesName];
      // make sure to register, eg,
      // hub.addMessageHandler("sendSelectionTo_blankTab", handleSelections);
  var onc;
  var cell_padding = 3;
  var cell_width = 4;
  var whitespace_on = true;
//  var track_id = [];
  var cnv_data,mnra_data,mut_data, cnv_data_promise,mrna_data_promise,mut_data_promise;
  var OncoprintDiv = $("#oncoprintDiv");
  var ControlsDiv = $("#oncoprintControlsDiv");
  var compute_start;
  var genes; 
//--------------------------------------------------------------------------------------------
function initializeUI()
{
  statusDiv = $("#oncoprintStatusDiv");
  $(window).resize(handleWindowResize);

//  sendSelectionsMenu = hub.configureSendSelectionMenu("#oncoprintSendSelectionsMenu", 
//                                                      selectionDestinations, 
//                                                      sendSelections,
//                                                      sendSelectionsMenuTitle);
  $("#oncoprintControlsDiv").css("display", "none");
  $('#toggle_whitespace').click(function() {
  onc.toggleCellPadding();
  });
  var z = 1;
  $('#reduce_cell_width').click(function() {
  z *= 0.5;
  onc.setZoom(z);
  });
  
  handleWindowResize();
  hub.disableTab(thisModulesOutermostDiv);
} // initializeUI
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  OncoprintDiv.width($(window).width() * 0.95);
  
  ControlsDiv.width(OncoprintDiv.width()); //  * 0.95);
  ControlsDiv.height("100px");

  $("#onc").width(OncoprintDiv.width()); //  * 0.95);
  
  OncoprintDiv.height($("#onc").height() + 100);  // leave room for tabs above  

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();

   var cmd = "sendSelectionTo_" + destination;
   var dummySelections = ["dummy selection 1", "dummy selection 2"];

   payload = {value: dummySelections, count: dummySelections.length, 
             source: thisModulesName};

   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//----------------------------------------------------------------------------------------------------
function handleSelections(msg)
{
   hub.enableTab(thisModulesOutermostDiv);
   hub.raiseTab(thisModulesOutermostDiv);   //var msgAsString = JSON.stringify(msg.payload);
   
   var ids = msg.payload.value;
   //var testingMode = msg.testing;

   console.log("******handleSelections msg.payload.value: ", ids);
   console.log("******handleSelections ids typeof:", typeof(ids));
   console.log("******handleSelections [ids] type: ", typeof([ids]));
   if(Array.isArray(ids)){
      console.log("Oncoprint module, " + msg.cmd + " patients and markers: " + ids);
   }else{
      console.log("Oncoprint module, " + msg.cmd + " patients and markers length" + ids);
   }
   $("#onc").empty();
   compute_start = Date.now();
   $("#oncoprintInstructions").css("display", "none");
   $("#oncoprintControlsDiv").css("display", "block");
   analyzeSelectedTissues(ids);
} // handleSelections
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function analyzeSelectedTissues(IDs)
{   
   $("#onc").append("Computing...");
   $("#errorMessage2").empty();
   var payload;
   var msg;
   if(Array.isArray(IDs)){ 
     console.log("Oncoprint module, hub.send 'oncoprint_data_selection' for %d IDs",
                 IDs.length);
     //if(IDs.length > 350 && testingMode !== "testing"){
     if(IDs.length > 350){
        $("#errorMessage2").text("Please choose less than 350 Nodes");
        $("#errorMessage2").dialog();
        postStatus("msg.status is error.");
        $("#oncoprintInstructions").css("display", "block");
        $("#oncoprintControlsDiv").css("display", "none");
        $("#onc").empty();
        postStatus("too many nodes selected");
     }else{
          payload = {sampleIDs: IDs};
          msg = {cmd:"oncoprint_data_selection", callback: "displayOncoprint", status: "request", 
            payload: payload};
          hub.send(JSON.stringify(msg));
    }   
   }else{
     console.log("Oncoprint module, hub.send 'oncoprint_data_selection' for %d IDs",
                 IDs);
     if(IDs > 350){  
        $("#errorMessage2").text("Please choose less than 350 Nodes");
        $("#errorMessage2").dialog();
        postStatus("msg.status is error.");
        $("#oncoprintInstructions").css("display", "block");
        $("#oncoprintControlsDiv").css("display", "none");
        $("#onc").empty();
        postStatus("too many nodes selected");
     }else{
          payload = {sampleIDs: IDs};
          msg = {cmd:"oncoprint_data_selection", callback: "displayOncoprint", status: "request", 
            payload: payload};
         hub.send(JSON.stringify(msg));
       }     
    } 
} // analyzeSelectedTissues
//----------------------------------------------------------------------------------------------------
function displayOncoprint(msg)
{
   $("#onc").empty();
   $("#errorMessage1").empty();
   console.log("entering displayOncoprint");
   
   //console.log("displayOncoprint print recieved msg.payload: %s", msg.payload);
   
   if(msg.status === "error") {
      var errorMessage = JSON.parse(msg.payload);
      console.log("***** displayOncoprint error section, msg.payload is ", errorMessage);
      $("#errorMessage1").text(errorMessage);
      $("#errorMessage1").dialog();
      $("#oncoprintInstructions").css("display", "block");
      $("#oncoprintControlsDiv").css("display", "none");  
      $("#onc").empty();
      postStatus("msg.status is error.");
   }else{
     xx = JSON.parse(msg.payload);
     console.log("displayOncoprint print recieved genes: %s",xx[1]);
     genes = xx[1];
     processed_data = JSON.parse(xx[0]);
     console.log("*****no error report but the processed_data is: ", processed_data);
     var then = Date.now(); 
     onc = Oncoprint.create('#onc', {cell_padding: cell_padding, cell_width: cell_width});
       console.log("Milliseconds to create Oncoprint div: ", Date.now() - then); 
     onc.suppressRendering();
       
     var startGenes = Date.now(); 
        
     $.when(processed_data).then(function() {

        if(typeof(genes) === "string"){
          genes = [genes];
         }  
        tracks_to_load = genes.length;
        console.log("Number of tracks to load: ", tracks_to_load);

        var track_id = [];
        for(i = 0; i < genes.length; i++){
          var thisGeneStart = Date.now();
          gene = genes[i];
    
          var data_gene = processed_data.filter(data_gene_map); 

          var addTrackStart = Date.now();
          track_id[i] = onc.addTrack({label: gene, removable:true}, 0);
          console.log("Milliseconds to addTrack ", gene, " : ", Date.now() - addTrackStart);

          if(i === 0){
            onc.setRuleSet(track_id[i], Oncoprint.GENETIC_ALTERATION);
          }else{
            onc.useSameRuleSet(track_id[i], track_id[0]);
          }

          onc.setTrackData(track_id[i], data_gene, true);

        }
        
      onc.releaseRendering();
      onc.sort();
      console.log("Milliseconds to step through processded_data ", Date.now() - startGenes);
    });    
    postStatus("oncoprint is displayed");
  }
   console.log("#######Computing since msg sent took: " + (Date.now() - compute_start) + " milliseconds"); 
   
} // displaySurvivalCurves
//----------------------------------------------------------------------------------------------------
function data_gene_map(obj) {
  return obj.gene === gene;
}

//-------------------------------------------------------------------------------------------
// when a dataset is specified, this module 
//  1) extracts the name of the dataset from the payload of the incoming msg
//  2) (for now) extracts the name of the matrices, from the manifest (also in the payload
//     of the incoming msg, chooses the first mtx.mrna entry it finds
//  3) sends a "createPLSR" message to the server, with dataset & matrix name specified
//  4) asks that the server, upon successful completion of that createPLSR request, callback
//     here so that the sliders can be set
function datasetSpecified(msg)
{
   console.log("--- Module.oncoprint, datasetSpecified: " + msg.payload);
   hub.enableTab(thisModulesOutermostDiv);
   $("#oncoprintInstructions").css("display", "block");
   $("#oncoprintControlsDiv").css("display", "none");
   $("#onc").empty();
   postStatus("dataset specified");
} // datasetSpecified
//--------------------------------------------------------------------------------------------
function demoPatientSet()
{
   var longSurvivors = ["TCGA.06.6693", "TCGA.12.1088", "TCGA.02.0113", "TCGA.02.0114", "TCGA.08.0344"];

   var firstFortyGbmPatients = ["TCGA.02.0001", "TCGA.02.0003", "TCGA.02.0006", "TCGA.02.0007",
                                "TCGA.02.0009", "TCGA.02.0010", "TCGA.02.0011", "TCGA.02.0014",
                                "TCGA.02.0021", "TCGA.02.0024", "TCGA.02.0027", "TCGA.02.0028",
                                "TCGA.02.0033", "TCGA.02.0034", "TCGA.02.0037", "TCGA.02.0038",
                                "TCGA.02.0043", "TCGA.02.0046", "TCGA.02.0047", "TCGA.02.0052",
                                "TCGA.02.0054", "TCGA.02.0055", "TCGA.02.0057", "TCGA.02.0058",
                                "TCGA.02.0060", "TCGA.06.0875", "TCGA.06.0876", "TCGA.06.0877",
                                "TCGA.06.0878", "TCGA.06.0879", "TCGA.06.0881", "TCGA.06.0882",
                                "TCGA.12.0670", "TCGA.12.0818", "TCGA.12.0819", "TCGA.12.0820",
                                "TCGA.12.0821", "TCGA.12.0822", "TCGA.12.0826", "TCGA.12.0827"];

   firstFortyGbmPatients.push(longSurvivors);
   return (firstFortyGbmPatients);

} // demoPatientSet
//----------------------------------------------------------------------------------------------------
return{
   init: function(){
        hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
        hub.addOnDocumentReadyFunction(initializeUI);
        hub.addMessageHandler("datasetSpecified", datasetSpecified);
        hub.addMessageHandler("sendSelectionTo_Oncoprint", handleSelections);
        hub.addMessageHandler("displayOncoprint", displayOncoprint);
      },
    genes: function(){
       return genes;
    }
}; // OncoprintTabModule return value

//----------------------------------------------------------------------------------------------------
}); // OncoprintTabModule

OncoprintM = OncoprintModule();
OncoprintM.init();
//----------------------------------------------------------------------------------------------------
var LinkoutModule = (function () {

  var thisModulesName = "linkout";
  var selectionDestinations = ["DGIdb", "Wikipedia", "Google", "GeneCards"];
  var thisModulesOutermostDiv = null;

//--------------------------------------------------------------------------------------------
function handleSelections_google(msg)
{
   console.log(JSON.stringify(msg));
   var ids = msg.payload.value;
   var searchString = ids[0];   // just one term for google

   var url = 'http://www.google.com/search?q="' + searchString + '"';
   window.open(url);

} // handleSelections_google
//----------------------------------------------------------------------------------------------------
function handleSelections_DGIdb(msg)
{
   console.log(JSON.stringify(msg));
   var ids = msg.payload.value;
   var searchString = ids[0];
   for(var i=1; i < msg.payload.value.length; i++)
     searchString = searchString + "," + ids[i];

   var url = "http://dgidb.genome.wustl.edu/interaction_search_results?genes=" + searchString; //=EGFR,MET
   url = url + "&limit_drugs=true";
   window.open(url);

} // handleSelections_DGIdb
//----------------------------------------------------------------------------------------------------
function handleSelections_wikipedia(msg)
{
   console.log(JSON.stringify(msg));
   var baseUrl = "https://en.wikipedia.org/wiki/";
   var ids = msg.payload.value;
   var searchString = ids[0];
   var url = baseUrl + searchString;
   window.open(url);

} // handleSelections_wikipedia
//----------------------------------------------------------------------------------------------------
function handleSelections_genecards(msg)
{
   console.log(JSON.stringify(msg));
   var baseUrl = "http://www.genecards.org/cgi-bin/carddisp.pl?gene=";
   var ids = msg.payload.value;
   var searchString = ids[0];
   var url = baseUrl + searchString;
   window.open(url);

} // handleSelections_genecards
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
   //hub.addOnDocumentReadyFunction(initializeUI);
   hub.addMessageHandler("sendSelectionTo_DGIdb", handleSelections_DGIdb);
   hub.addMessageHandler("sendSelectionTo_Wikipedia", handleSelections_wikipedia);
   hub.addMessageHandler("sendSelectionTo_Google", handleSelections_google);
   hub.addMessageHandler("sendSelectionTo_GeneCards", handleSelections_genecards);

} // initializeModule
//----------------------------------------------------------------------------------------------------
return{
   init: initializeModule
   }; // LinkoutModule return value

//----------------------------------------------------------------------------------------------------
}); // LinkoutModule

linkoutModule = LinkoutModule();
linkoutModule.init();


//----------------------------------------------------------------------------------------------------
    // observers used in QUnit testing
  var datasetsStatusObserver = null;
  var pcaStatusObserver = null;


var OncoscapeAppTestModule = (function () {


//--------------------------------------------------------------------------------------------
runTests = function()
{
   var datasetNames; 
   
   QUnit.test("all expected tabs present?", function(assert){
     console.log("starting 'all expected tabs present?' test");
     assert.equal($("#oncoscapeTabs").length, 1);               
     assert.equal($("#datasetsDiv").length, 1);
     assert.equal($("#patientHistoryDiv").length, 1);
     assert.equal($("#markersAndPatientsDiv").length, 1);
     assert.equal($("#gbmPathwaysDiv").length, 1);
     assert.equal($("#survivalDiv").length, 1);
     assert.equal($("#pcaDiv").length, 1);
     assert.equal($("#plsrDiv").length, 1);
     assert.equal($("#userDataStoreDiv").length, 1);
     });
 
   QUnit.test("determine available datasets", function(assert) {
      console.log("determine available datasets");
      datasetNames = $("#datasetMenu option").map(function(opt){return this.value})
      datasetNames = datasetNames.filter(function(e){return e});
      assert.ok(datasetNames.length > 0);        
      });

   console.log(datasetNames);
   console.log("datasetNames length: " + datasetNames.length);

   //for(var i=0; i < datasetNames.length; i++){
   //   console.log("about to start testing with dataset '" + datasetNames[i] + "'");
      testDisplayDataSetManifest("DEMOdz");
   //   }


}; // runTests
//----------------------------------------------------------------------------------------------------
//
// setup a mutation observer watching the datasetsStatusDiv
// raise the datasets tab
// select the named dataset
// mutation observer will call qunit_testManifestTableDisplayed
//
function testDisplayDataSetManifest(datasetName)
{
   var testTitle = 'display dataset manifest for ' + datasetName;

   console.log(testTitle);

   $("#datasetMenu").val(datasetName);
   $("#datasetMenu").trigger("change");
   
   var target = document.querySelector("#datasetsStatusDiv");
   console.log(" new mutobs target: " + target.id);

   if(datasetsStatusObserver == null) {
   datasetsStatusObserver = new MutationObserver(function(mutations) {
     datasetsStatusObserver.disconnect();
      //mutations.forEach(function(mutation) {
        var mutation = mutations[0];
        var id = mutation.target.id;
        var msg = $("#datasetsStatusDiv").text();
        console.log(id + " status changed: " + msg);
        QUnit.test(testTitle, function(assert) {
           assert.equal($("#datasetMenu").val(), datasetName);
           assert.ok($("#datasetsManifestTable tr").length >= 10);
           var firstRowTitle = $("#datasetsManifestTable tbody tr td")[0].innerHTML;
           var expectedTitles = ["mRNA expression", "mutations", "copy number", "history", 
                                 "protein abundance", "methylation", "geneset", "network"];
           assert.ok(jQuery.inArray(firstRowTitle, expectedTitles) >= 0);
           console.log("dispalyDataSetManifest test complete, now calling loadDataSet");
           firstTime = true;
           datasetsStatusObserver.disconnect();
           hub.raiseTab("datasetsDiv");
           testLoadDataSet(datasetName);
           }); // Qunit.test
         });  // new MutationObserver
      } // not null
   var config = {attributes: true, childList: true, characterData: true};
   datasetsStatusObserver.observe(target, config);
   console.log("observing " + target.id);

}; // testDisplayDataSetManifest
//----------------------------------------------------------------------------------------------------
function testLoadDataSet(datasetName)
{
   var testTitle = 'testLoadDataSet: ' + datasetName;
   console.log(testTitle);

   $("#selectDatasetButton").trigger("click");

     // patientHistory, PCA, PLSR tabs all respond to the "datasetSelected" message

   var pcaTarget = document.querySelector("#pcaStatusDiv");
   console.log(" new mutobs target: " + pcaTarget.id);

   if(pcaStatusObserver == null){
   pcaStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        pcaStatusObserver.disconnect();
        pcaStatusOvserver = null;
        var id = mutation.target.id;
        var msg = $("#pcaStatusDiv").text();
        console.log("======== ----- =========== " + id + " status changed: " + msg);
        QUnit.test("PCA button enabled after loading dataset", function(assert) {
           assert.equal($("#datasetMenu").val(), datasetName);
           assert.equal($("#pcaCalculateButton").prop("disabled"), false);
           });
      }) // new MutationObserver
     } // if null

   var config = {attributes: true, childList: true, characterData: true};
   pcaStatusObserver.observe(pcaTarget, config);
   console.log("observing " + pcaTarget.id);

   hub.raiseTab("pcaDiv");
 
}; // testLoadDataSet
//----------------------------------------------------------------------------------------------------
function testDEMOdzPLSRConfiguration()
{
   QUnit.test('testDEMOdzPLSRConfiguration', function(assert) {
      var minAge = $("#plsrAgeAtDxMinSliderReadout").val();
      assert.ok(minAge == "45");
      var maxAge = $("#plsrAgeAtDxMaxSliderReadout").val();
      assert.ok(maxAge == "66");
      var minSurvival = $("#plsrSurvivalMinSliderReadout").val();
      console.log("  minSurvival: " + minSurvival);
      assert.ok(minSurvival == "3");
      var maxSurvival = $("#plsrSurvivalMaxSliderReadout").val();
      console.log("  maxSurvival: " + maxSurvival);
      assert.ok(maxSurvival == "7"); 
      assert.ok($("#plsrGeneSetSelector").val() == "random.40");
      testRunPLSR();
      });

} // testDEMOdzPLSRConfiguration
//----------------------------------------------------------------------------------------------------
function testRunPLSR()
{
   QUnit.test('testRunPLSR', function(assert) {
      $("#plsrCalculateButton").trigger("click");
       assert.expect(6); 
       var done1 = assert.async();
       var done2 = assert.async();
       var done3 = assert.async();
       var done4 = assert.async();
       var done5 = assert.async();
       var done6 = assert.async();
       setTimeout(function(){
          assert.ok($("circle").length > 10); done1();
          assert.ok($("circle").length > 10); done2();
          var c0 = $("circle")[0];
          var geneName = c0.innerHTML;
          assert.ok(geneName == "PRRX1"); done3();
          var xPos = Number(c0.getAttribute("cx"));
          var yPos =  Number(c0.getAttribute("cy"));
          var radius = Number(c0.getAttribute("r"));
          assert.ok(xPos > 0); done4();
          assert.ok(yPos > 0); done5();
          assert.ok(radius > 0); done6();
          }, 5000);
      });

} // testRunPLSR
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   console.log("initializing scripts/apps/oncoscape");

} // initializeModule
//----------------------------------------------------------------------------------------------------
return{
   init: initializeModule,
   run: runTests
   }; // module return value

//----------------------------------------------------------------------------------------------------
}); // OncoscapeAppTestModule
oat = OncoscapeAppTestModule();
oat.init();

</script>

<body>

  <div id="qunit" style="display:none"></div>
  <div id="qunit-fixture"></div>

<div id="oncoscapeTabs">
   <ul>
     <li><a href="#DashboardDiv">Dashboard</a></li>
     <li><a href="#datasetsDiv">Datasets</a></li>
     <li><a href="#patientHistoryDiv">Patient History</a></li>
     <li><a href="#patientTimeLinesDiv">Timelines</a></li>
     <li><a href="#markersAndPatientsDiv">Markers &amp; Patients</a></li>
     <li><a href="#gbmPathwaysDiv">GBM Pathways</a></li>
     <li><a href="#survivalDiv">Survival</a></li>
     <li><a href="#pcaDiv">PCA</a></li>
     <li><a href="#plsrDiv">PLSR</a></li>
     <li><a href="#oncoprintDiv">Oncoprint</a></li>

   </ul>

<style>
ul.UserDocs {
    list-style-type: circle;
}

</style>

<div id="DashboardDiv" class="container">
   <a href="https://github.com/FredHutch/Oncoscape" target="_blank" ><img style="position: absolute; top: 0; right: 0; border: 0;" 
   src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67"
    alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a>
<!--    	<span id="InfoLogo_pathways" style="float:right">
          <img height="50" src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/oncoscape_thumb.png"
          alt="Info" data-canonical-src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/oncoscape_thumb.png/images/oncoscape_thumb.png">
        </span>
-->

   <div align="center" class="jumbotron"> 
       <div id="oncoscapeLogo" >	<img width="375" src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/oncoscape_logo_FINAL.png" alt="Oncoscape"/></div>

       <span> (version 1.4.94, March 10th, 2016)<br></span>
       <p> <font color="red">This website is undergoing frequent modification.  <br> User beware!</font></p>
   </div>   
 
   <center><p> Oncoscape works best with the latest Chrome browser, and a high resolution screen. </p></center>

       
	 <div id="DashboardAccordion">
		<h3 class="panel-title" style="margin-bottom:0px">
			<a class="collapsed" data-toggle="collapse" data-parent="#DashboardAccordion" href="#collapse1" aria-expanded="true" aria-controls="collapse1">
			  Available Data 
			</a>
		</h3>
		<div id="collapse1">
		   <div id="AvailableDataAccordian">     
		   <h3 class="panel-title" style="margin-bottom:0px">
			<a data-toggle="collapse" data-parent="#collapse1" href="#collapse11" aria-expanded="true" aria-controls="collapse11">
			  TCGA: The Cancer Genome Atlas
			</a>
		  </h3>
		  <div id="TCGAdataInfo" class="panel-body"></div>
  
		  <h3 class="panel-title" style="margin-bottom:0px">
			<a data-toggle="collapse" data-parent="#collapse1" href="#collapse22" aria-expanded="true" aria-controls="collapse22">
			  Restricted Data
			</a>
		  </h3>
		   <div id="collapse22" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading22">
			  <div id="UWMSCCAdataInfo" class="panel-body"> </div>      
		   </div>
		</div>
	 </div>
 
		<h3 class="panel-title" style="margin-bottom:0px">
			<a class="collapsed " data-toggle="collapse" data-parent="#DashboardAccordion" href="#collapse2" aria-expanded="true" aria-controls="collapse2">
			  Table of Contents
			</a>
		 </h3>
		<div id="collapse2" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading2">
		  <div id="TableContentsDiv" class="panel-body"></div>
		</div>
  
		<h3 class="panel-title" style="margin-bottom:0px">
			<a  class="collapsed " data-toggle="collapse" data-parent="#DashboardAccordion" href="#collapse3" aria-expanded="true" aria-controls="collapse3">
			  Features To Come...
			</a>
		  </h3>
		<div id="collapse3" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading3">
		  <ul id="FeaturesToCome">
				  <li> Saved Selections </li>
				  <li> Interactive Kaplan Meier Plots </li>
				  <li> Expression subtyping tool </li>
				  <li> Expression correlation to TCGA samples using MDS </li>
				  <li> Tool to find TCGA samples with similar mutational profiles </li>
				  <li> Expression clustering and heatmaps </li>
				  <li> Gene set enrichment analysis for user-selected groups </li>
				  <li> Differential expression analysis for user-selected groups </li>
				  <li> Hallmarks of Cancer </li>
			   </ul>
		  </div>
  
		<h3 class="panel-title" style="margin-bottom:0px">
			<a class="collapsed " data-toggle="collapse" data-parent="#DashboardAccordion" href="#collapse4" aria-expanded="false" aria-controls="collapse4">
			  About Oncoscape
			</a>
		  </h3>
		<div id="collapse4" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading4">
		  <div  id="AboutOncoscapeDiv" class="panel-body"></div>
		</div>
  
		<h3 class="panel-title" style="margin-bottom:0px">
			<a class="collapsed " data-toggle="collapse" data-parent="#DashboardAccordion" href="#collapse5" aria-expanded="false" aria-controls="collapse5">
			  Terms Of Use
			</a>
		  </h3>
		<div id="collapse5" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading5">
		  <div  id="LegalNotice" class="panel-body">
			<p>
				Oncoscape source code is freely available via <a href="http://github.com/FredHutch/oncoscape" name='newWindow'>GitHub</a> under the minimally restrictive <a href="http://opensource.org/licenses/MIT" name='newWindow'>MIT open source license</a>.
				Access to data in Oncoscape is restricted to the same conditions of use as specified in the original data source.
				<br/>By using this site, you agree to follow and be bound by the <a href="http://www.fredhutch.org/en/util/terms-privacy.html" name='newWindow'>terms of use and privacy policy</a>. If you do not agree with any of the terms, please do not use this site.
				</p>
		  </div>
		</div>
	</div>
		
 
 </div>

<style>
</style>

<div id="datasetsDiv" style="height:auto">
  <div id="datasetsStatusDiv" style="display:none"></div>
  <div id="dataSummaryControlsDiv">
     <span id="selectDataSetMenuLabel" style="margin-left: 20px;">Available Datasets</span>
     <select type="button" id="datasetMenu" style="margin: 5px;"><option> </option></select>
     <button id="selectDatasetButton">Use Dataset</button>
	 <span id="loadingDatasetMessage" style="display:none; margin-left:10px">Loading Dataset...</span>
     <select type="button" id="datasetsSendSelectionsMenu" style="float:right; margin:15px; display: none"></select>

  </div>

   <div id="dataSetNamesOutputDiv" style="margin: 20px;"></div>

   <div id="dataSummaryOutputDiv" style="margin: 20px;overflow-x:auto">
      <div id="datasetInstructions">Please select a dataset from the above menu.</div>
      <table id="datasetsManifestTable" class="display" cellpadding="0" cellspacing="0" style="margin:0px; width:auto; display:none; border:none"></table>
   </div>
</div>

<style>


#patientHistoryDiv{
   width: 600px;
   height: 400px;
   background-color: #ffffff;
   margin: auto;
   padding: 5px;
   }


#patientHistoryControlsDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  border-radius: 5px;
  margin-right: auto;
  margin-left: auto;
  margin-top: 10px;
  margin-bottom: 5px;
  padding: 0px;
  }

#patientHistoryTableDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  overflow-x:auto;
  margin-right: auto;
  margin-left: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  padding: 0px;
  }

.patientDataFilterSliderReadout {
  font-family:"Courier";
  color: #0000FF;
  background-color: #FFF;
  font-size: 12px;
  border: 2px solid #DDD;
  width: 50px;
  height: 25px;
  resize: none;
  margin-top: 5px;
  margin-left: 1px;
  }

.patientDataFilterSliderTitleDiv {
  font-family:"Arial";
  color: #000000;
  font-size: 12px;
  padding-top: 0px;
  padding-right:0px;
  }

.ColVis_collection{
width:auto;
}

</style>


<div id="patientHistoryDiv">
  <div id="patientHistoryStatusDiv" style="display:none"></div>
  <div id="patientHistoryControlsDiv">  


        <div id="ageSliderDiv" class="nav navbar-nav navbar-form navbar-left"  style="display: inline-block">
           <div id="ageAtDxSliderTitleDiv" class="patientDataFilterSliderTitleDiv" style="text-align: center; width=100%">Age at Dx</div>
           <div style="width: 280px; overflow: hidden;">
               <div id="ageAtDxMsgBox1" style="float: left; margin-left: 5px; margin-right: 15<px; width: 40px" >
  
                  <textarea id="ageAtDxMinSliderReadout" style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
               <div style="width: 120px; height: 6px; float: left; margin-top: 10px; 
                           margin-left: 30px; margin-right: 15px;" 
                   id="ageAtDxSlider" class="slider patientDataFilterSlider">
                   </div>
               <div id="ageAtDxMsgBox2" style="float: left">  
                  <textarea id="ageAtDxMaxSliderReadout" style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
              </div>
           </div>


        <div id="survivalSliderDiv" class="nav navbar-nav navbar-form navbar-left" style="display: inline-block">
           <div id="survivalSliderTitleDiv" class="patientDataFilterSliderTitleDiv" style="text-align: center; width=100%">Survival</div>
           <div style="width: 280px; overflow: hidden;">
               <div id="survivalMsgBox1" style="float: left" >  
                  <textarea id="survivalMinSliderReadout" style="font-size: 12px; height:16px"
                             readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
               <div style="width: 120px; height: 6px; float: left; margin-top: 10px; margin-left: 15px;
                            margin-right: 15px;" 
                   id="survivalSlider" class="slider patientDataFilterSlider">
                   </div>
               <div id="survivalMsgBox2" style="float: left">  
                  <textarea id="survivalMaxSliderReadout"  style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
              </div>
           </div>

     <button id="patientHistoryShowAllRowsButton" type="button">Reset</button>
     <select class="SelectionMenu" type="button" id="patientHistorySendSelectionsMenu" style="float:right; margin:15px"></select>


  </div>

  <div id="patientHistoryTableDiv">  
    <table id="patientHistoryTable" cellpadding="0" cellspacing="0" border="0" class="display">
    </table>
 </div>

</div>

<style>

.x.axis line {
  stroke: #fff;
}

.x.axis .minor {
  stroke-opacity: .5;
}

.x.axis path {
  fill: none;
  stroke: #000;
}
.y.axis line, .y.axis path {
  fill: none;
  stroke: #000;
}

.path {
  opacity: 0.7 ;
}

.path:hover {
  opacity: 1 ;
}

.eventNoHover {
	visibility: hidden;
}
.eventHover {
	visibility: visible !important;
}
.tooltipNoHover{
	visibility: hidden;
}
.tooltipHover{
	visibility: visible !important;
}

</style>

<div id="patientTimeLinesDiv" >
	<div id="ArrangeDataDiv" class="navbar navbar-default" role="navigation">
	<div class="navbar-collapse collapse navbar-inner">
	
	<div class="nav navbar-nav navbar-form navbar-left"  style="float:left">  
	     <span id="SideBarMenu">Features: </span>
	     <select type="button" id="SideBarOptions" style="margin: 5px;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
	     	<option selected="selected">--</option>
<!--	     	<option> Add+ </option>  -->
	     	<optGroup label='Category' class="plotCategoryOptions"></optGroup>
	     	<optGroup label='Value' class="plotValueOptions"></optGroup>	     
	     </select>
	     <span id="AlignByMenu" >Align By: </span>
	     <select type="button" id="AlignOptions"  name="AlignOptions" style="margin: 5px;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
	     	<option value="--" selected="selected">--</option>
	     </select>
	     <span id="OrderByMenu" >Order By: </span>
	     <select type="button" id="OrderOptions" name="OrderOptions" style="margin: 5px;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
	     	<option value="--" selected="selected">--</option>
<!--	     	<option> Add+ </option>  -->
	     	<optGroup label='Date' class="OrderByDateOptions"></optGroup>
	     	<optGroup label='Value' class="OrderByValueOptions"></optGroup>
	     </select>
	     <input type="checkbox" id="FitToPage" checked>Fit to Page </input>
	     
    </div>
    <div class="infoDiv nav navbar-nav navbar-form navbar-right"  style="float:right">
        <select class="btn btn-primary selectpicker SelectionMenu" id="timeLineSendSelectionsMenu" name="SendSelectionToModule" >Send Selection to...</select>
    </div>
       
       
       
    </div>
    </div>
    <br>
    <div id="TimeLineDisplay" class="content" style="margin:0 auto" >
    </div>
     
     <div id="AddCalculatedEvent" class="Modal" style="display:none">
     <form>
          <label for="Name">Name: </label>
          <input type="text" id="Name" value="e.g. Survival"><br>
          <label for="Event1">Event 1: </label>
          <select id="Event1"></select><br/>
          <label for="Event2">Event 2: </label>
          <select id="Event2"></select><br/>
          <label for="TimeScale"> Time Scale: </label>
          <select id="TimeScale" value="Days, Months, Years">
        		<option value="Days">Days</option>
        		<option value="Months">Months</option>
        		<option value="Years">Years</option>
          </select>
  	</form>
     </div>
     
    <svg>
      <defs>
        <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="4" height="4">
		  <path d="M-1,1 l2,-2
 		           M0,4 l4,-4
      			   M3,5 l2,-2" style="stroke:black; stroke-width:1; fill:grey border-radius:20px" />
		</pattern>      
      </defs>
	</svg>
 	
 
</div>

<style>

div {
   display: block;
   }

#gbmPathwaysDiv {
  }

#cyGbmPathwaysDiv {
  background-color: #FFFFFF;

  position: relative;

  height: 400px;
  width: 600px;

  border: 1px solid #aaa;

  margin-top: 0px;
  margin-left: 0px;

  padding: 0px;
  }

.gbmButton {
   font-size: 8pt;
   }

#gbmPathwaysMouseOverReadoutDiv{
  border: 1px solid #aaa;
  width: 800px;
  height: 20px;
  margin: 0px;
  }

#gbmPathwaysButtonDiv{
  margin-top: 0px;
  margin-bottom: 0px;
  }

#gbmPathwaysMovieSpeedReadout{
   border: 1px solid #aaa;
   width: 50px;
   height: 20px;
   margin: 0px;
   }
#bottomMargin{
   height:18px;
}
</style>
<script>
$("#gbmPathwaysMovieButton").click(function(){
    $(this).text("Stop");
});
</script>

<div id="gbmPathwaysDiv">
   <div id="gbmPathwaysStatusDiv" style="display:none"></div>
   <div id="gbmPathwaysButtonDiv" style="margin-bottom: 0px;bottom: 8px;">
      <!--
      <label id="gbmPathwaysSelectLabel" class="text-muted" for="select">Select a sample:</label>
      <select class="navbar-form selectpicker" id="gbmPathwaysSampleSelector"></select>
      -->
      <input type="text" id="gbmPathwaysSearchBox" value="search"></input>
      <!--
      <button id="gbmPathwaysMovieButton" style="width:100px"  type="button" class="btn btn-info navbar-btn  btn-xs"></button>
      <button id="gbmPathwaysSlowerMovieButton" type="button" class="btn btn-info navbar-btn btn-xs"> + </button>
      <span id="gbmPathwaysMovieSpeedReadout" class="navbar-btn btn-lg badge"></span> &nbsp;
      <button id="gbmPathwaysFasterMovieButton" type="button" class="btn btn-info navbar-btn btn-xs"> - </button>
      -->
      <button id="gbmViewAbstractsButton" type="button" class="btn btn-info navbar-btn btn-xs">Enable Abstracts</button>
      <button id="gbmZoomSelectedButton" type="button" class="btn btn-info navbar-btn btn-xs">Zoom Selected</button>
      <select class="SelectionMenu" type="button" id="gbmPathwaysSendSelectionMenu" style="float:right; margin-right:15px"></select>
    </div>

   <div id="cyGbmPathwaysDiv" class="content" style="margin:0 auto" ></div>

</div>





<style>

#cyMarkersDiv {
  background-color: white;  // medium light gray
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  margin-top: 2px;
  margin-left: 0px;
  padding: 0px;
  }

#cyMarkersDiv select, input, button{
  font-size: 14px;
  }
  
#markersControlsLayoutTable{
  border: 1px solid black;
  margin: 2px;
  width: 100%;
  }

.chosen-container, .chosen-drop .chosen-search input {
   width: 100% !important;
   -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
           box-sizing: border-box;
  }

</style>


<div id="markersAndPatientsDiv">
   <div id="markersAndTissuesControlsDiv">
      <table id="markersControlsLayoutTable">
         <tr>
           <td style="width:25%">
             <input type="text" id="markersAndTissuesMouseOverReadout" disabled
                    title="Edge and node names displayed here on hover"  style="width:80%; margin-right:2px"></input>
             <input type="text" id="markersSelectionCountReadout", disabled
                    title="Selected node count" style="width: 40px;"></input>

           </td>
   
           <td style="width:20%">
             <select id="cyMarkersOperationsMenu" style="float:right; margin-right:5px">
             </select>
           </td>

           <td style="width:10%">
             <select id="cyMarkersTumorCategorizationsMenu">
             </select>
           </td>
         
           <td style="width:30%">
             <select class="SelectionMenu" type="button" id="cyMarkersSendSelectionsMenu"
                     style="float:right; margin-right:5px">
            </select>
          </td>
         </tr>
    
      <tr>
          <td>
           <input type="text" id="markersAndTissuesSearchBox" placeholder="search" ></input>
           <button id="markersFitViewButton" title="Restore Initial View">Fit</button>
           <button id="markersShowEdgesFromSelectedButton" title="Show Edges from Selected Nodes">Show</button>
           <button id="markersHideEdgesButton" title="Hide Edges">Hide</button>
           <button id="markersZoomSelectedButton" title="Zoom into selected nodes">Zoom</button>
          </td>
    
          <td>
           <select id="markerLayouts" style="float:right; margin-right:5px">
           </select>
          </td>
          <td>
            <button id="markersSubSelectButton">Subselect</button>
          </td>

          <td>
             <select id="markersEdgeTypeSelector" 
                class="chosen-select form-control dropdown navbar-form selectpicker SelectionMenu"
                 multiple>
            </select>
          </td>
      </tr>
    
    </table>
    </div>
   
   
 <div id="cyMarkersDiv" data-toggle="tooltip" class="content" style="margin:0 auto" ></div>

 <div id="bottomMargin" style="width:100%;height:30px margin:0 auto"></div>

</div>





<style>

#survivalCurveDiv{
   width: 1000px;
   height: 500px;
   border: 1px solid #aaa;
}
#bottomMargin{
  height:18px;
}
</style>


<div id="survivalDiv" class="container-fluid">
  <div id="survivalInstructions"><p></p>Please select and send a group of patients to compare against the remaining population.</p>
  <p>Note that all patients with clinical histories are used in this comparison.</p>
  </div>
  <div id="survivalStatusDiv" style="display:none"></div>
  <div id="survivalCurveDiv" class="content" style="margin:0 auto" >
     <img id="survivalImageArea" width="800" height="800"></img>
  </div>

</div>


<style>

.domain { 
  fill: none; 
  stroke: black; 
  stroke-width; 1; 

  } 


.extent {
  fill-opacity: .1;
  stroke: #f00;
}


.axis path, .axis line {
    stroke: black;
    stroke-width: 1px;
    }

circle {
   opacity: 1;
   }

circle.highlighted {
   fill: orange;
   opacity: 1;
   }

#pcaDisplay {
   border: 1px solid #aaa;
   width: 50px;
   height: 50px;
   background-color: #FAFAFA;
   margin-top: 1px;
   margin-left: 19px;
   margin-right: 0;
   margin-bottom: 1px;
   padding: 1px;
   padding-bottom: 0px;
   }

#pcaBroadcastSelectionToClinicalTable{
   font-size: 10pt;
   }

#pcaHighlight{
   font-size: 10pt;
   }

.pcaButton {
   font-size: 8pt;
   }

.pcaDownload{
padding-left:10px;
color: #808080;
 cursor: pointer;
}

.pcaExpMenu {
    list-style:none;
    padding:0px 10px 0px 10px;
    float:left;
    display:block;
    text-align:center;
    position:relative;
    margin:3px 0px 0;
    border:none;
    margin-top: 0px !important;
}

.pcaExpMenu .dropdown {
    margin:-1px auto  0 200px;
    float:left;
    position:absolute;
    text-align:left;
    padding:10px 5px 10px 5px;
    border:1px solid #dedede;
    background:#fff;
    z-index:999;
    display:none;
}

.pcaExpMenu p {
    text-align:left;
}

.pcaExpMenu .dropdown table{
    border-collapse: collapse;
}

.strong {
    font-weight:bold;
}

.pcaExpMenu button{
    height: 31px;
    color: rgb(128, 128, 128);
    background-color: lightgray;
    border: 1px solid #d3d3d3;
    background: #CBCBCB;
    display: inline-block;
    position: relative;
    padding: 0;
    margin-right: .1em;
    text-decoration: none !important;
    cursor: pointer;
    text-align: center;
    zoom: 1;
    overflow: visible;
}

</style>

<div id="pcaDiv" class="container-fluid">
   <div id="pcaStatusDiv" style="display:none"></div>
   <div id="pcaControlsDiv">
    	  <span style="float:left">
	       <button id="pcaClearSelectionButton" style="margin-bottom: 5px;">Clear Selection</button>
    	  </span>
	      <span class="pcaExpMenu" id="pcaExpressionDataSetSelector" style="height:20px; margin-top:15px; margin-left:3px;">
            <button class="ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only"><a href="#">Choose Expression Data</a></button>
            <div class="dropdown">
                <table class="dropdownTable"></table>
             </div>   
          </span>
		<span style="float:left">
		   <select class="SelectionMenu" id="pcaGeneSetSelector" style="margin-bottom: 5px;"></select>
		   <button id="pcaCalculateButton" style="margin-bottom: 5px;">Calculate</button>
		   <button id="pcaUseAllSamplesButton" style="margin-bottom: 5px;">Use All Samples in Current Dataset</button>
       </span>
        <select class= "SelectionMenu" type="button" id="pcaSendSelectionsMenu" style="float:right; margin-right:15px"></select>
   </div>

   <div id="pcaInstructions" style="clear:both">Please select an expression data set and a gene set from the above menus and click the 'Calculate' button.</div>
   <div id="pcaOutputDiv"  style="clear:both">
      <div id="pcaDisplay"></div>
      <div id="pcaLegend"></div>
      <div id="pcaTextDisplayDiv"></div>
   </div>

</div>

<<<<<<< HEAD
<style>


.domain { 
  fill: none; 
  } 

.extent {
  fill-opacity: .1;
  stroke: #f00;
}


.axis path, .axis line {
    stroke: black;
    stroke-width: 1px;
    }

#plsrControlsDiv {
   border: 1px solid #aaa;
   font-family: sans-serif;
   font-size: 12px;
   margin-top: 2px;
   margin-left: 5px;
   margin-right: 10px;
   margin-bottom: 5px;
   height: 80px;
   background-color: #E8E8E8;
   }

#plsrPlotDiv {
   border-style: solid;
   border-width: 1px;
   width: 800px;
   height: 500px;
   margin: 5px;
   }

.plsrSlider { 
   margin-left:0px; 
   margin-right:0px; 
   margin-top:0px;
   border: 3px solid #FFF;
   background-color: #FFF;
   height: 20px;
   max: 0;  min: 10; 
   orientation: 'horizontal';

   }

.plsrSliderReadout {
  font-family:"Courier";
  color: #00F;
  background-color: #FFF;
  font-size: 12px;
  border: 2px solid #DDD;
  width: 40px;
  height: 18px;
  resize: none;
  margin-top: 5px;
  margin-left: 1px;
  }

.plsrSliderTitleDiv {
  font-family:"Arial";
  color: #000000;
  font-size: 14px;
  padding-top: 0px;
  }


#plsrButtonDiv{
   padding-botton: 30px;
   }

#plsrAgeAtDxSlider .ui-widget-header { border: 1px solid #fff; background: #fff; }
#plsrAgeAtDxSlider {  background: #E8E8E8; }
#plsrSurvivalSlider .ui-widget-header { border: 1px solid #fff; background: #fff; }
#plsrSurvivalSlider {  background: #E8E8E8; }

#plsrAgeAtDxSlider {
background:#ABD3E8;
}

#plsrSurvivalSlider {
background:#ABD3E8;
}

.plsrExpMenu {
    list-style:none;
    padding:0px 10px 0px 10px;
    float:left;
    display:block;
    text-align:center;
    position:relative;
    margin:3px 0px 0;
    border:none;
    margin-top: 0px !important;
}

.plsrExpMenu .dropdown {
    margin:-1px auto  0 -500px;
    float:left;
    position:absolute;
    text-align:left;
    padding:10px 5px 10px 5px;
    border:1px solid #dedede;
    background:#fff;
    z-index:999;
    display:none;
}

.plsrExpMenu p {
    text-align:left;
}

.plsrExpMenu .dropdown table{
    border-collapse: collapse;
}

.strong {
    font-weight:bold;
}

.plsrExpMenu button{
    height: 50px;
    color: rgb(128, 128, 128);
    background-color: lightgray;
    border: 1px solid #d3d3d3;
    background: #CBCBCB;
    display: inline-block;
    position: relative;
    padding: 0;
    margin-right: .1em;
    text-decoration: none !important;
    cursor: pointer;
    text-align: center;
    zoom: 1;
    overflow: visible;
}
</style>

<div id="plsrDiv" style="padding:0px; padding-top: 5px;">
   <div id="plsrStatusDiv" style="display:none"></div>
   <div id="plsrControlsDiv" class="flex-container">

          <div id="plsrAgeSliderDiv" style="display: inline-block; margin-top: 3px; margin-right: 20px; width:250px;">
             <div id="plsrAgeSliderTitleDiv" class="plsrSliderTitleDiv" style="text-align: center; width:100%">Age at Dx</div>
             <div id="plsrAgeSliderBodyDiv" style="overflow: hidden; display: inline-block">
                <div id='msgBox1' style="float:left; display: inline-block" >  
                   <textarea id="plsrAgeAtDxMinSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                </div>
                <div id="plsrAgeAtDxSlider" style="width: 120px; height: 6px; float: left; margin-top: 12px;" class="slider plsrSlider"></div>
                <div id='msgBox2' style="float: left" >  
                  <textarea id="plsrAgeAtDxMaxSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                 </div>
             </div>
         </div>

        <div id="plsrSurvivalSliderDiv" style="display: inline-block; margin-top: 3px; margin-left: 3px; margin-right: 10px; width:250px;">
           <div id="plsrSurvivalSliderTitleDiv" class="plsrSliderTitleDiv" style="text-align: center; width=100%">Survival</div>
           <div id="plsrSurvivalSliderBodyDiv" style="overflow: hidden; display: inline-block">
               <div id='msgBox3' style="float: left" >  
                  <textarea id="plsrSurvivalMinSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                </div>
               <div id="plsrSurvivalSlider" style="width: 120px; height: 6px; float: left; margin-top: 12px;" class="slider plsrSlider"></div>
               <div id='msgBox4' style="float: left; display: inline-block" >  
                    <textarea id="plsrSurvivalMaxSliderReadout" readonly class="plsrSliderReadout"></textarea> 
               </div>
           </div>
       </div>

       <div id="plsrCalculateButtonDiv" class="flex-container" style="margin-right: auto; margin-top:15px;">
          <button id="plsrClearSelectionButton" style="height:50px;">Clear<br>Selection</button>
          
          <div class="plsrExpMenu" id="plsrExpressionDataSetSelector" style="height:20px; margin-top:15px; margin-left:3px;">
            <button class="ui-button ui-widget ui-state-default ui-corner-all ui-button-text-only"><a href="#">Choose Expression Data</a></button>
            <div class="dropdown">
                <table class="dropdownTable"></table>
             </div>   
          </div>

          <select class="SelectionMenu" id="plsrGeneSetSelector" style="height:20px; margin-top:15px; margin-left:3px;" class="navbar-form selectpicker" ></select>
          <button id="plsrCalculateButton" style="height:50px;">Calculate</button>
          
       </div>
      <div id="plsrSendSelectionsMenuDiv" style="margin-right:10px; margin-top: 25px;">
         <select class="SelectionMenu" id="plsrSendSelectionsMenu" type="button" style="margin-top: 7px;"></select>
      </div>
  </div>
  <div id="plsrInstructions">
    <p>Please adjust the sliders specifying Age at Diagnosis and Survival ranges, select the desired expression dataset and gene set from dropdown menu, then click 'Calculate' to display the PLSR result.</p>
  </div>
  <div id="plsrDisplay" style="margin:0 auto; display: none"></div>

</div>
=======
<style>


.domain { 
  fill: none; 
  } 

.extent {
  fill-opacity: .1;
  stroke: #f00;
}


.axis path, .axis line {
    stroke: black;
    stroke-width: 1px;
    }

#plsrControlsDiv {
   border: 1px solid #aaa;
   font-family: sans-serif;
   font-size: 12px;
   margin-top: 2px;
   margin-left: 5px;
   margin-right: 10px;
   margin-bottom: 5px;
   height: 80px;
   background-color: #E8E8E8;
   }

#plsrPlotDiv {
   border-style: solid;
   border-width: 1px;
   width: 800px;
   height: 500px;
   margin: 5px;
   }

.plsrSlider { 
   margin-left:0px; 
   margin-right:0px; 
   margin-top:0px;
   border: 3px solid #FFF;
   background-color: #FFF;
   height: 20px;
   max: 0;  min: 10; 
   orientation: 'horizontal';

   }

.plsrSliderReadout {
  font-family:"Courier";
  color: #00F;
  background-color: #FFF;
  font-size: 12px;
  border: 2px solid #DDD;
  width: 40px;
  height: 18px;
  resize: none;
  margin-top: 5px;
  margin-left: 1px;
  }

.plsrSliderTitleDiv {
  font-family:"Arial";
  color: #000000;
  font-size: 14px;
  padding-top: 0px;
  }


#plsrButtonDiv {
   padding-botton: 30px;
   }
#plsrAgeAtDxSlider .ui-widget-header { border: 1px solid #fff; background: #fff; }
#plsrAgeAtDxSlider {  background: #E8E8E8; }
#plsrSurvivalSlider .ui-widget-header { border: 1px solid #fff; background: #fff; }
#plsrSurvivalSlider {  background: #E8E8E8; }

#plsrAgeAtDxSlider {
background:#ABD3E8;
}
#plsrSurvivalSlider {
background:#ABD3E8;
}

</style>


<div id="plsrDiv" style="padding:0px; padding-top: 5px;">
   <div id="plsrStatusDiv" style="display:none"></div>
   <div id="plsrControlsDiv" class="flex-container">

          <div id="plsrAgeSliderDiv" style="display: inline-block; margin-top: 3px; margin-right: 20px; width:250px;">
             <div id="plsrAgeSliderTitleDiv" class="plsrSliderTitleDiv" style="text-align: center; width:100%">Age at Dx</div>
             <div id="plsrAgeSliderBodyDiv" style="overflow: hidden; display: inline-block">
                <div id='msgBox1' style="float:left; display: inline-block" >  
                   <textarea id="plsrAgeAtDxMinSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                </div>
                <div id="plsrAgeAtDxSlider" style="width: 120px; height: 6px; float: left; margin-top: 12px;" class="slider plsrSlider"></div>
                <div id='msgBox2' style="float: left" >  
                  <textarea id="plsrAgeAtDxMaxSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                 </div>
             </div>
         </div>

        <div id="plsrSurvivalSliderDiv" style="display: inline-block; margin-top: 3px; margin-left: 3px; margin-right: 10px; width:250px;">
           <div id="plsrSurvivalSliderTitleDiv" class="plsrSliderTitleDiv" style="text-align: center; width=100%">Survival</div>
           <div id="plsrSurvivalSliderBodyDiv" style="overflow: hidden; display: inline-block">
               <div id='msgBox3' style="float: left" >  
                  <textarea id="plsrSurvivalMinSliderReadout" readonly class="plsrSliderReadout"></textarea> 
                </div>
               <div id="plsrSurvivalSlider" style="width: 120px; height: 6px; float: left; margin-top: 12px;" class="slider plsrSlider"></div>
               <div id='msgBox4' style="float: left; display: inline-block" >  
                    <textarea id="plsrSurvivalMaxSliderReadout" readonly class="plsrSliderReadout"></textarea> 
               </div>
           </div>
       </div>

       <div id="plsrCalculateButtonDiv" class="flex-container" style="margin-right: auto; margin-top:15px;">
          <button id="plsrClearSelectionButton" style="height:50px;">Clear<br>Selection</button>
          <button id="plsrCalculateButton" style="height:50px;">Calculate</button>
          <select class="SelectionMenu" id="plsrGeneSetSelector" style="height:20px; margin-top:15px; margin-left:3px;" class="navbar-form selectpicker" ></select>
       </div>
      <div id="plsrSendSelectionsMenuDiv" style="margin-right:10px; margin-top: 25px;">
         <select class="SelectionMenu" id="plsrSendSelectionsMenu" type="button" style="margin-top: 7px;"></select>
      </div>
  </div>
  <div id="plsrInstructions">
    <p>Please adjust the sliders specifying Age at Diagnosis and Survival ranges, select the desired gene set from dropdown menu, then click 'Calculate' to display the PLSR result.</p>
  </div>
  <div id="plsrDisplay" style="margin:0 auto; display: none"></div>

</div>
>>>>>>> fix-line-endings

<link rel="stylesheet" type="text/css" href="http://cdn.jsdelivr.net/qtip2/2.2.1/jquery.qtip.min.css">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
<script type="text/javascript" src="http://cdn.jsdelivr.net/qtip2/2.2.1/jquery.qtip.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore.js"></script>

<style>
.oncoprint-toolbar-ctr {
	display: inline-block;
	vertical-align: top;
	float: right;
}
.oncoprint-label-area-ctr {
	float:left;
	overflow: auto;
	width: auto;
}
.oncoprint-cell-area-ctr {
	overflow: auto;
	width: auto;
	position:relative;
}

.oncoprint-cell-area {
	background-color: transparent;
    	position: relative;
}

.oncoprint-column-highlight {
	position:absolute;
	width: 1px;
	border-left: 1px dashed rgba(0,0,0,0.75);
	top: 0px;
}

.oncoprint-cell {
	position: absolute;
}

.oncoprint-animated {
	-webkit-transition: 0.5s ease-out;
	-moz-transition: 0.5s ease-out;
	-o-transition: 0.5s ease-out;
	transition: 0.5s ease-out;
}

.oncoprint-cell-hover {
	outline: 1px solid DarkGray;
	position: absolute;
}

.oncoprint-legend-header {
	font-family: Arial !important;
	font-weight: bold !important;
	fill: gray !important;
	text-anchor: start;
	alignment-baseline: hanging;
	font-size: 12px;
	padding-right: 30px;
}

.oncoprint-legend-label {
	font-family: Arial;
	alignment-baseline: hanging;
	font-size: 12px;
}

.oncoprint-legend-block {
	display: inline-block;
}
.oncoprint-legend-element {
	display: inline-block;
}

.oncoprint-track-label {
	font-size: 12px;
}

.oncoprint-track-label-draggable {
	cursor: move;
}
.oncoprint-label-dragging {
	font-weight: bold !important;
	color: #ff0000;
}

.noselect {
	-webkit-touch-callout: none;
    	-webkit-user-select: none;
    	-khtml-user-select: none;
    	-moz-user-select: none;
    	-ms-user-select: none;
    	user-select: none;
}

.oncoprint-cell-qtip {
	background-color: rgba(0,0,0,0) !important;
	//border: none !important;
}
.oncoprint-cell-qtip .qtip-content {
	background-color: rgba(255,255,255,0.92) !important;
	font-size: 13px !important;
}
</style>
<script>
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.oncoprint_events = {
	ADD_TRACK: 'add_track.oncoprint',
	REMOVE_TRACK: 'remove_track.oncoprint',
	MOVE_TRACK: 'move_track.oncoprint',
	SORT: 'sort.oncoprint',
	SET_CELL_PADDING: 'set_cell_padding.oncoprint',
	SET_CELL_WIDTH: 'set_cell_width.oncoprint',
	SET_TRACK_DATA: 'set_track_data.oncoprint',
	SET_ID_ORDER: 'set_id_order.oncoprint',
	CELL_CLICK: 'cell_click.oncoprint',
	CELL_MOUSEENTER: 'cell_mouseenter.oncoprint',
	CELL_MOUSELEAVE: 'cell_mouseleave.oncoprint',
	ONCOPRINT_MOUSEENTER: 'oncoprint_mouseenter.oncoprint',
	ONCOPRINT_MOUSELEAVE: 'oncoprint_mouseleave.oncoprint',
	SET_PRE_TRACK_PADDING: 'set_pre_track_padding.oncoprint',
	TRACK_INIT: 'init.track.oncoprint',
	UPDATE_RENDER_RULES: 'update_render_rules.cell_renderer.oncoprint',
	FINISHED_RENDERING: 'finished_rendering.oncoprint',
	FINISHED_POSITIONING: 'finished_positioning.renderer.oncoprint',
	SET_ZOOM: 'set_zoom.oncoprint',
	SET_SORT_DIRECTION: 'set_sort_direction.oncoprint',
	SET_VISIBLE_ID_ORDER: 'set_visible_ids.oncoprint'
};
;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.oncoprint_utils = (function() {
	var exports = {};

	exports.sign = function(number) {
		return number?((number<0)?-1:1):0
	};

	exports.invert_array = function invert_array(arr) {
		return arr.reduce(function(curr, next, index) {
			curr[next] = index;
			return curr;
		}, {});
	};

	exports.cssClassToSelector = function(classes) {
		return "."+classes.split(" ").join(".");
	};
	exports.mouseY = function(evt) {
		return exports.ifndef(evt.offsetY, evt.originalEvent && evt.originalEvent.layerY);
	};
	exports.mouseX = function(evt) {
		return exports.ifndef(evt.offsetX, evt.originalEvent && evt.originalEvent.layerX);
	};
	exports.ifndef = function(val, replacement) {
		return (typeof val === 'undefined') ? replacement : val;
	};
	exports.extends = function(child_class, parent_class) {
		child_class.prototype = Object.create(parent_class.prototype);
		child_class.prototype.constructor = child_class;
	};

	exports.makeIdCounter = function() {
		var counter = 0;
		return function() {
			counter += 1;
			return counter;
		};
	};

	exports.clamp = function(t, a, b) {
		return Math.max(Math.min(b,t), a);
	};

	exports.makeD3SVGElement = function(tag) {
		return d3.select(document.createElementNS('http://www.w3.org/2000/svg', tag));
	};

	exports.appendD3SVGElement = function(elt, target, svg) {
		return target.select(function() {
			return this.appendChild(elt.node().cloneNode(true));
		});
	};

	exports.spaceSVGElementsHorizontally = function(group, padding) {
		var x = 0;
		var elts = exports.d3SelectChildren(group, '*').each(function() {
			if (this.tagName === 'defs') {
				// don't adjust spacing for a defs element
				return;
			}
			var transform = d3.select(this).attr('transform');
			var y = transform && transform.indexOf("translate") > -1 && parseFloat(transform.split(",")[1], 10);
			y = y || 0;
			d3.select(this).attr('transform', exports.translate(x, y));
			x += this.getBBox().width;
			x += padding;
		});
		return group;
	};

	exports.textWidth = function(string, font) {
		var obj = $('<div>'+string+'</div>')
				.css({position: 'absolute', float: 'left',
					'white-space':'nowrap', visibility: 'hidden',
					font: font})
				.appendTo($('body'));
		var width = obj.width();
		obj.remove();
		return width;
	};

	exports.d3SelectChildren = function(parent, selector) {
		return parent.selectAll(selector).filter(function() {
			return this.parentNode === parent.node();
		});
	};

	exports.warn = function(str, context) {
		console.log("Oncoprint error in "+context+": "+str);
	};

	exports.stableSort = function(arr, cmp) {
		// cmp returns something in [-1,0,1]

		var zipped = [];
		_.each(arr, function(val, ind) {
			zipped.push([val, ind]);
		});
		var stable_cmp = function(a,b) {
			var res = cmp(a[0], b[0]);
			if (res === 0) {
				if (a[1] < b[1]) {
					res = -1;
				} else if (a[1] > b[1]) {
					res = 1;
				}
			}
			return res;
		};
		zipped.sort(stable_cmp);
		return _.map(zipped, function(x) { return x[0];});
	};

	exports.lin_interp = function(t, a, b) {
		if (a[0] === '#') {
			var r = [parseInt(a.substring(1,3), 16), parseInt(b.substring(1,3), 16)];
			var g = [parseInt(a.substring(3,5), 16), parseInt(b.substring(3,5), 16)];
			var b = [parseInt(a.substring(5,7), 16), parseInt(b.substring(5,7), 16)];
			var R = Math.round(r[0]*(1-t) + r[1]*t).toString(16);
			var G = Math.round(g[0]*(1-t) + g[1]*t).toString(16);
			var B = Math.round(b[0]*(1-t) + b[1]*t).toString(16);

			R = R.length < 2 ? '0'+R : R;
			G = G.length < 2 ? '0'+G : G;
			B = B.length < 2 ? '0'+B : B;

			return '#' + R + G + B;
		} else if (isNaN(a) && a.indexOf('%') > -1) {
			var A = parseFloat(a, 10);
			var B = parseFloat(b, 10);
			return (A*(1-t) + B*t)+'%';
		} else {
			return a*(1-t) + b*t;
		}
	};

	exports.translate = function(x,y) {
		return "translate(" + x + "," + y + ")";
	};

	exports.assert = function(bool, msg) {
		if (!bool) {
			throw msg;
		}
	}
	return exports;
})();
;
window.oncoprint_defaults = (function() {
	var utils = window.oncoprint_utils;
	var makeGeneticAlterationComparator = function(distinguish_mutations) {
		var cna_key = 'cna';
		var cna_order = utils.invert_array(['AMPLIFIED', 'HOMODELETED', 'GAINED', 'HEMIZYGOUSLYDELETED', 'DIPLOID', undefined]);
		var mut_type_key = 'mut_type';
		var mut_order = (function() {
			if (!distinguish_mutations) {
				return function(m) {
					return +(typeof m === 'undefined');
				}
			} else {
				var _order = utils.invert_array(['TRUNC', 'INFRAME', 'MISSENSE', undefined]); 
				return function(m) {
					return _order[m];
				}
			}
		})();
		var mrna_key = 'mrna';
		var rppa_key = 'rppa';
		var regulation_order = utils.invert_array(['UPREGULATED', 'DOWNREGULATED', undefined]);

		return function(d1, d2) {
			var cna_diff = utils.sign(cna_order[d1[cna_key]] - cna_order[d2[cna_key]]);
			if (cna_diff !== 0) {
				return cna_diff;
			}

			var mut_type_diff = utils.sign(mut_order(d1[mut_type_key]) - mut_order(d2[mut_type_key]));
			if (mut_type_diff !== 0) {
				return mut_type_diff;
			}

			var mrna_diff = utils.sign(regulation_order[d1[mrna_key]] - regulation_order[d2[mrna_key]]);
			if (mrna_diff !== 0) {
				return mrna_diff;
			}

			var rppa_diff = utils.sign(regulation_order[d1[rppa_key]] - regulation_order[d2[rppa_key]]);
			if (rppa_diff !== 0) {
				return rppa_diff;
			}

			return 0;
		};
	};

	var genetic_alteration_config_base = {
		default: [{shape: 'full-rect', color: '#D3D3D3', z_index: -1}],
		altered: {
			'cna': {
				'AMPLIFIED': {
					shape: 'full-rect',
					color: 'red',
					legend_label: 'Amplification'
				},
				'GAINED': {
					shape: 'full-rect',
					color: '#FFB6C1',
					legend_label: 'Gain'
				},
				'HOMODELETED':{
					shape: 'full-rect',
					color: '#0000FF',
					legend_label: 'Deep Deletion'
				},
				'HEMIZYGOUSLYDELETED': {
					shape: 'full-rect',
					color: '#8FD8D8',
					legend_label: 'Shallow Deletion'
				}
			},
			'mrna': {
				'UPREGULATED': {
					shape: 'outline',
					color: '#FF9999',
					legend_label: 'mRNA Upregulation'
				},
				'DOWNREGULATED': {
					shape: 'outline',
					color: '#6699CC',
					legend_label: 'mRNA Downregulation'
				}
			},
			'rppa': {
				'UPREGULATED': {
					shape: 'small-up-arrow',
					color: 'black',
					legend_label: 'Protein Upregulation'
				},
				'DOWNREGULATED': {
					shape: 'small-down-arrow',
					color: 'black',
					legend_label: 'Protein Downregulation'
				}
			}
		},
		legend_label: "Genetic Alteration",
	};
	var genetic_alteration_config_nondistinct_mutations = $.extend(true,{},genetic_alteration_config_base);
	genetic_alteration_config_nondistinct_mutations.altered.mut_type = {
		'*': {
			shape: 'middle-rect',
			color: 'green',
			legend_label: 'Mutation'
		}
	};
	var genetic_alteration_config = $.extend(true,{},genetic_alteration_config_base);
	genetic_alteration_config.altered.mut_type = {
		'MISSENSE': {
			shape: 'middle-rect',
			color: 'green',
			legend_label: 'Missense Mutation'
		},
		'INFRAME': {
			shape: 'middle-rect',
			color: '#9F8170',
			legend_label: 'Inframe Mutation'
		},
		'TRUNC': {
			shape: 'middle-rect',
			color: 'black',
			legend_label: 'Truncating Mutation'
		},
		'FUSION':{
			shape: 'large-right-arrow',
			color: 'black',
			legend_label: 'Fusion'
		}
	};
	
	return {
		genetic_alteration_config: genetic_alteration_config,
		genetic_alteration_config_nondistinct_mutations: genetic_alteration_config_nondistinct_mutations,
		genetic_alteration_comparator: makeGeneticAlterationComparator(true),
		genetic_alteration_comparator_nondistinct_mutations: makeGeneticAlterationComparator(false)
	};
})();
;
window.oncoprint_RuleSet = (function() {
	var utils = oncoprint_utils;
	var defaults = oncoprint_defaults;

	var CATEGORICAL_COLOR = 'categorical_color';
	var GRADIENT_COLOR = 'gradient_color'; 
	var GENETIC_ALTERATION = 'genetic_alteration';
	var BAR_CHART = 'bar_chart';

	var CELL = "cell";
	var ANY = '*';

	var getRuleSetId = utils.makeIdCounter();

	var numericalNaNSort = function(d1, d2) {
		var f1 = parseFloat(d1[this.data_key], 10);
		var f2 = parseFloat(d2[this.data_key], 10);
		var f1_isNaN = isNaN(f1);
		var f2_isNaN = isNaN(f2);
		if (f1_isNaN && f2_isNaN) {
			return 0;
		} else if (!f1_isNaN && !f2_isNaN) {
			if (f1 < f2) {
				return -1;
			} else if (f1 > f2) {
				return 1;
			} else {
				return 0;
			}	
		} else if (f1_isNaN) {
			return Number.POSITIVE_INFINITY;
		} else {
			return Number.NEGATIVE_INFINITY;
		}
	};
	var makeNARuleParams = function(condition, label) {
		return {
				condition: condition,
				shape: utils.makeD3SVGElement('rect'),
				attrs: {fill: '#eeeeee', width: '100%', height:'100%'},
				legend_label: label,
				children: [{
					condition: condition,
					shape: utils.makeD3SVGElement('path'),
					attrs: {d: "m 0% 0% L 100% 100%"},
					styles: {'stroke-width':'1px', 'stroke':'#555555'},
					legend_label: label,
				}],
			};
	};
	var D3SVGRuleSet = (function() {
		function D3SVGRuleSet(params) {
			this.rule_map = {};
			this.rule_set_id = getRuleSetId();
			this.legend_label = params.legend_label;
			this.exclude_from_legend = false;
		};
		var getRuleId = utils.makeIdCounter();

		D3SVGRuleSet.prototype.getLegendLabel = function() {
			return this.legend_label;
		};
		D3SVGRuleSet.prototype.getRuleSetId = function() {
			return this.rule_set_id;
		};
		D3SVGRuleSet.prototype.addRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGRule(params, rule_id);
			return rule_id;
		}
		D3SVGRuleSet.prototype.addStaticRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGStaticRule(params, rule_id);
			return rule_id;
		};
		D3SVGRuleSet.prototype.addGradientRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGGradientRule(params, rule_id);
			return rule_id;
		};
		D3SVGRuleSet.prototype.addBarChartRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGBarChartRule(params, rule_id);
			return rule_id;
		};
		D3SVGRuleSet.prototype.removeRule = function(rule_id) {
			delete this.rule_map[rule_id];
		};
		D3SVGRuleSet.prototype.getRules = function() {
			var self = this;
			var rule_ids = Object.keys(this.rule_map);
			var rules = _.map(rule_ids, function(id) { return self.rule_map[id]; });
			var sorted_rules = _.sortBy(rules, function(r) { return r.z_index; });
			return sorted_rules;
		};
		D3SVGRuleSet.prototype.apply = function(g, cell_width, cell_height) {
			var active_rules = {};
			_.each(this.getRules(), function(rule) {
				var affected_groups = rule.filter(g);
				if (affected_groups[0].length > 0) {
					active_rules[rule.rule_id] = true;
				}
				rule.apply(affected_groups, cell_width, cell_height);
			});
			return active_rules;
		};
		D3SVGRuleSet.prototype.getRule = function(rule_id) {
			return this.rule_map[rule_id];
		};
		return D3SVGRuleSet;
	})();

	function D3SVGCategoricalColorRuleSet(params) {
		D3SVGRuleSet.call(this, params);
		this.type = CATEGORICAL_COLOR;
		var self = this;
		var d3_colors = ["#3366cc","#dc3912","#ff9900","#109618",
				"#990099","#0099c6","#dd4477","#66aa00",
				"#b82e2e","#316395","#994499","#22aa99",
				"#aaaa11","#6633cc","#e67300","#8b0707",
				"#651067","#329262","#5574a6","#3b3eac",
				"#b77322","#16d620","#b91383","#f4359e",
				"#9c5935","#a9c413","#2a778d","#668d1c",
				"#bea413","#0c5922","#743411"];/*_.shuffle(_.filter(d3.scale.category20().range().concat(d3.scale.category20b().range()).concat(d3.scale.category20c().range()),
									function(color) {
										var rgb = d3.rgb(color);
										return !(rgb.r === rgb.g && rgb.g === rgb.b);
									}));*/
		var addColorRule = function(color, category) {
			var colored_rect = utils.makeD3SVGElement('rect').attr('fill', color);
			var condition = (function(cat) {
				return function(d) {
					return params.getCategory(d) === cat;
				};
			})(category);
			self.addStaticRule({
				condition: condition,
				shape: colored_rect,
				legend_label: category
			});
		};
		params.color = params.color || {};
		_.each(params.color, function(color, category) {
			addColorRule(color, category);
		});
		self.addStaticRule(makeNARuleParams(function(d) {
			return params.getCategory(d) === 'NA';
		}, 'NA'));

		this.sort_cmp = params.sort_cmp || function(d1,d2) {
			var cat1 = params.getCategory(d1);
			var cat2 = params.getCategory(d2);
			if (typeof cat1 !== 'string') {
				cat1 = cat1.toString();
			}
			if (typeof cat2 !== 'string') {
				cat2 = cat2.toString();
			}
			if (cat1 === cat2) {
				return 0;
			} else if (cat1 === 'NA') {
				return Number.POSITIVE_INFINITY;
			} else if (cat2 === 'NA') {
				return Number.NEGATIVE_INFINITY;
			} else {
				return cat1.localeCompare(cat2);
			}
		};
		self.apply = function(g, cell_width, cell_height) {
			g.each(function(d,i) {
				var category = params.getCategory(d);
				if (!params.color.hasOwnProperty(category) && category !== "NA") {
					var new_color = d3_colors.pop();
					params.color[category] = new_color;
					addColorRule(new_color, category);
				}
			});
			return D3SVGRuleSet.prototype.apply.call(this, g, cell_width, cell_height);
		};

		self.getLegendDiv = function(active_rules, cell_width, cell_height) {
			var div = d3.select(document.createElement('div'));
			_.each(self.getRules(), function(rule) {
				if (active_rules[rule.rule_id]) {
					var legend_div = rule.getLegendDiv(cell_width, cell_height);
					if (legend_div) {
						div.node().appendChild(legend_div);
					}
				}
			});
			utils.d3SelectChildren(div, '*').style('padding-right', '20px');
			return div.node();
		};
	}
	D3SVGCategoricalColorRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	function D3SVGGradientColorRuleSet(params) {
		D3SVGRuleSet.call(this, params);
		this.type = GRADIENT_COLOR;
		this.data_key = params.data_key;
		var rule = this.addGradientRule({
			shape: utils.makeD3SVGElement('rect'),
			data_key: params.data_key,
			data_range: params.data_range,
			color_range: params.color_range,
			scale: params.scale,
			na_color: params.na_color
		});
		this.addStaticRule(makeNARuleParams(function(d) {
			return isNaN(d[params.data_key]);
		}, 'NA'));
		this.sort_cmp = params.sort_cmp || $.proxy(numericalNaNSort, this);
		this.getLegendDiv = function(active_rules, cell_width, cell_height) {
			return (active_rules[rule] && this.rule_map[rule].getLegendDiv(cell_width, cell_height)) || $('<div>')[0];
		};
	}
	D3SVGGradientColorRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	function D3SVGBarChartRuleSet(params) {
		D3SVGRuleSet.call(this, params);
		var self = this;
		self.type = BAR_CHART;
		self.data_key = params.data_key;
		var rule = this.addBarChartRule({
			data_key: params.data_key,
			data_range: params.data_range,
			scale: params.scale,
			fill: params.fill,
			na_color: params.na_color
		});
		this.addStaticRule(makeNARuleParams(function(d) {
			return isNaN(d[params.data_key]);
		}, 'NA'));
		this.sort_cmp = params.sort_cmp || $.proxy(numericalNaNSort, this);
		this.getLegendDiv = function(active_rules, cell_width, cell_height) {
			return (active_rules[rule] && this.rule_map[rule].getLegendDiv(cell_width, cell_height)) || $('<div>')[0];
		};
	}
	D3SVGBarChartRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	function D3SVGGeneticAlterationRuleSet(params) {
		if (params && params.dont_distinguish_mutation_color) {
			params = $.extend({}, params, defaults.genetic_alteration_config_nondistinct_mutations);
		} else {
			params = $.extend({}, params, defaults.genetic_alteration_config);
		}
		if (params && params.distinguish_mutation_order) {
			this.sort_cmp = defaults.genetic_alteration_comparator;
		} else {
			this.sort_cmp = defaults.genetic_alteration_comparator_nondistinct_mutations;
		}
		D3SVGRuleSet.call(this, params);
		var vocab = ['full-rect', 'middle-rect', 'large-right-arrow', 'small-up-arrow', 'small-down-arrow'];
		var self = this;
		self.type = GENETIC_ALTERATION;

		var makeStaticShapeRule = function(rule_spec, key, value) {
			var condition = typeof key !== 'undefined' && typeof value !== 'undefined' ? (function(_key, _value) {
				if (_value === ANY) {
					return function(d) {
						return typeof d[_key] !== 'undefined';
					}
				} else {
					return function(d) {
						return d[_key] === _value;
					};
				}
			})(key, value) : undefined;
			var shape, attrs, styles, z_index;
			switch (rule_spec.shape) {
				case 'full-rect':
					shape = utils.makeD3SVGElement('rect');
					attrs = {fill: rule_spec.color, width: '100%', height: '100%'};
					styles = {};
					z_index = utils.ifndef(rule_spec.z_index, 0);
					break;
				case 'middle-rect':
					shape = utils.makeD3SVGElement('rect');
					attrs = {fill: rule_spec.color, width: '100%', height: '33.33%', y: '33.33%'};
					styles = {};
					z_index = utils.ifndef(rule_spec.z_index, 1);
					break;
				case 'large-right-arrow':
					shape = utils.makeD3SVGElement('polygon');
					attrs = {points: "0%,0% 100%,50% 0%,100%"};
					styles = {'stroke-width':'0px', 'fill': rule_spec.color};
					z_index = utils.ifndef(rule_spec.z_index, 2);
					break;
				case 'small-up-arrow':
					shape = utils.makeD3SVGElement('polygon');
					attrs = {points: "50%,0% 100%,25% 0%,25%"};
					styles = {'stroke-width':'0px', 'fill': rule_spec.color};
					z_index = utils.ifndef(rule_spec.z_index, 3);
					break;
				case 'small-down-arrow':
					shape = utils.makeD3SVGElement('polygon');
					attrs = {points: "50%,100% 100%,75% 0%,75%"};
					styles = {'stroke-width':'0px', 'fill': rule_spec.color};
					z_index = utils.ifndef(rule_spec.z_index, 4);
					break;
				case 'outline':
					shape = CELL;
					styles = {'outline-color':rule_spec.color, 'outline-style':'solid', 'outline-width':'2px'};
					z_index = utils.ifndef(rule_spec.z_index, 5);
					break;
			}
			var new_rule = self.addStaticRule({
				condition: condition,
				shape: shape,
				attrs: attrs,
				styles: styles,
				z_index: z_index,
				legend_label: rule_spec.legend_label,
				exclude_from_legend: (typeof rule_spec.legend_label === "undefined")
			});
			return new_rule;
		};
		var altered_rules = [];
		_.each(params.altered, function(values, key) {
			_.each(values, function(rule_spec, value) {
				altered_rules.push(makeStaticShapeRule(rule_spec, key, value));
			});
		});
		_.each(params.default, function(rule_spec) {
			makeStaticShapeRule(rule_spec);
		});
		self.getLegendDiv = function(active_rules, cell_width, cell_height) {
			var div = d3.select(document.createElement('div'));
			_.each(self.getRules(), function(rule) {
				if (active_rules[rule.rule_id]) {
					var legend_div = rule.getLegendDiv(cell_width, cell_height);
					if (legend_div) {
						div.node().appendChild(legend_div);
					}
				}
			});
			utils.d3SelectChildren(div, '*').style('padding-right', '20px');
			return div.node();
		};
		self.alteredData = function(data) {
			var altered_data = [];
			_.each(altered_rules, function(rule_id) {
				altered_data = altered_data.concat(self.getRule(rule_id).filterData(data));
			});
			return _.uniq(altered_data);
		};
	}
	D3SVGGeneticAlterationRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	var D3SVGRule = (function() {
		function D3SVGRule(params, rule_id) {
			this.rule_id = rule_id;
			this.condition = params.condition || function(d) { return true; };
			this.shape = typeof params.shape === 'undefined' ? utils.makeD3SVGElement('rect') : params.shape;
			this.z_index = typeof params.z_index === 'undefined' ? this.rule_id : params.z_index;
			this.legend_label = params.legend_label;
			this.exclude_from_legend = params.exclude_from_legend;

			this.attrs = params.attrs || {};
			this.attrs.width = utils.ifndef(this.attrs.width, '100%');
			this.attrs.height = utils.ifndef(this.attrs.height, '100%');
			this.attrs.x = utils.ifndef(this.attrs.x, 0);
			this.attrs.y = utils.ifndef(this.attrs.y, 0);

			this.styles = params.styles || {};

			this.children = _.map(params.children, function(p) {
				return new D3SVGRule(p);
			});
		}

		var percentToPx = function(attr_val, attr_name, cell_width, cell_height) {
			// convert a percentage to a local pixel coordinate
			var width_like = ['width', 'x'];
			var height_like = ['height', 'y'];
			attr_val = parseFloat(attr_val, 10)/100;
			if (width_like.indexOf(attr_name) > -1) {
				attr_val = attr_val*cell_width;
			} else if (height_like.indexOf(attr_name) > -1) {
				attr_val = attr_val*cell_height;
			} 
			return attr_val+'';
		};

		var convertAttr = function(d, i, attr_val, attr_name, cell_width, cell_height) {
			var ret = attr_val;
			if (typeof ret === 'function') {
				ret = ret(d,i);
			}
			if (typeof ret === 'string' && ret.indexOf('%') > -1) {
				if (attr_name === 'points') {
					ret = _.map(ret.split(" "), function(pt) {
						var split_pt = pt.split(",");
						var pt_x = percentToPx(split_pt[0], 'x', cell_width, cell_height);
						var pt_y = percentToPx(split_pt[1], 'y', cell_width, cell_height);
						return pt_x+","+pt_y;
					}).join(" ");
				} else if (attr_name === 'd') {
					var split = ret.split(/\s+/);
					for (var i=0, _len = split.length; i<_len; i++) {
						var c = split[i].toLowerCase();
						if (c === 'm' || c === 'l') {
							split[i+1] = percentToPx(split[i+1], 'x', cell_width, cell_height);
							split[i+2] = percentToPx(split[i+2], 'y', cell_width, cell_height);
							i += 2;
						}
					}
					return split.join(" ");
				} else {
					ret = percentToPx(ret, attr_name, cell_width, cell_height);
				}
			}
			return ret;
		};

		D3SVGRule.prototype.apply = function(g, cell_width, cell_height) {
			var shape = this.shape;
			var elts = shape === CELL ? g : utils.appendD3SVGElement(shape, g);
			var styles = this.styles;
			var attrs = this.attrs;
			attrs.x = attrs.x || 0;
			attrs.y = attrs.y || 0;
			_.each(attrs, function(val, key) {
				elts.attr(key, function(d,i) {
					return convertAttr(d, i, val, key, cell_width, cell_height);
				});
			});
			_.each(styles, function(val, key) {
				elts.style(key, val);
			});
			_.each(this.children, function(r) {
				r.apply(g, cell_width, cell_height);
			});
		}
		D3SVGRule.prototype.filter = function(g) {
			return g.filter(this.condition);
		};
		D3SVGRule.prototype.filterData = function(data) {
			return data.filter(this.condition);
		};
		D3SVGRule.prototype.showInLegend = function() {
			return !this.exclude_from_legend;
		};
		return D3SVGRule;
	})();
	

	function D3SVGBarChartRule(params, rule_id) {
		D3SVGRule.call(this, params, rule_id);
		this.data_key = params.data_key;
		this.data_range = params.data_range;
		this.inferred_data_range;
		this.attrs.fill = function(d) {
			if (isNaN(d[params.data_key])) {
				return params.na_color;
			}  else {
				return params.fill;
			}
		};
		this.na_color = params.na_color;

		var scale = function(x) {
			if (params.scale === 'log') {
				return Math.log10(Math.max(Math.abs(x), 0.1)); 
			} else {
				return x;
			}
		};
		var makeDatum = function(x) {
			var ret = {};
			ret[params.data_key] = x;
			return ret;
		};

		this.setUpHelperFunctions = function(data_range) {
			var scaled_data_range = _.map(data_range, scale);
			var height_helper = function(d) {
				var datum = scale(d[params.data_key]);
				var distance = Math.abs(datum-scaled_data_range[0]) / Math.abs(scaled_data_range[1]-scaled_data_range[0]);
				return distance * 100;
			};
			var y_function = function(d) {
				return (isNaN(d[params.data_key]) ? "0" : (100 - height_helper(d))) + '%';
			};
			var height_function = function(d) { 
				return (isNaN(d[params.data_key]) ? "100" : height_helper(d)) + '%';
			};
			this.attrs.height = height_function;
			this.attrs.y = y_function;
		};

		this.inferDataRange = function(g) {
			var self = this;
			var min = Number.POSITIVE_INFINITY;
			var max = Number.NEGATIVE_INFINITY;
			g.each(function(d,i) {
				var datum = d[self.data_key];
				var datumIsNaN = isNaN(datum);
				min = Math.min(min, datumIsNaN ? Number.POSITIVE_INFINITY : datum);
				max = Math.max(max, datumIsNaN ? Number.NEGATIVE_INFINITY : datum);
			});
			return [min, max];
		};

		this.getEffectiveDataRange = function() {
			if (typeof this.data_range === "undefined") {
				return this.inferred_data_range;
			} else {
				var ret = [];
				ret[0] = (typeof this.data_range[0] === 'undefined' ? this.inferred_data_range[0] : this.data_range[0]);
				ret[1] = (typeof this.data_range[1] === 'undefined' ? this.inferred_data_range[1] : this.data_range[1]);
				return ret;
			}
		};
		this.getLegendDiv = function(cell_width, cell_height) {
			if (!this.showInLegend()) {
				return;
			}
			var div = d3.select(document.createElement('div'));
			var data_range = this.getEffectiveDataRange();
			if (!data_range) {
				return div.node();
			}
			var display_data_range = _.map(data_range, function(x) { 
				var num_digit_multiplier = Math.pow(10, utils.ifndef(params.legend_num_decimal_digits,2));
				return Math.round(x * num_digit_multiplier) / num_digit_multiplier;
			});
			div.append('span').text(display_data_range[0]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', '0px');
			var mesh = 50;
			var svg = div.append('svg').attr('width', mesh+'px').attr('height', cell_height+'px').classed('oncoprint-legend-element', true)
			for (var i=0; i<=mesh; i++) {
				var t = i/mesh;
				var d = (1-t)*data_range[0] + t*data_range[1];
				var datum = makeDatum(d);
				var height = cell_height*parseInt(this.attrs.height(datum))/100;
				svg.append('rect')
					.attr('width', '1px')
					.attr('height', height+'px')
					.attr('y', (cell_height-height)+'px')
					.attr('fill', params.fill)
					.attr('x', i+'px');
			}
			div.append('span').text(display_data_range[1]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', cell_height - 3 + 'px');
			utils.d3SelectChildren(div, '*').style('padding-right', '10px');
			return div.node();
		};
		this.apply = function(g, cell_width, cell_height) {
			if (g[0].length === 0) {
				return;
			}
			this.inferred_data_range = this.inferDataRange(g);
			this.setUpHelperFunctions(this.getEffectiveDataRange());
			D3SVGRule.prototype.apply.call(this, g, cell_width, cell_height);
		};

	}
	D3SVGBarChartRule.prototype = Object.create(D3SVGRule.prototype);

	function D3SVGGradientRule(params, rule_id) {
		D3SVGRule.call(this, params, rule_id);
		this.data_key = params.data_key;
		this.data_range = params.data_range;
		this.inferred_data_range;
		this.color_range = params.color_range;
		this.na_color = params.na_color;

		var makeDatum = function(x) {
			var ret = {};
			ret[params.data_key] = x;
			return ret;
		};
		var scale = function(x) {
			if (params.scale === 'log') {
				return Math.log10(Math.max(x, 0.1)); 
			} else {
				return x;
			}
		};

		this.setUpHelperFunctions = function(data_range) {
			var scaled_data_range = _.map(data_range, scale);
			var fill_function = function(d) {
				if (isNaN(d[params.data_key])) {
					return params.na_color;
				}
 				var datum = scale(d[params.data_key]);
				var data_range = [scaled_data_range[0], scaled_data_range[1]];
				var distance = (datum-scaled_data_range[0]) / (scaled_data_range[1]-scaled_data_range[0]);
				color_range = [d3.rgb(params.color_range[0]).toString(),
						d3.rgb(params.color_range[1]).toString()];
				return utils.lin_interp(distance, params.color_range[0], params.color_range[1]);
			};
			this.attrs.fill = fill_function;
		};

		this.inferDataRange = function(g) {
			var self = this;
			var min = Number.POSITIVE_INFINITY;
			var max = Number.NEGATIVE_INFINITY;
			g.each(function(d,i) {
				var datum = d[self.data_key];
				var datumIsNaN = isNaN(datum);
				min = Math.min(min, datumIsNaN ? Number.POSITIVE_INFINITY : datum);
				max = Math.max(max, datumIsNaN ? Number.NEGATIVE_INFINITY : datum);
			});
			return [min, max];
		};

		this.getLegendDiv = function(cell_width, cell_height) {
			if (!this.showInLegend()) {
				return;
			}
			var div = d3.select(document.createElement('div'));
			var data_range = this.data_range || this.inferred_data_range;
			if (!data_range) {
				return div.node();
			}
			var display_data_range = _.map(data_range, function(x) { 
				var num_digit_multiplier = Math.pow(10, utils.ifndef(params.legend_num_decimal_digits,2));
				return Math.round(x * num_digit_multiplier) / num_digit_multiplier;
			});
			div.append('span').text(display_data_range[0]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', cell_height / 2 - 3 + 'px');
			var mesh = 50;
			var svg = div.append('svg').attr('width', mesh+'px').attr('height', cell_height+'px').classed('oncoprint-legend-element', true);
			for (var i=0; i<=mesh; i++) {
				var t = i/mesh;
				var d = (1-t)*data_range[0] + t*data_range[1];
				var datum = makeDatum(d);
				svg.append('rect')
					.attr('width', '1px')
					.attr('height', cell_height+'px')
					.attr('fill', this.attrs.fill(datum))
					.attr('x', i+'px');
			}
			div.append('span').text(display_data_range[1]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', cell_height / 2 - 3 + 'px');
			utils.d3SelectChildren(div, '*').style('padding-right', '10px');
			return div.node();
		};
		this.apply = function(g, cell_width, cell_height) {
			this.setUpHelperFunctions(this.data_range || (this.inferred_data_range = this.inferDataRange(g)));
			D3SVGRule.prototype.apply.call(this, g, cell_width, cell_height);
		};
	}
	D3SVGGradientRule.prototype = Object.create(D3SVGRule.prototype);

	function D3SVGStaticRule(params, rule_id) {
		D3SVGRule.call(this, params, rule_id);

		this.getLegendDiv = function(cell_width, cell_height) {
			if (!this.showInLegend()) {
				return;
			}
			var div = d3.select(document.createElement('div'));
			var svg_ctr = div.append('div').classed('oncoprint-legend-block', true);
			var svg = svg_ctr.append('svg').attr('width', cell_width+'px').attr('height', cell_height+'px').classed('oncoprint-legend-element', true);
			this.apply(svg, cell_width, cell_height);
			if (this.legend_label) {
				div.append('span').text(this.legend_label).classed('oncoprint-legend-label oncoprint-legend-element', true)
						.style('position', 'relative').style('bottom', cell_height / 2 - 3 + 'px');
			}
			utils.d3SelectChildren(div, '*').style('padding-right', '10px');
			return div.node();
		};
	}
	D3SVGStaticRule.prototype = Object.create(D3SVGRule.prototype);

	return {
		CATEGORICAL_COLOR: CATEGORICAL_COLOR,
		GRADIENT_COLOR: GRADIENT_COLOR,
		GENETIC_ALTERATION: GENETIC_ALTERATION,
		BAR_CHART: BAR_CHART,
		makeRuleSet: function(type, params) {
			if (type === CATEGORICAL_COLOR) {
				return new D3SVGCategoricalColorRuleSet(params);
			} else if (type === GRADIENT_COLOR) {
				return new D3SVGGradientColorRuleSet(params);
			} else if (type === GENETIC_ALTERATION) {
				return new D3SVGGeneticAlterationRuleSet(params);
			} else if (type === BAR_CHART) {
				return new D3SVGBarChartRuleSet(params);
			} else {
				return new D3SVGRuleSet();
			}
		}
	};
})();;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.OncoprintRenderer = (function() {
	var events = oncoprint_events;
	var utils = oncoprint_utils;
	var RuleSet = oncoprint_RuleSet;

	function OncoprintRenderer(oncoprint, config) {
		this.rule_sets = {};
		this.clipping = true;
		this.oncoprint = oncoprint;
		this.config = config;
		this.upper_padding = utils.ifndef(config.upper_padding, 0);
		this.max_label_length = utils.ifndef(config.max_label_length, 20);
		this.track_group_separation = 12;

		(function computeLabelAreaWidth(self) {
			var label_font = self.getLabelFont();
			var max_label_width = utils.textWidth((Math.pow(10,self.max_label_length)-1).toString(), label_font);
			var max_percent_altered_width = utils.textWidth('100%', label_font);
			var buffer_width = 20;
			self.label_area_width = max_label_width + buffer_width + max_percent_altered_width;
		})(this);
	};
	OncoprintRenderer.prototype.getCellCSSClass = function() {
		return 'oncoprint-cell';	
	};
	OncoprintRenderer.prototype.getTrackCellCSSClass = function(track_id) {
		return this.getCellCSSClass()+track_id;
	};
	OncoprintRenderer.prototype.getTrackLabelCSSClass = function(track_id) {
		return 'oncoprint-track-label oncoprint-track-label'+track_id;
	};
	OncoprintRenderer.prototype.getTrackLabelCSSSelector = function(track_id) {
		// TODO: replace with utils.cssClassToSelector
		return "."+this.getTrackLabelCSSClass(track_id).split(" ").join(".");
	};
	OncoprintRenderer.prototype.getTrackCellCtrCSSClass = function(track_id) {
		return 'oncoprint-track-cell-ctr'+track_id;
	};
	OncoprintRenderer.prototype.getLabelFont = function() {
		return this.config.label_font;
	};
	OncoprintRenderer.prototype.setRuleSet = function(track_id, type, params) {
		var new_rule_set = RuleSet.makeRuleSet(type, params);
		this.rule_sets[track_id] = new_rule_set;
		if (new_rule_set.sort_cmp) {
			this.oncoprint.setTrackSortComparator(track_id, new_rule_set.sort_cmp);
		}
	};
	OncoprintRenderer.prototype.useSameRuleSet = function(target_track_id, source_track_id) {
		var rule_set = this.rule_sets[source_track_id];
		this.rule_sets[target_track_id] = rule_set;
		if (rule_set.sort_cmp) {
			this.oncoprint.setTrackSortComparator(target_track_id, rule_set.sort_cmp);
		}
	};
	OncoprintRenderer.prototype.getRuleSet = function(track_id) {
		return this.rule_sets[track_id];
	};
	OncoprintRenderer.prototype.getTrackTops = function() {
		var ret = {};
		var y = this.upper_padding;
		var self = this;
		_.each(this.oncoprint.getTrackGroups(), function(group) {
			if (group.length === 0) {
				return;
			}
			_.each(group, function(id) {
				ret[id] = y;
				y+= self.getRenderedTrackHeight(id);
			});
			y += self.track_group_separation;
		});
		return ret;
	};
	OncoprintRenderer.prototype.getTrackCellTops = function() {
		return this.track_cell_tops || this.computeTrackCellTops();
	};
	OncoprintRenderer.prototype.computeTrackCellTops = function() {
		var tops = this.getTrackTops();
		var self = this;
		_.each(tops, function(top, id) {
			tops[id] = top + self.oncoprint.getTrackPadding(id);
		});
		this.track_cell_tops = tops;
		return tops;
	};
	OncoprintRenderer.prototype.getTrackLabelTops = function() {
		return this.getTrackCellTops();
	};
	OncoprintRenderer.prototype.getRenderedTrackHeight = function(track_id) {
		return this.oncoprint.getTrackHeight(track_id) + 2*this.oncoprint.getTrackPadding(track_id);
	};
	OncoprintRenderer.prototype.getCellX = function(index) {
		return (typeof index === 'number' ? index*(this.oncoprint.getZoomedCellWidth()+this.oncoprint.getCellPadding()) : -1);
	};
	OncoprintRenderer.prototype.getCellXArray = function(length) {
		var cell_unit = this.oncoprint.getZoomedCellWidth() + this.oncoprint.getCellPadding();
		return _.map(_.range(0,length), function(x) { return x*cell_unit; });
	};
	OncoprintRenderer.prototype.getCellAreaWidth = function() {
		return this.oncoprint.getVisibleIdOrder().length*(this.oncoprint.getZoomedCellWidth() + this.oncoprint.getCellPadding());
	};
	OncoprintRenderer.prototype.getCellAreaHeight = function() {
		var track_tops = this.getTrackTops();
		var track_order = this.oncoprint.getTracks();
		if (track_order.length === 0) {
			return 0;
		} else {
			var last_track = track_order[track_order.length-1];
			return track_tops[last_track] + this.getRenderedTrackHeight(last_track);
		}
	};
	OncoprintRenderer.prototype.getLabelAreaWidth = function() {
		return this.label_area_width;
	};
	OncoprintRenderer.prototype.getLabelAreaHeight = function() {
		return this.getCellAreaHeight();
	};
	OncoprintRenderer.prototype.render = function() {
		throw "not implemented in abstract class";
	}
	return OncoprintRenderer;
})();;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 window.OncoprintSVGRenderer = (function() {
	var events = oncoprint_events;
	var utils = oncoprint_utils;

	var TOOLBAR_CONTAINER_CLASS = 'oncoprint-toolbar-ctr';
	var LABEL_AREA_CONTAINER_CLASS = 'oncoprint-label-area-ctr';
	var CELL_AREA_CONTAINER_CLASS = 'oncoprint-cell-area-ctr';
	var CELL_AREA_CLASS = 'oncoprint-cell-area';
	var COLUMN_HIGHLIGHT_CLASS = 'oncoprint-column-highlight'
	
	var CELL_HOVER_CLASS = 'oncoprint-cell-hover';
	var LEGEND_HEADER_CLASS = 'oncoprint-legend-header';
	var LABEL_DRAGGING_CLASS = 'oncoprint-label-dragging';
	var LABEL_DRAGGABLE_CLASS = 'oncoprint-label-draggable';
	var CELL_QTIP_CLASS = 'oncoprint-cell-qtip';

	function OncoprintSVGRenderer(container_selector_string, oncoprint, config) {
		OncoprintRenderer.call(this, oncoprint, config);
		var self = this;
		this.track_cell_selections = {};
		this.track_cells = {};
		this.active_rule_set_rules = {};
		this.toolbar_container;
		this.label_div;
		this.label_drag_div;
		this.label_container;
		this.cell_container;
		this.cell_container_node;
		this.cell_div;
		this.legend_table;
		this.document_fragment;
		this.percent_altered_max_width = utils.textWidth('100%', self.getLabelFont());
		this.altered_data_percentage = {};
		
		this.cell_tooltip_html = '';

		this.container = d3.select(container_selector_string);
		this.container.classed('noselect', true).selectAll('*').remove();
		this.container.append('br');
		(function initLegend() {
			if (config.legend) {
				self.legend_table = d3.select(container_selector_string).append('table').style('border-collapse', 'collapse');
			}
		})();
		var content_area = d3.select(container_selector_string).append('div').classed('oncoprint-content-area', true);
		(function initLabelContainer() {
			self.label_container = content_area.append('div').classed(LABEL_AREA_CONTAINER_CLASS, true).style('position', 'relative');
			self.label_div = self.label_container.append('div').style('position', 'relative').style('overflow', 'hidden');
			self.label_drag_div = self.label_container.append('div').style('position', 'absolute').style('overflow', 'hidden')
							.style('top', '0px').style('left','0px')
							.style('display','none');
		})();
		(function initCellContainer() {
			self.cell_container = content_area.append('div').classed(CELL_AREA_CONTAINER_CLASS, true);
			self.cell_column_highlight = self.cell_container.append('div').classed(COLUMN_HIGHLIGHT_CLASS, true)
						.style('height', self.getCellAreaHeight())
						.style('visibility', 'hidden');

			self.cell_container_node = self.cell_container.node();
			self.cell_div = self.cell_container.append('div').classed(CELL_AREA_CLASS, true);

		
			self.cell_mouseover_div = self.cell_container.append('div').style('position', 'absolute').style('overflow', 'hidden')
							.style('top', '0px').style('left','0px');
			self.cell_container_node.addEventListener("scroll", function() {
				self.calculateVisibleInterval();
				self.clipAndPositionCells();
			});
			var mouseMove, mouseOut;
			(function() {
				var prev_track, prev_cell_index, prev_dom, highlighted_col_cells = [];
				var column_highlight_timeout;
				$(self.cell_div.node()).qtip({
					content: 'SHARED QTIP',
					position: {target: 'event', my:'bottom middle', at:'top middle', viewport: $(window)},
					style: { classes: CELL_QTIP_CLASS, border: 'none'},
					show: {event: "cell-mouseover"},
					hide: {fixed: true, delay: 100, event: "cell-mouseout"},
					events: {
						show: function() {
							$(this).find('.qtip-content').html(self.cell_tooltip_html);
						},
						render: function(){
							$(this).find('.qtip-content').html(self.cell_tooltip_html);
						}
					}
				});
				var hover_cell = function(dom) {
					$('.'+CELL_QTIP_CLASS).finish();
					$(dom).trigger("cell-mouseover");
				};
				var unhover_cell = function(dom) {
					$('.'+CELL_QTIP_CLASS).finish();
					$(dom).trigger("cell-mouseout");
				};
				var clear_and_unhover = function() {
					prev_track = undefined;
					prev_cell_index = undefined;
					prev_dom && unhover_cell(prev_dom);
					prev_dom = undefined;
					//self.cell_column_highlight.style('visibility', 'hidden');
					column_highlight_timeout && clearTimeout(column_highlight_timeout)
					_.each(highlighted_col_cells, function(cell) {
						if (cell) {
							cell.style.border = '';
							cell.style.margin = '';
						}
					});
					highlighted_col_cells = [];
				};
				mouseOut = function() {
					clear_and_unhover();
				};
				mouseMove = function(evt) {
					var mouseX = utils.mouseX(evt);
					var mouseY = utils.mouseY(evt);
					var track_cell_tops = self.getTrackCellTops();
					var track = (function() {
						var closest_track_dist = Number.POSITIVE_INFINITY;
						var closest_track = undefined;
						_.each(track_cell_tops, function(top, track_id) {
							var dist = mouseY - top;
							if (dist >= 0 && dist < closest_track_dist) {
								closest_track_dist = dist;
								closest_track = track_id;
							}
						});
						return closest_track;
					})();
					if (!track) {
						clear_and_unhover();
						return;
					}
					var track_height = oncoprint.getCellHeight(track);
					if (mouseY > track_cell_tops[track] + track_height) {
						clear_and_unhover();
						return;
					}
					var cell_width = oncoprint.getZoomedCellWidth();
					var cell_unit = cell_width + oncoprint.getCellPadding();
					if (mouseX % cell_unit > cell_width) {
						clear_and_unhover();
						return;
					}
					// at this point, we are hovered over a cell position
					var cell_index = Math.floor(mouseX / cell_unit);
					if (cell_index !== prev_cell_index || track !== prev_track) {
						//self.cell_column_highlight.style('visibility', 'hidden');
						column_highlight_timeout && clearTimeout(column_highlight_timeout)
						// not the same cell as before
						clear_and_unhover();
						var cell_id = oncoprint.getVisibleIdOrder()[cell_index];
						var track_cell = self.track_cells[track][cell_id];
						if (!track_cell) {
							// track doesn't have a cell there
							return;
						}
						// otherwise, we're over a cell
						$('.'+CELL_QTIP_CLASS).finish().hide();
						prev_cell_index = cell_index;
						prev_track = track;
						prev_dom = track_cell.dom;
						self.cell_tooltip_html = oncoprint.getTrackTooltip(track)(track_cell.d);
						hover_cell(prev_dom);
						column_highlight_timeout = setTimeout(function() {
							highlighted_col_cells = _.map(self.track_cells, function(cells, track_id) {
								var cell = cells[cell_id].dom;
								if (cell) {
									if (track_id === track) {
										cell.style.border = "1px solid #000000";
										cell.style.margin = "-1px";
									} else {
										cell.style.border = "1px solid #999999";
										cell.style.margin = "-1px";
									}
								}
								return cell;
							});
						}, 200);
					}
				};
			})();
			self.cell_mouseover_div.node().addEventListener('mousemove', mouseMove);
			self.cell_mouseover_div.node().addEventListener('mouseout', mouseOut);
			// TODO: magic number
			self.cell_div.style('max-width', '1000px');
		})();
		$(content_area.node()).hover(function() {
			$(self.label_div.node()).find('.'+self.getTrackButtonCSSClass()).stop().fadeTo(80,1);
		}, function() {
			$(self.label_div.node()).find('.'+self.getTrackButtonCSSClass()).stop().fadeOut(500);
		});
		
		(function reactToOncoprint() {
			$(oncoprint).on(events.REMOVE_TRACK, function(evt, data) {
				var track_id = data.track_id;
				delete self.rule_sets[track_id];
				delete self.track_cell_selections[track_id];
				delete self.altered_data_percentage[track_id];
				self.removeTrackCells(track_id);
				self.removeTrackLabels(track_id);
				self.removeTrackButtons(track_id);
				
				self.computeTrackCellTops();
				self.renderLegend();
				self.renderTrackLabels();
				self.renderTrackButtons();
				self.resizeLabelDiv();
				self.resizeCellDiv();
				oncoprint.sort();
			});
			$(oncoprint).on(events.MOVE_TRACK, function(evt, data) {
				self.computeTrackCellTops();
				self.clipAndPositionCells(data.moved_tracks, 'top', true);
				self.renderTrackLabels();
				self.renderTrackButtons();
				oncoprint.sort();
			});

			$(oncoprint).on(events.ADD_TRACK, function(e,d) {
				//this.cell_div.style('display', 'none');
				self.drawCells(d.track_id);
				self.clipAndPositionCells(undefined, 'top', true);
				self.computeTrackCellTops();
				self.renderTrackLabels();
				self.renderTrackButtons();
				self.resizeLabelDiv();
				//self.clipCells(true, d.track_id);
				//this.cell_div.style('display','inherit');
			});

			$(oncoprint).on(events.SET_TRACK_DATA, function(e,d) {
				//this.cell_div.style('display', 'none');
				self.drawCells(d.track_id);
				self.clipAndPositionCells(d.track_id, undefined, true);
				self.computeAlteredDataPercentage(d.track_id);
				self.renderTrackLabels(d.track_id);
				self.resizeCellDiv();
				self.renderLegend();
				//self.clipCells(true);
				//this.cell_div.style('display','inherit');
			});


			$(oncoprint).on(events.SET_CELL_PADDING, function(e,d) {
				self.clipAndPositionCells(undefined, undefined, true);
				self.resizeCellDiv();
			});

			$(oncoprint).on(events.SET_ZOOM, function(e,d) {
				self.clipAndPositionCells(undefined, undefined, true);
				self.resizeCells();
				self.resizeCellDiv();
				//self.cell_highlight.style('width', oncoprint.getZoomedCellWidth() + 'px');
			});

			$(oncoprint).on(events.SET_VISIBLE_ID_ORDER, function() {
				self.clipAndPositionCells(undefined, undefined, true);
				self.resizeCellDiv();
			});
		})();
	}
	utils.extends(OncoprintSVGRenderer, OncoprintRenderer);
	OncoprintSVGRenderer.prototype.computeAlteredDataPercentage = function(track_id) {
		var rule_set = this.getRuleSet(track_id);
		if (rule_set && rule_set.alteredData) {
			var data = this.oncoprint.getTrackData(track_id);
			var num_altered = rule_set.alteredData(data).length;
			var percent_altered = Math.floor(100 * num_altered / data.length);
			this.altered_data_percentage[track_id] = percent_altered;
		}
	};
	OncoprintSVGRenderer.prototype.getAlteredDataPercentage = function(track_id) {
		return this.altered_data_percentage[track_id];
	};
	OncoprintSVGRenderer.prototype.calculateVisibleInterval = function() {
		var cell_unit = this.oncoprint.getZoomedCellWidth() + this.oncoprint.getCellPadding();
		var cell_ctr_rect = this.cell_container_node.getBoundingClientRect();
		this.visible_interval = [this.cell_container_node.scrollLeft, this.cell_container_node.scrollLeft + cell_ctr_rect.right - cell_ctr_rect.left];
		return this.visible_interval;
	};
	OncoprintSVGRenderer.prototype.getVisibleInterval = function() {
		return (this.visible_interval || this.calculateVisibleInterval());
	};
	OncoprintSVGRenderer.prototype.cellRenderTarget = function() {
		return d3.select(this.document_fragment || this.cell_div.node());
	};
	OncoprintSVGRenderer.prototype.suppressRendering = function() {
		this.document_fragment = document.createDocumentFragment();
	};
	OncoprintSVGRenderer.prototype.releaseRendering = function() {
		this.cell_div.node().appendChild(this.document_fragment);
		this.document_fragment = undefined;
		var self = this;
		$(this.cell_div.node()).ready(function() {
			self.resizeCells();
			self.clipAndPositionCells(undefined, undefined, true);
		});
	};
	// Rule sets
	OncoprintSVGRenderer.prototype.setRuleSet = function(track_id, type, params) {
		OncoprintRenderer.prototype.setRuleSet.call(this, track_id, type, params);
		this.active_rule_set_rules[this.getRuleSet(track_id).getRuleSetId()] = {};
		this.drawCells(track_id);
		this.clipAndPositionCells(track_id, undefined, true);
		this.renderLegend();
		this.computeAlteredDataPercentage(track_id);
		this.renderTrackLabels(track_id);
	};
	OncoprintSVGRenderer.prototype.useSameRuleSet = function(target_track_id, source_track_id) {
		OncoprintRenderer.prototype.useSameRuleSet.call(this, target_track_id, source_track_id);
		this.drawCells(target_track_id);
		this.clipAndPositionCells(target_track_id, undefined, true);
		this.renderLegend();
		this.computeAlteredDataPercentage(target_track_id);
		this.renderTrackLabels(target_track_id);
	}

	// Containers
	OncoprintSVGRenderer.prototype.getLabelDiv = function() {
		return this.label_div;
	};
	OncoprintSVGRenderer.prototype.getLabelDragDiv = function() {
		return this.label_drag_div;
	};
	OncoprintSVGRenderer.prototype.resizeCellDiv = function() {
		this.cell_div.style('min-width', this.getCellAreaWidth()+'px')
				.style('min-height', this.getCellAreaHeight()+'px');
		
		this.cell_mouseover_div.style('min-width', this.getCellAreaWidth()+'px')
				.style('min-height', this.getCellAreaHeight()+'px');
		this.cell_column_highlight.style('height', this.getCellAreaHeight() + 'px');
	};
	OncoprintSVGRenderer.prototype.resizeLabelDiv = function() {
		this.getLabelDiv().style('width', this.getLabelAreaWidth()+'px')
				.style('height', this.getLabelAreaHeight()+'px');
		this.getLabelDragDiv().style('width', this.getLabelAreaWidth()+'px')
				.style('height', this.getLabelAreaHeight()+'px');
	};

	// Labels
	OncoprintSVGRenderer.prototype.removeTrackLabels =function(track_ids) {
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);	
		var div = this.label_div;
		var self = this;
		_.each(track_ids, function(track_id) {
			div.selectAll(self.getTrackLabelCSSSelector(track_id)).remove();
		});
	}
	OncoprintSVGRenderer.prototype.renderTrackLabels = function(track_ids, y, render_whole_labels) {
		var div = this.label_div;
		if (typeof y !== "undefined") {
			div.selectAll(this.getTrackLabelCSSSelector(track_ids)).style('top', y+'px');
		} else {
			track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
			track_ids = [].concat(track_ids);
			var label_tops = this.getTrackLabelTops();
			var self = this;
			var label_area_width = this.getLabelAreaWidth();
			var percent_altered_left = label_area_width - this.percent_altered_max_width;
			_.each(track_ids, function(track_id) {
				var label_top = label_tops[track_id];
				var track_label_class = self.getTrackLabelCSSClass(track_id);
				var label_text = self.oncoprint.getTrackLabel(track_id);
				var disp_label_text = label_text;
				if (label_text.length > self.max_label_length && !render_whole_labels) {
					disp_label_text = label_text.substring(0,self.max_label_length-3)+'...';
				}
				_.each(div.selectAll(self.getTrackLabelCSSSelector(track_id)), function(node) {
					$(node).qtip('destroy');
				});
				div.selectAll(self.getTrackLabelCSSSelector(track_id)).remove();
				var span = div.append('span')
					.style('position','absolute')
					.classed(self.getTrackLabelCSSClass(track_id), true)
					.classed('oncoprint-track-label-draggable', true)
					.classed('oncoprint-track-label-main', true)
					.classed('oncoprint-track-label', true)
					.classed('noselect', true)
					.style('font-family', self.getLabelFont())
					.style('font-weight', 'bold')
					.text(disp_label_text)
					.style('top', label_top+'px')
					.on("mousedown", function() {
						self.dragLabel(track_id);
					});
					$(span.node()).qtip( {content: {text: (label_text.length > self.max_label_length ? label_text+'<br> hold to drag' : 'hold to drag') },
									position: {my:'middle right', at:'middle left', viewport: $(window)},
									style: { classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow'},
									show: {event: "mouseover"}
								});
				var percent_altered = self.getAlteredDataPercentage(track_id);
				if (typeof percent_altered !== 'undefined') {
					div.append('span')
						.style('position','absolute')
						.classed(self.getTrackLabelCSSClass(track_id), true)
						.classed('oncoprint-track-label', true)
						.classed('noselect', true)
						.style('font-family', self.getLabelFont())
						.text(percent_altered + '%')
						.style('top', label_top+'px')
						.style('left', percent_altered_left+'px');	
				}
			});
		}
	};

	// Buttons
	OncoprintSVGRenderer.prototype.getTrackButtonCSSClass = function(track_id) {
		return 'oncoprint-track-button'+utils.ifndef(track_id, "");
	};
	OncoprintSVGRenderer.prototype.removeTrackButtons = function(track_ids) {
		var div = this.label_div;
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var self = this;
		_.each(track_ids, function(track_id) {
			div.selectAll('.'+self.getTrackButtonCSSClass(track_id)).remove();
		});
	};
	OncoprintSVGRenderer.prototype.renderTrackButtons = function(track_ids) {
		var div = this.label_div;
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var label_tops = this.getTrackLabelTops();
		var self = this;
		var label_area_width = this.getLabelAreaWidth();
		_.each(track_ids, function(track_id) {
			var button_class = self.getTrackButtonCSSClass(track_id);
			div.selectAll('.'+button_class).remove();
			var left = label_area_width - 15;
			if (self.oncoprint.isTrackRemovable(track_id)) {
				(function() {
					var new_btn = div.append('span').classed('noselect', true).style('font-size','12px').style('color', '#87CEFA').style('cursor', 'pointer')
					.classed(button_class, true).classed(self.getTrackButtonCSSClass(), true).on('click', function() {
						self.oncoprint.removeTrack(track_id);
					})
					.style('position', 'absolute').style('left', left+'px').style('top', label_tops[track_id]+'px');
					new_btn.text('X');
					$(new_btn.node()).hover(function() {
						new_btn.style('font-size', '15px').style('color', '#0000FF');
					}, function() {
						new_btn.style('font-size','12px').style('color', '#87CEFA');
					}).qtip({
				                    content: {text: 'Click to remove'},
				                    position: {my:'bottom middle', at:'top middle', viewport: $(window)},
				                    style: { classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow' },
				                    show: {event: "mouseover"},
				                    hide: {fixed: true, delay: 100, event: "mouseout"}
                    				});
				})();
				left -= 35;
			}
			if (self.oncoprint.isTrackSortDirectionChangable(track_id)) {
				(function() {
					var imgs = ['images/decreaseSort.svg', 'images/increaseSort.svg', 'images/nonSort.svg'];
					var descs = ['Click to sort in descending order', 'Click to not sort on this track', 'Click to sort in ascending order'];
					var sort_direction = [1, -1, 0];
					var current_sort_setting = sort_direction.indexOf(self.oncoprint.getTrackSortDirection(track_id));
					var new_btn = div.append('img');
					new_btn.attr('src', imgs[current_sort_setting]).style('cursor','pointer');
					$(new_btn.node()).qtip({
				                    content: {text: function() {
				                    	return descs[current_sort_setting];
				                    }},
				                    position: {my:'bottom middle', at:'top middle', viewport: $(window)},
				                    style: { classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow' },
				                    show: {event: "mouseover"},
				                    hide: {fixed: true, delay: 100, event: "mouseout"}
                    				});
					new_btn.classed(button_class, true).classed(self.getTrackButtonCSSClass(), true).on('click', function() {
						current_sort_setting = (current_sort_setting + 1) % 3;
						self.oncoprint.setTrackSortDirection(track_id, sort_direction[current_sort_setting]);//toggleTrackSortDirection(track_id);
						new_btn.attr('src', imgs[current_sort_setting]);
					})
					.style('position', 'absolute').style('left', left+'px').style('top', label_tops[track_id]+'px');
				})();
			}
		});
	};

	// Cells
	OncoprintSVGRenderer.prototype.resizeCells = function(new_width) {
		this.cell_div.selectAll('svg.'+this.getCellCSSClass()).style('width', this.oncoprint.getZoomedCellWidth()+'px');
	};
	OncoprintSVGRenderer.prototype.removeTrackCells = function(track_id) {
		this.cell_div.selectAll('svg.'+this.getTrackCellCSSClass(track_id)).remove();
	};
	OncoprintSVGRenderer.prototype.drawTrackCells = function(track_id, fragment) {
		var oncoprint = this.oncoprint;
		var data = oncoprint.getTrackData(track_id);
		var id_key = oncoprint.getTrackDatumIdKey(track_id);
		var id_accessor = oncoprint.getTrackDatumIdAccessor(track_id);
		var rule_set = this.getRuleSet(track_id);
		if (!rule_set) {
			return;
		}
		var self = this;

		this.track_cells[track_id] = {};
		var cell_class = this.getCellCSSClass();
		var track_cell_class = this.getTrackCellCSSClass(track_id);
		var track_cells = this.track_cells[track_id];

		var bound_svg = d3.select(fragment).selectAll('svg.'+track_cell_class).data(data);
		bound_svg.enter().append('svg').classed(track_cell_class, true).classed(cell_class, true)
			.attr('shape-rendering','geometricPrecision')
			.attr('preserveAspectRatio','none')
			.attr('viewBox', '0 0 '+oncoprint.getFullCellWidth()+' '+oncoprint.getCellHeight(track_id))
			.style('width', oncoprint.getZoomedCellWidth()+'px').style('height', oncoprint.getCellHeight(track_id)+'px');
		bound_svg.exit().remove();

		var tooltip = oncoprint.getTrackTooltip(track_id);
		bound_svg.each(function(d,i) {
			var dom_cell = this;
			var id = id_accessor(d);
			track_cells[id] = {dom: this, d: d};
		});
		bound_svg.selectAll('*').remove();
		this.active_rule_set_rules[rule_set.getRuleSetId()][track_id] = rule_set.apply(bound_svg, oncoprint.getFullCellWidth(), oncoprint.getCellHeight(track_id));
		self.track_cell_selections[track_id] = bound_svg;
	};
	OncoprintSVGRenderer.prototype.drawCells = function(track_ids) {
		var fragment;
		if (this.document_fragment) {
			//HACK
			fragment = document.createDocumentFragment();
		} else {
			fragment = this.cell_div.node();
		}
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var self = this;
		_.each(track_ids, function(track_id) {
			self.drawTrackCells(track_id, fragment);
		});
		if (this.document_fragment) {
			this.cellRenderTarget().node().appendChild(fragment);
		}
		setTimeout(function() {
			$(self).trigger(events.FINISHED_RENDERING);
		}, 0);
	};

	// Positioning
	OncoprintSVGRenderer.prototype.clipAndPositionCells = function(track_ids, axis, force, display_all) {
		this.cell_div.node().display = 'none';
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var visible_interval = this.getVisibleInterval();
		var interval_width = 4*(visible_interval[1] - visible_interval[0]);
		var interval_number = Math.floor(visible_interval[0] / interval_width);
		visible_interval = _.map([-interval_width, 2*interval_width], function(x) { 
			return Math.max(x + interval_number*interval_width, 0); 
		});
		var self = this;
		var track_cell_tops = this.getTrackCellTops();
		var id_order = this.oncoprint.getVisibleInvertedIdOrder();
		var cell_x = this.getCellXArray(Object.keys(id_order).length);
		_.each(track_ids, function(track_id) {
			var y;
			if (!axis || axis === 'top') {
				y = track_cell_tops[track_id];
			}
			var id_key = self.oncoprint.getTrackDatumIdKey(track_id);
			if ((interval_number !== self.prev_interval_number) || force) {
				if (self.track_cell_selections.hasOwnProperty(track_id)) {
					self.track_cell_selections[track_id].each(function(d,i) {
						var new_x = cell_x[id_order[d[id_key]]];
						var disp = this.style.display;
						var new_disp = ((isNaN(new_x) || new_x < visible_interval[0] || new_x > visible_interval[1]) && !display_all) ? 'none' : 'inherit';
						if (disp !== new_disp) {
							this.style.display = new_disp;
						}
						if ((!axis || axis === 'left') && new_disp !== 'none') {
							this.style.left = new_x + 'px';
						}
						if ((!axis || axis === 'top') && new_disp !== 'none') {
							this.style.top = y+'px';
						}
					});
				}
			}
		});
		this.prev_interval_number = interval_number;
		this.cell_div.node().display = 'block';
	};

	OncoprintSVGRenderer.prototype.setLegendVisible = function(track_ids, visible) {
		var self = this;
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : [].concat(track_ids);
		_.each(track_ids, function(id) {
			self.getRuleSet(id).exclude_from_legend = !visible;
		});
		this.renderLegend();
	};
	OncoprintSVGRenderer.prototype.renderLegend = function(include_all) {
		var cell_width = this.oncoprint.getFullCellWidth();
		var self = this;
		var rendered = {};
		self.legend_table.selectAll('*').remove();
		_.each(this.rule_sets, function(rule_set, track_id) {
			if (rule_set.exclude_from_legend && !include_all) {
				return;
			}
			var rule_set_id = rule_set.getRuleSetId();
			var active_rules = {};
			_.each(self.active_rule_set_rules[rule_set_id], function(track_map, track_id) {
				$.extend(active_rules, track_map);
			});
			if (!rendered.hasOwnProperty(rule_set_id)) {
				var tr = self.legend_table.append('tr');
				var label_header = tr.append('td').style('padding-top', '1em').style('padding-bottom', '1em')
							.append('span').classed('oncoprint-legend-header', true);
				label_header.text(rule_set.getLegendLabel());
				var legend_body_td = tr.append('td');
				var legend_div = rule_set.getLegendDiv(active_rules, cell_width, self.oncoprint.getCellHeight(track_id));
				legend_body_td.node().appendChild(legend_div);
				utils.d3SelectChildren(d3.select(legend_div), '*').classed('oncoprint-legend-block', true);
				rendered[rule_set_id] = true;
			}
		});
	};
	OncoprintSVGRenderer.prototype.dragLabel = function(track_id) {
		this.getLabelDragDiv().style('display','block');
		var track_group = this.oncoprint.getContainingTrackGroup(track_id);
		var first_track = track_group[0], last_track=track_group[track_group.length-1];
		var all_track_tops = this.getTrackLabelTops();
		var track_tops = {};
		_.each(track_group, function(id) { 
			track_tops[id] = all_track_tops[id];
		});
		track_group.splice(track_group.indexOf(track_id), 1);
		var group_track_tops = _.map(track_group, function(id) {
			return track_tops[id];
		});
		var label_area_height = this.getLabelAreaHeight();
		var drag_bounds = [undefined, undefined];
		drag_bounds[0] = utils.clamp(track_tops[first_track], 0, label_area_height);
		drag_bounds[1] = utils.clamp(track_tops[last_track]+this.getRenderedTrackHeight(last_track), 0, label_area_height);

		var self = this;
		var $label_drag_div = $(self.getLabelDragDiv().node());
		delete track_tops[track_id];

		(function(track_id) {
			var new_pos = -1;
			var moveHandler = function(evt) {
				if (evt.stopPropagation) {
					evt.stopPropagation();
				}
				if (evt.preventDefault) {
					evt.preventDefault();
				}
				var mouse_y = utils.clamp(utils.mouseY(evt), drag_bounds[0], drag_bounds[1]);
				self.renderTrackLabels(track_id, mouse_y);
				d3.selectAll(self.getTrackLabelCSSSelector(track_id)).classed(LABEL_DRAGGING_CLASS, true);
				
				new_pos = _.sortedIndex(group_track_tops, mouse_y);
				_.each(track_tops, function(top, id) {
					top += 3*(+(new_pos < track_group.length && track_group[new_pos] == id));
					top -= 3*(+(new_pos > 0 && track_group[new_pos-1] == id));
					self.renderTrackLabels(id, top);
				});
			}
			$label_drag_div.on("mousemove", moveHandler);
			var mouseUpHandler = function(evt) {
				$label_drag_div.hide();
				$label_drag_div.off("mousemove", moveHandler);
				if (new_pos > -1) {
					self.oncoprint.moveTrack(track_id, new_pos);
				}
			};
			$(document).one("mouseup", mouseUpHandler);
		})(track_id);
	};
	OncoprintSVGRenderer.prototype.toSVG = function(full_labels) {
		var self = this;
		var root = $(this.container.node()).offset();
		var svg = d3.select(document.createElementNS('http://www.w3.org/2000/svg', 'svg'));
		svg.attr('width', this.getLabelAreaWidth() + this.getCellAreaWidth() + 'px');
		this.renderLegend(true);
		this.renderTrackLabels(undefined, undefined, full_labels);
		svg.attr('height', $(this.container.node()).height()+'px');
		(function addLabels() {
			self.label_div.selectAll('.oncoprint-track-label').each(function() {
				var text_elt = d3.select(this);
				var font = text_elt.style('font-family') || 'Arial';
				var weight = text_elt.style('font-weight'); 
				var size = text_elt.style('font-size') || '12px';
				var pos = $(text_elt.node()).offset();
				var text = text_elt.text();
				svg.append('text').style('font-family', font).style('font-weight', weight).style('font-size', size)
						.attr('transform', utils.translate(pos.left - root.left,pos.top - root.top))
						.style('alignment-baseline', 'hanging')
						.text(text);	
			});
		})();
		(function addCells() {
			self.clipAndPositionCells(undefined, undefined, true, true);
			self.cell_div.selectAll('.oncoprint-cell').each(function() {
				var cell_elt = d3.select(this);
				var cell_rect = cell_elt.node().getBoundingClientRect();
				var cell_dim = {width: cell_rect.width, height: cell_rect.height};
				var pos = $(cell_elt.node()).offset();
				var g = svg.append('g').attr('transform', utils.translate(pos.left - root.left, pos.top - root.top));
				cell_elt.selectAll('*').each(function() {
					utils.appendD3SVGElement(d3.select(this), g);
				});
				var outline_styles = {color: cell_elt.style('outline-color'), width: cell_elt.style('outline-width')};
				if (outline_styles.color) {
					g.append('rect').attr('width', cell_dim.width+'px').attr('height', cell_dim.height+'px')
							.style('fill', 'none').style('stroke', outline_styles.color).style('stroke-width', outline_styles.width);
				}
			});
			//styles = {'outline-color':rule_spec.color, 'outline-style':'solid', 'outline-width':'2px'};
			self.clipAndPositionCells(undefined, undefined, true);
		})();
		(function addLegend() {
			self.legend_table.selectAll('tr').each(function() {
				d3.select(this).selectAll('td').each(function() {
					d3.select(this).selectAll('.oncoprint-legend-header,.oncoprint-legend-element').each(function() {
						if ($(this).text().trim().length) {
							// text type element
							var text_elt = d3.select(this);
							var font = text_elt.style('font-family') || 'Arial';
							if (font !== 'Arial') {
								console.log(this);
							}
							var weight = text_elt.style('font-weight'); 
							var size = text_elt.style('font-size') || '12px';
							var text = text_elt.text();
							var pos = $(text_elt.node()).offset();
							svg.append('text').style('font-family', font).style('font-weight', weight)
								.style('font-size', size)
								.attr('transform', utils.translate(pos.left - root.left, pos.top - root.top))
								.style('alignment-baseline', 'hanging')
								.text(text);
						} else if (this.tagName.toLowerCase() === 'svg') {
							var elt = d3.select(this);
							var pos = $(elt.node()).offset();
							var g = svg.append('g').attr('transform', utils.translate(pos.left - root.left, pos.top - root.top));
							var cell_rect = elt.node().getBoundingClientRect();
							var cell_dim = {width: cell_rect.width, height: cell_rect.height};
							var outline_styles = {color: elt.style('outline-color'), width: elt.style('outline-width')};
							if (outline_styles.color) {
								g.append('rect').attr('width', cell_dim.width+'px').attr('height', cell_dim.height+'px')
										.style('fill', 'none').style('stroke', outline_styles.color).style('stroke-width', outline_styles.width);
							}
							elt.selectAll('*').each(function() {
								utils.appendD3SVGElement(d3.select(this), g);
							});
						}
					});
				});
			});
		})();
		this.renderLegend();
		this.renderTrackLabels();
		return svg.node();
	};
	return OncoprintSVGRenderer;
})();;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.Oncoprint = (function() {
	var events = oncoprint_events;
	var utils = oncoprint_utils;
	var RuleSet = oncoprint_RuleSet;

	var defaultOncoprintConfig = {
		cell_width: 6,
		cell_padding: 2.5,
		legend: true,
	};

	var hiddenOncoprintConfig = {
		pre_track_padding: 0,
	};

	var defaultTrackConfig = {
		label: 'Gene',
		datum_id_key: 'patient',
		cell_height: 23,
		track_height: 20,
		track_padding: 5,
		sort_cmp: undefined,
		tooltip: function(d) {
			return d['patient'];
		},
		removable: false,
		sort_direction_changable: false
	}; 



	function Oncoprint(config) {
		var self = this;
		var getTrackId = utils.makeIdCounter();

		self.config = config;

		self.id_order = [];
		self.inverted_id_order = {};
		self.visible_id_order = [];
		self.visible_inverted_id_order = {};
		self.hidden_ids = {};
		self.track_groups = [[],[]];
		self.track_group_sort_order = [0,1];
		self.sort_direction = {};
		self.tracks = {};
		self.sort_config = {type: 'track'};

		self.cell_padding_on = true;
		self.true_cell_width = config.cell_width;

		self.zoomed_cell_width = self.true_cell_width;
		self.zoom = 1;

		// Cell Padding
		self.toggleCellPadding = function() {
			self.cell_padding_on = !self.cell_padding_on;
			$(self).trigger(events.SET_CELL_PADDING);
		};
		self.getCellPadding = function() {
			return Math.ceil(self.config.cell_padding*self.getZoom())*(+self.cell_padding_on);
		};

		// Zoom
		self.getZoom = function() {
			return self.zoom;
		};
		self.setZoom = function(z) {
			self.zoom = utils.clamp(z, 0, 1);
			updateZoomedCellWidth();
			updateZoom();
			$(self).trigger(events.SET_ZOOM);
			return self.zoom;
		};
		var updateZoom = function() {
			// maps {1, ... , true_cell_width} to [0,1]
			self.zoom = (self.zoomed_cell_width-1)/(self.true_cell_width - 1);
		};
		var updateZoomedCellWidth = function() {
			// maps [0,1] to {1, ... , true_cell_width}
			self.zoomed_cell_width = Math.round(self.zoom*(self.true_cell_width-1) + 1);
		};
		self.increaseZoom = function() {
			self.zoomed_cell_width = utils.clamp(self.zoomed_cell_width+1, 1, self.true_cell_width);
			updateZoom();
			$(self).trigger(events.SET_ZOOM);
			return self.zoom;
		};
		self.decreaseZoom = function() {
			self.zoomed_cell_width = utils.clamp(self.zoomed_cell_width-1, 1, self.true_cell_width);
			updateZoom();
			$(self).trigger(events.SET_ZOOM);
			return self.zoom;
		};

		// Cell Width
		self.getFullCellWidth = function() {
			return self.true_cell_width;
		};
		self.getZoomedCellWidth = function() {
			return self.zoomed_cell_width;
		};

		// Cell Height
		self.getCellHeight = function(track_id) {
			return self.tracks[track_id].config.cell_height;
		};

		// Track Height
		self.getTrackHeight = function(track_id) {
			return self.tracks[track_id].config.track_height;
		};

		// Track Padding
		self.getTrackPadding = function(track_id) {
			return self.tracks[track_id].config.track_padding;
		};

		// Id Order
		self.getFilteredIdOrder = function(data_filter_fn, track_ids) {
			var tracks = track_ids || self.getTracks();
			return _.filter(self.id_order, function(id) {
				var d = _.map(tracks, function(track_id) {
					return self.getTrackDatum(track_id, id);
				});
				return data_filter_fn(d);
			});
		};
		self.getIdOrder = function() {
			return self.id_order;
		};
		self.getInvertedIdOrder = function() {
			return self.inverted_id_order;
		};
		self.getVisibleIdOrder = function() {
			return self.visible_id_order;
		};
		self.getVisibleInvertedIdOrder = function() {
			return self.visible_inverted_id_order;
		};
		var updateVisibleIdOrder = function() {
			self.visible_id_order = _.filter(self.id_order, function(id) {
				return !self.hidden_ids[id];
			});
			self.visible_inverted_id_order = utils.invert_array(self.visible_id_order);
			$(self).trigger(events.SET_VISIBLE_ID_ORDER);
		};
		self.setIdOrder = function(id_order) {
			self.id_order = id_order.slice();
			self.inverted_id_order = utils.invert_array(self.id_order);
			updateVisibleIdOrder();
			$(self).trigger(events.SET_ID_ORDER);
		};
		// Hide Ids
		self.hideIds = function(ids, clear_existing) {
			if (clear_existing) {
				self.hidden_ids = {};
			}
			_.each(ids, function(id) {
				self.hidden_ids[id] = true;
			});
			updateVisibleIdOrder();
		};
		self.showIds = function(ids) {
			if (!ids) {
				self.hidden_ids = {};
			} else {
				_.each(ids, function(id) {
					delete self.hidden_ids[id];
				});
			}
			updateVisibleIdOrder();
		};

		// Sorting
		self.getTopmostTrack = function() {
			return (self.track_groups[0].length > 0 ? self.track_groups[0][0] : self.track_groups[1][0]);
		};
		self.setTrackSortComparator = function(track_id, cmp) {
			self.tracks[track_id].config.sort_cmp = cmp;
		};
		self.getTrackSortComparator = function(track_id) {
			return self.tracks[track_id].config.sort_cmp;
		};
		self.getTrackSortDirection = function(track_id) {
			return self.sort_direction[track_id];
		};
		self.setTrackSortDirection = function(track_id, dir) {
			self.sort_direction[track_id] = dir;
			self.sort();
		};
		self.setTrackGroupSortOrder = function(order) {
			self.track_group_sort_order = order.slice();
		};
		self.getTrackGroupSortOrder = function() {
			return self.track_group_sort_order.slice();
		};
		self.getTrackSortOrder = function() {
			var ret = [];
			var track_groups = self.getTrackGroups();
			_.each(self.getTrackGroupSortOrder(), function(group_id) {
				ret = ret.concat(track_groups[group_id]);
			});
			return ret;
		};
		self.setSortConfig = function(config) {
			self.sort_config = config;
		};
		var sortById = function(desc) {
			var ret = _.sortBy(self.getIdOrder(), _.identity);
			if (desc) {
				ret.reverse();
			}
			self.setIdOrder(ret);
		};
		var sortByTrack = function() {
			var track_id_list = self.getTrackSortOrder();
			var cmp_list = _.map(track_id_list, function(track_id) { 
				return self.getTrackSortComparator(track_id);
			});
			var data = {};
			var id_order = self.getIdOrder();
			_.each(id_order, function(id) {
				data[id] = {};
				_.each(track_id_list, function(track_id) {
					data[id][track_id] = self.getTrackDatum(track_id, id);
				});
			});
			var lexicographically_ordered_cmp = function(id1,id2) {
				var cmp_result = 0;
				for (var i=0, _len = track_id_list.length; i<_len; i++) {
					var track_id = track_id_list[i];
					var cmp = cmp_list[i];
					var d1 = data[id1][track_id];
					var d2 = data[id2][track_id];
					var d1_undef = (typeof d1 === "undefined");
					var d2_undef = (typeof d2 === "undefined");
					if (!d1_undef && !d2_undef) {
						cmp_result = cmp(d1, d2);
					} else if (d1_undef && d2_undef) {
						cmp_result = 0;
					} else if (d1_undef) {
						cmp_result = 1;
					} else {
						cmp_result = -1;
					}
					if (isFinite(cmp_result)) {
						// reverse direction unless infinite, which is a signal that an NA is involved
						cmp_result *= self.sort_direction[track_id];
					}
					if (cmp_result !== 0) {
						break;
					}
				}
				return cmp_result;
			};
			self.setIdOrder(utils.stableSort(self.getIdOrder(), lexicographically_ordered_cmp));
		};
		self.sort = function() {
			var config = self.sort_config;
			if (config.type === 'track') {
				sortByTrack();
			} else if (config.type === 'id') {
				sortById(config.desc);
			}
		};

		// Track Creation/Destruction
		self.addTrack = function(config, group) {
			group = utils.ifndef(group, 1);
			var track_id = getTrackId();
			self.tracks[track_id] ={id: track_id, 
						data: [], 
						config: $.extend({}, defaultTrackConfig, config),
						id_data_map: {}};
			self.track_groups[group].push(track_id);
			self.sort_direction[track_id] = 1;

			$(self).trigger(events.ADD_TRACK, {track_id: track_id});
			return track_id;
		};
		self.removeTrack = function(track_id) {
			var track = self.tracks[track_id];
			delete self.tracks[track_id];
			delete self.sort_direction[track_id];

			var track_group = self.getContainingTrackGroup(track_id, true);
			if (!track_group) {
				return false;
			} else {
				var old_position = track_group.indexOf(track_id);
				track_group.splice(old_position, 1);

				$(self).trigger(events.REMOVE_TRACK, {track: track, track_id: track_id});
				return true;	
			}
		};

		// Track Ordering
		self.getTrackGroups = function(reference) {
			return (reference === true ? self.track_groups : $.extend(true, [], self.track_groups));			
		};
		self.getTracks = function() {
			return _.flatten(self.getTrackGroups());
		};
		self.getContainingTrackGroup = function(track_id, reference) {
			var group = false;
			_.find(self.track_groups, function(grp) {
				if (grp.indexOf(track_id) > -1) {
					group = grp;
					return true;
				}
				return false;
			});
			return (reference === true ? group : group.slice());
		};
		self.moveTrack = function(track_id, new_position) {
			var track_group = self.getContainingTrackGroup(track_id, true);
			if (!track_group) {
				return false;
			}
			var old_position = track_group.indexOf(track_id);
			new_position = utils.clamp(new_position, 0, track_group.length-1);
			track_group.splice(old_position, 1);
			track_group.splice(new_position, 0, track_id);
			var moved_tracks = track_group.slice(Math.min(old_position, new_position), Math.max(old_position, new_position) + 1);
			$(self).trigger(events.MOVE_TRACK, {moved_tracks: moved_tracks});
		};


		// Track Label
		self.getTrackLabel = function(track_id) {
			return self.tracks[track_id].config.label;
		};

		// Track Tooltip
		self.getTrackTooltip = function(track_id) {
			return self.tracks[track_id].config.tooltip;
		};
		self.setTrackTooltip = function(track_id, tooltip) {
			self.tracks[track_id].config.tooltip = tooltip;
		};

		// Track Data
		self.getTrackData = function(track_id) {
			return self.tracks[track_id].data;
		};
		self.setTrackData = function(track_id, data) {
			var id_accessor = self.getTrackDatumIdAccessor(track_id);

			self.tracks[track_id].data = data;

			var current_id_order = self.getIdOrder();
			var current_inverted_id_order = self.getInvertedIdOrder();
			_.each(_.map(data, id_accessor), function(id) {
				if (!(id in current_inverted_id_order)) {
					current_id_order.push(id);
				}
			});
			self.setIdOrder(current_id_order);
			
			self.tracks[track_id].id_data_map = {};
			var id_data_map = self.tracks[track_id].id_data_map;
			_.each(self.tracks[track_id].data, function(datum) {
				id_data_map[id_accessor(datum)] = datum;
			});
			$(self).trigger(events.SET_TRACK_DATA, {track_id: track_id});
		};
		self.getTrackDatum = function(track_id, datum_id) {
			return self.tracks[track_id].id_data_map[datum_id];
		};
		self.getTrackDatumDataKey = function(track_id) {
			return self.tracks[track_id].config.datum_data_key;
		};

		// Track Datum Id
		self.getTrackDatumIdAccessor = function(track_id) {
			var key = self.getTrackDatumIdKey(track_id);
			return function(d) {
				return d[key];
			};
		};
		self.getTrackDatumIdKey = function(track_id) {
			return self.tracks[track_id].config.datum_id_key;
		};
		self.setTrackDatumIdKey = function(track_id, key) {
			self.tracks[track_id].config.datum_id_key = key;
		};

		// Track info
		self.isTrackRemovable = function(track_id) {
			return self.tracks[track_id].config.removable;
		};
		self.isTrackSortDirectionChangable = function(track_id) {
			return self.tracks[track_id].config.sort_direction_changable;
		};

		// Clearing
		self.clearData = function() {
			_.each(self.getTracks(), function(track_id) {
				self.setTrackData(track_id, []);
			});
			self.setIdOrder([]);
		}
	}

	return { 
		CATEGORICAL_COLOR: RuleSet.CATEGORICAL_COLOR,
		GRADIENT_COLOR: RuleSet.GRADIENT_COLOR,
		GENETIC_ALTERATION: RuleSet.GENETIC_ALTERATION,
		BAR_CHART: RuleSet.BAR_CHART,
		create: function CreateOncoprint(container_selector_string, config) {
			config = $.extend({}, defaultOncoprintConfig, config || {});
			config = $.extend(config, hiddenOncoprintConfig);
			var oncoprint = new Oncoprint(config);
			var renderer = new OncoprintSVGRenderer(container_selector_string, oncoprint, {label_font: 'Arial', legend:config.legend});
			var ret = {
				onc_dev: oncoprint,
				ren_dev: renderer,
				addTrack: function(config, group) {
					var track_id = oncoprint.addTrack(config, group);
					return track_id;
				},
				removeTrack: function(track_id) {
					oncoprint.removeTrack(track_id);
				},
				moveTrack: function(track_id, position) {
					oncoprint.moveTrack(track_id, position);
				},
				setTrackDatumIdKey: function(track_id, key) {
					oncoprint.setTrackDatumIdKey(track_id, key);
				},
				setTrackData: function(track_id, data) {
					oncoprint.setTrackData(track_id, data);
				},
				setRuleSet: function(track_id, type, params) {
					renderer.setRuleSet(track_id, type, params);
				},
				useSameRuleSet: function(target_track_id, source_track_id) {
					renderer.useSameRuleSet(target_track_id, source_track_id);
				},
				toggleCellPadding: function() {
					oncoprint.toggleCellPadding();
				},
				toSVG: function() {
					return renderer.toSVG();
				},
				setTrackGroupSortOrder: function(order) {
					oncoprint.setTrackGroupSortOrder(order);
				},
				sort: function() {
					oncoprint.sort();
				},
				setSortConfig: function(config) {
					oncoprint.setSortConfig(config);
				},
				setIdOrder: function(id_order) {
					oncoprint.setIdOrder(id_order);
				},
				getTrackSortDirection: function(track_id) {
					return oncoprint.getTrackSortDirection(track_id);
				},
				setTrackSortDirection: function(track_id, dir) {
					oncoprint.setTrackSortDirection(track_id, dir);
				},
				setZoom: function(z) {
					return oncoprint.setZoom(z);
				},
				increaseZoom: function() {
					return oncoprint.increaseZoom();
				},
				decreaseZoom: function() {
					return oncoprint.decreaseZoom();
				},
				suppressRendering: function() {
					renderer.suppressRendering();
				},
				releaseRendering: function() {
					renderer.releaseRendering();
				},
				setLegendVisible: function(track_ids, visible) {
					renderer.setLegendVisible(track_ids, visible);
				},
				getFilteredIdOrder: function(data_filter_fn, track_ids) {
					return oncoprint.getFilteredIdOrder(data_filter_fn, track_ids);
				},
				getVisibleIdOrder: function() {
					return oncoprint.getVisibleIdOrder();
				},
				hideIds: function(ids) {
					oncoprint.hideIds(ids);
				},
				showIds: function(ids) {
					oncoprint.showIds(ids);
				},
				clearData: function() {
					oncoprint.clearData();
				},
				setTrackTooltip: function(track_id, tooltip) {
					oncoprint.setTrackTooltip(track_id, tooltip);
				}
			};
			$(oncoprint).on(events.MOVE_TRACK, function() {
				$(ret).trigger(events.MOVE_TRACK);
			});
			$(renderer).on(events.FINISHED_RENDERING, function() {
				$(ret).trigger(events.FINISHED_RENDERING);
			});
			$(oncoprint).on(events.REMOVE_TRACK, function(evt, data) {
				$(ret).trigger(events.REMOVE_TRACK, {track_id: data.track_id});
			});
			$(renderer).on(events.CONTENT_AREA_MOUSEENTER, function(evt, data) {
				$(ret).trigger(events.CONTENT_AREA_MOUSEENTER);
			});
			$(renderer).on(events.CONTENT_AREA_MOUSELEAVE, function(evt, data) {
				$(ret).trigger(events.CONTENT_AREA_MOUSELEAVE);
			});
			return ret;
		}
	};
})();
;
</script>

<style>
#oncoprintDiv{
   background-color: #f0f0f0;
   margin: auto;
   padding: 5px;
   }
</style>
<div id = 'oncoprintDiv'>
<div id="oncoprintInstructions" style="display: block">Please select and send up to 350 genes and patients from another tab, such as Markers &amp Patients, to populate the display.</div>
<div id="oncoprintControlsDiv">  
<!--	<select type="button" id="oncoprintSendSelectionsMenu" style="float:right; margin:15px"></select>  -->
	<div id='onc'></div>
    <button id='toggle_whitespace' >Toggle Whitespace</button>
    <button id='reduce_cell_width'>Reduce Cell Width</button>
</div>
<div id="errorMessage1"></div>
<div id="errorMessage2"></div>
</div>


</div>

<div id="footer-logos" style="margin-left:auto; margin-right:auto">
	<span style="float:left; width:33%">
	  <a href="http://www.fredhutch.org" target="_blank"><img width="235" height="80" src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/FredHutch_h_tag_4col_RBG_tm.png" alt="Fred Hutch"/></a>
	</span>

    <span id="githubIssues" style="float:right; margin:10px" title="GitHub Help Wanted Issues">
       <a href="https://github.com/FredHutch/Oncoscape/labels/help%20wanted" target="_blank" >
          <img width="40" src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/GitHub-Mark-120px-plus.png"
          alt="GitHub Issues" data-canonical-src="http://oncoscape-static.s3-website-us-west-2.amazonaws.com/images/GitHub-Mark-120px-plus.png"></a>
    </span>

</div>
<script>
hub.hideTab("blank tab", "#blankTabDiv");
</script>


</body>
</html>
