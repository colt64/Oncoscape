




<!DOCTYPE html> 
<html>

<head>
   <meta charset="UTF-8">
   <meta property="og:title" content="Oncoscape" />

   <title> OncoDev 1.4</title>

   <script src="http://code.jquery.com/qunit/qunit-1.18.0.js"></script>
   <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.18.0.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-2.1.3.min.js"></script>
   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-1.11.2.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-ui-1.11.4.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.7/themes/smoothness/jquery-ui.css">

   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.4.4.min.js"></script -->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.5.0.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.cytoscape.js-panzoom.js"></script>
   <link   href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.cytoscape.js-panzoom.css" 
           rel="stylesheet" 
           type="text/css">


   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/d3.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.dataTables-1.10.5.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.dataTables-1.10.5.min.css">

   <script src="http://cdn.datatables.net/colvis/1.1.0/js/dataTable.colVis.js"></script>

   <link   rel="stylesheet" type="text/css"
           href="http://cdn.datatables.net/colvis/1.1.0/css/dataTables.colVis.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.multi-select.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/multi-select.css" media="screen" rel="stylesheet" type="text/css">
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/chosen.jquery.min.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/chosen.min.css" media="screen" rel="stylesheet" type="text/css">

    <link rel="SHORTCUT ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>
    <link rel="ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>


<script> 
//--------------------------------------------------------------------------------------------------
// hooks for google analytics

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-528883-29', 'auto');
  ga('send', 'pageview');
//--------------------------------------------------------------------------------------------------
</script> 

<script>
navigator.sayswho= (function(){
    var ua= navigator.userAgent, tem,
    M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
    }
    if(M[1]!== 'Chrome'){
       alert("Oncoscape is currently developed and tested under Chrome.  For best results, please use Chrome version 45.0 and later.")
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
    }
    M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();
</script>

</head>

<style>

.flex-container {
  display: -webkit-flex;
  display: flex;
  }

.ui-slider-range {
   background-image: none;
   background: lightgrey;
   }

th,td {
   font-size:12px;
   }

.patientDataFilterSliderReadout{
   font-size: 10px;
   height:16px;
   }

.ui-tabs .ui-tabs-nav li a{
   font-size:10pt !important;
   }

.ui-button .ui-button-text{
   font-size:10pt !important;
   }

.SelectionMenu{
color: rgb(0, 0, 0); 
background-color: rgb(255, 255, 255);
}

</style>



<script>

//----------------------------------------------------------------------------------------------------
// These javascript functions and variables are arranged into a simple module so that
// implementation details are kept private from the public API other oncoscape 
// browser modules will use.  common services and utility functions are provided here
//----------------------------------------------------------------------------------------------------
var HubModule = (function () {

  var name = "HubModule";
     // keys are module names, their outermost divs are the values.
     // providing these outermost divs allows was inspired by 
     // the need to allow raising of tabs by the sending tab.
     // TODO: not sure that's still needed

  var selectionDestinations = {};
  var dispatchOptions = {};
  var socketIsConnected = false;
  var socketConnectedFunctions = [];
  var onDocumentReadyFunctions = [];
  var socketURI = window.location.href.replace("http://", "ws://");
  var socket;

  var  messagingRestrictedToLogin = false;

  var modules = {};
//----------------------------------------------------------------------------------------------------
function registerModule(name, moduleObject)
{
   modules[name] = moduleObject;

} // registerModule
//----------------------------------------------------------------------------------------------------
function getModuleNames()
{
   return(Object.getOwnPropertyNames(modules));

} // getModuleNames
//----------------------------------------------------------------------------------------------------
function getModules()
{
   return modules;

} // getModules
//----------------------------------------------------------------------------------------------------
// TODO: add 3rd argument: acceptsIncomingMessages
//       datasets, for instance, seems to have no need for incoming json/websocket messages
function registerSelectionDestination(names, outermostDivID)
{
  if(typeof(names) == "string")
    names = [names];

  for(var i=0; i < names.length; i++)
     selectionDestinations[names[i]] = outermostDivID;

} // registerSelectionDestination
//----------------------------------------------------------------------------------------------------
function getRegisteredSelectionDestinations()
{
  return(selectionDestinations);

} // getRegisteredSelectionDestinations
//----------------------------------------------------------------------------------------------------
function setupSocket(socket)
{
  console.log("=== Module.hub setupSocket");

  try {
     socket.onopen = function() {
        console.log("websocket connection now open");
        socketIsConnected = true;
        for(var f=0; f < socketConnectedFunctions.length; f++){
           console.log("calling the next sockectConnectedFunction");
           socketConnectedFunctions[f]();
           } // for f
        } // socked.onopen

     socket.onmessage = function got_packet(msg) {
        var msg = JSON.parse(msg.data)
        dispatchMessage(msg)
        } // socket.onmessage, got_packet

     socket.onclose = function(){
        alert("Web socket connection to server has closed");
        } // socket.onclose
     } // try
  catch(exception) {
    console.log("Error: " + exception);
    }
 
  return(socket);

} // setupSocket
//----------------------------------------------------------------------------------------------------
function socketConnected()
{
   return(socketIsConnected);

} // socketConnected
//----------------------------------------------------------------------------------------------------
function addSocketConnectedFunction(func)
{
   socketConnectedFunctions.push(func)

} // addSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function getSocketConnectedFunctions()
{
   return(socketConnectedFunctions)

} // getSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function addOnDocumentReadyFunction(func)
{
   onDocumentReadyFunctions.push(func)

} // addOnDocumentReadyFunction
//----------------------------------------------------------------------------------------------------
function getOnDocumentReadyFunctions()
{
   return(onDocumentReadyFunctions)

} // getOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
// the nginx proxy server, used by fhcrc IT for the publicly-visible version of Oncoscape
// times out web sockets at 90 seconds.
// this function, when called more often that that, will keep the websocket open.
keepAlive = function()
{   
    //console.log("keep alive"); 
    msg = {cmd: "keepAlive", callback: "", status:"request", payload:""}
    socket.send(JSON.stringify(msg));

} // keepAlive
//--------------------------------------------------------------------------------------------------
function runOnDocumentReadyFunctions()
{
  setInterval(keepAlive, 10000);  // 10 seconds
  var funcs = getOnDocumentReadyFunctions()
  console.log("==== Module.hub: " + funcs.length + " onDocumentReadyFunctions");

  for (var f = 0; f < funcs.length; f++) {
     console.log("calling on ready function");
     funcs[f]();
     }

} // runOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
function runningInNode()
{
    // a not very sophisticated test, but adequate for our purposes thus far
  return(typeof(window) == "undefined")

} // functionRunningInNode
//----------------------------------------------------------------------------------------------------
function initializeWebSocket()
{
   if(runningInNode()){
     console.log("--- web socket not currently available when runing in Node");
     process.exit(code=1)
     }

   socket = new WebSocket(socketURI);
   socket = setupSocket(socket);

} // initializeWebSocket
//----------------------------------------------------------------------------------------------------
function getSocket()
{
  return(socket);

} // getSocket
//----------------------------------------------------------------------------------------------------
function addMessageHandler(cmd, func)
{
  if(cmd in dispatchOptions){
     dispatchOptions[cmd].push(func)
     }
  else{
     dispatchOptions[cmd] = [func]
     }
  
} // addMessageHandler
//----------------------------------------------------------------------------------------------------
function getRegisteredMessageNames()
{
   return(Object.keys(dispatchOptions));
  
} // getRegisteredMessageNames
//----------------------------------------------------------------------------------------------------
function getDispatchOptions()
{
   return(dispatchOptions);
  
} // getDispatchOptions
//----------------------------------------------------------------------------------------------------
function dispatchMessage(msg)
{
   var cmd = msg.cmd;
   var status = msg.status;
   console.log("====== Mondule.hub dispatchMessage '" + cmd + "' [" + Date() + "]" );

   var dispatchKeys = Object.keys(dispatchOptions);
   var cmdIndex = dispatchKeys.indexOf(cmd);
   console.log("hub.dispatchMessage(" + cmd + "): " + cmdIndex);

   if(cmdIndex === -1){
      console.log("unrecognized socket request: " + msg.cmd);
      console.log(" --- msg:");
      console.log(msg);
      console.log(" --- dispatchOptions");
      console.log(dispatchOptions);
      }
   else{
     var funcs = dispatchOptions[cmd];
     //console.log(" func count for msg cmd " + cmd + ": " + funcs.length);
      for(var i=0; i < funcs.length; i++){
         //console.log("--- Module.hub executing func # " + i + " for cmd " + msg.cmd);
         funcs[i](msg); // dispatchOptions[msg.cmd](msg)
         } // for i
      }

}  // dispatchMessage
//----------------------------------------------------------------------------------------------------
function restrictMessagingToLogin(newState)
{
   messagingRestrictedToLogin = newState;

} // restrictMessagingToLogin
//----------------------------------------------------------------------------------------------------
function send(msg)
{
   var cmd = JSON.parse(msg).cmd;
   if(messagingRestrictedToLogin && cmd === "checkPassword"){
      console.log("hub.send drops non-login msg");
      return;
      }

   var browserLocalCommand = Object.keys(dispatchOptions).indexOf(cmd) >= 0;
   var mode = "server";
   if(browserLocalCommand)
      mode = "browser local";

   console.log("--- hub.send: '" + cmd + "' (" + mode + ")");

   if(browserLocalCommand)
      dispatchMessage(JSON.parse(msg));
   else{
      socket.send(msg);
      }

}  // send
//----------------------------------------------------------------------------------------------------
function setTitle (newTitle)
{
  window.document.title = newTitle;

}  // setTitle
//----------------------------------------------------------------------------------------------------
// add a pulldown menu to the specified menuSelector, which has been provided by the caller, which
// is assumed to be an Oncoscape module.  append the names of all previously-registered divs, 
// except for those explicitly excluded in the incoming argument "excludedModules".
// This supports the usual (but not universal) case: a module does not want to send selections
// to itself.
// this argument will often be an array of one element, the name of the calling module.
// some modules may have multiple send destinations (eg, "PCA" & "PCA (highlight)".
function configureSendSelectionMenu(menuSelector, excludedModules, changeFunction, menuTitle)
{
  var menu = $(menuSelector);
  menu.append("<option>" + menuTitle + "</option>");
  menu.change(changeFunction);
  var otherModules = Object.keys(hub.getRegisteredSelectionDestinations());

  for(var i=0; i < otherModules.length; i++){
     var moduleName = otherModules[i];
     var excluded = excludedModules.indexOf(moduleName) >= 0;
     if(!excluded){
        menu.append("<option>" + moduleName + "</option>");
        }
     } // for i

  return(menu);

} // createSendSelectionMenu
//--------------------------------------------------------------------------------------------
function disableButton(button)
{
   button.prop("disabled", true);
   button.css({"background-color": "lightgray", "color": "gray"});

} // disableButton
//--------------------------------------------------------------------------------------------
function enableButton(button)
{
   button.prop("disabled", false);
   //button.css({ 'color': 'black'})
   button.css({"background-color": "white", "color": "black"});

} // enableButton
//--------------------------------------------------------------------------------------------
function disableAllTabsExcept(tabIDstring)
{
  if(typeof tabIDstring == "string") tabIDstring = [tabIDstring]
  var allDivIDs = getTabDivIDs()
  allDivIDs = allDivIDs.filter(function(i, id){ return(tabIDstring.indexOf(id) == -1) })
  for(var i=0;i<allDivIDs.length; i++){  	disableTab(allDivIDs[i]) }
  
  return allDivIDs;  //returns divIDs that have been disabled
  
} // disableTab

//--------------------------------------------------------------------------------------------
function disableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "disable", "#" + tabIDstring  )
} // disableTab
//--------------------------------------------------------------------------------------------
function enableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "enable", "#" + tabIDstring   )
} // enableTab

//--------------------------------------------------------------------------------------------
// if jQuery-style tabs are in use with Oncoscape, this function raised the named tab to the
// the front (visible) position in the tabset
// the argument, "tabIDString" is the tab id used in the module's widget.html, reproduced exactly
// in tabsApp/widget.html, with some current examples being
//  pcaDiv, patientTimeLinesDiv, gbmPathwaysDiv
//
function raiseTab(tabIDString)
{
  var tabsWidget = $("#oncoscapeTabs");

  if(tabsWidget.length > 0){
     var selectionString = '#oncoscapeTabs a[href="#' + tabIDString + '"]';
     var tabIndex = $(selectionString).parent().index ();
     if(tabIndex < 0) throw "Module.hub does not recognize tabIDString '" + tabIDString + "'";
     tabsWidget.tabs( "option", "active", tabIndex);
     } // if tabs exist

} // raiseTab
//----------------------------------------------------------------------------------------------------
// each of our tabs is a div, nested directly within $("oncoscapeTabs").  
// this function returns an array of each of the div ids
function getTabNames()
{
  var tabNames = $("#oncoscapeTabs").children()[0].textContent.trim().split("\n")
  for (i=0;i< tabNames.length; i++){ tabNames[i] = tabNames[i].trim()}
  tabNames =tabNames.filter(function(name){return name != ""})

	return tabNames;

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// each of our tabs has a title within the $("oncoscapeTabs") nav bar
// this function returns an array of each tab Title
function getTabDivIDs()
{
   return ($("#oncoscapeTabs").children("div").map(function(index,dom){return dom.id}));

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTab("Login", "#loginDiv");
function hideTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideTab
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTabNav("Login");
function hideTabNav(tabTitle)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()

} // hideTab
//----------------------------------------------------------------------------------------------------
function hideAllTabsButOne(tabTitle, tabDivIDstring)
{
  var divIDs = getTabDivIDs();
  
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideAllTabsButOne
//----------------------------------------------------------------------------------------------------
function showTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").show()
  $(tabDivIDstring).show();

} // showTab
//----------------------------------------------------------------------------------------------------
function addTab(tabTitle, tabDivIDstring,  content)
{
  var tabs = $("#oncoscapeTabs").tabs()
  var listItem = "<li><a href='#" + tabDivIDstring + "}'>" + tabTitle + "</a>";

  tabs.find(".ui-tabs-nav").append(listItem);
  tabs.append("<div id='" + tabDivIDstring + "'><p>" + content + "</p></div>");
  tabs.tabs("refresh");

} // addTab
//----------------------------------------------------------------------------------------------------
function getRandomFloat (min, max)
{
    return Math.random() * (max - min) + min;
}
//----------------------------------------------------------------------------------------------------
function getRandomInt (min, max) 
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
//----------------------------------------------------------------------------------------------------
String.prototype.beginsWith = function (string) 
{
    return(this.toLowerCase().indexOf(string.toLowerCase()) === 0);
};
//----------------------------------------------------------------------------------------------------
uniqueElementsOfArray = function(vector)
{
  var u = {}, a = [];

  for(var i = 0, l = vector.length; i < l; ++i){
     if(u.hasOwnProperty(vector[i])){
       continue;
       }
     a.push(vector[i]);
     u[vector[i]] = 1;
     } // for i

   return a;

} // uniqueElementsOfArray
//----------------------------------------------------------------------------------------------------
// return the targets matched by the candidates, where match is tolerant of differences by suffix
// thus incoming id "TCGA.06.0649.01" matches existing id "TCGA.06.0649" and
//      incoming id "TCGA.06.0649"    matches existing id "TCGA.06.0649.01" 
// this may cause problems with gene names, eg, MYC would mach MYCL and MYCA
// todo: make this suffix-tolerant match suffix-specific 
function intersectionOfArrays(candidates, targets) {

  hits=[]; 

  for(var i=0; i < candidates.length; i++){
    for (var j=0; j < targets.length; j++){
       candidate = candidates[i];
       target = targets[j];
       index1 = candidate.indexOf(target);   // "abc".indexOf("ab") -> 0
       index2 = target.indexOf(candidate); 
       //console.log("c(t): " + candidate + " contains " + target + ": " + index1);
       //console.log("t(c): " + target + " contains " + candidate + ": " + index2);
       if (index1 == 0)
          hits.push(target)
       else if (index2 == 0)
          hits.push(target)
         } // for j
     } // for i

  return(hits)

} // intersectionOfArays
//----------------------------------------------------------------------------------------------------
function setupGlobalExceptionHandler()
{
   window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {

      var title = "Oncoscape Error";
      var options = {buttons: { "Ok": function () { $(this).dialog("close"); } },
                     title: title};
      var text = "<i>" + errorMsg + "</i><br>" +
                 "<br><b>Script</b>: " + url + 
                 "<br><b>Line:</b> " + lineNumber + 
                 "<br><b>Column:</b> " + column + 
                 "<br><b>StackTrace:</b> " +  errorObj;
      $("<div></div>").dialog(options).html(text);
      };
 
} // setupGlobalExceptionHandler
//----------------------------------------------------------------------------------------------------
function start()
{
  setupGlobalExceptionHandler();
  initializeWebSocket();
  $(document).ready(runOnDocumentReadyFunctions);
  QUnit.config.altertitle = false;

}  // start
//----------------------------------------------------------------------------------------------------
function test_intersectionOfArrays()
{
   console.log("---  test_intersectionOfArrays");
   var targets = ["TCGA.02.0006"];
   var candidates = ["TCGA.02.0006"];

   QUnit.test("test_intersectionOfArrays 1", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   targets = ["TCGA.02.0006"];
   candidates = ["bogus"];
   QUnit.test("test_intersectionOfArrays 2", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });

   targets = ["bogus"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 3", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });


   targets = ["TCGA.02.0006.01"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 4", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   //targets = ["MAP2"];   this test will fail because sometimes we want incomplete matches:
   //  see test4 just above
   //candidates = ["MAP2K4", "abc"];
   //QUnit.test("test_intersectionOfArrays 5", function(assert) {
   //   assert.equal(hub.intersectionOfArrays(candidates, targets), []);
   //   });


} //  test_intersectionOfArrays
//----------------------------------------------------------------------------------------------------
function standAloneTest()
{
   test_intersectionOfArrays();

}  // standaloneTest
//----------------------------------------------------------------------------------------------------

  return({
     getName: function() {return(name)},
     restrictMessagingToLogin: restrictMessagingToLogin,
     registerModule: registerModule,
     getModules: getModules,
     registerSelectionDestination: registerSelectionDestination,
     getRegisteredSelectionDestinations: getRegisteredSelectionDestinations,
     socketConnected: socketConnected,
     addSocketConnectedFunction: addSocketConnectedFunction,
     getSocketConnectedFunctions: getSocketConnectedFunctions,
     addOnDocumentReadyFunction: addOnDocumentReadyFunction,
     getOnDocumentReadyFunctions: getOnDocumentReadyFunctions,
     runningInNode: runningInNode,
     initializeWebSocket: initializeWebSocket,
     getSocket: getSocket,
     addMessageHandler: addMessageHandler,
     getRegisteredMessageNames: getRegisteredMessageNames,
     getDispatchOptions: getDispatchOptions,
     dispatchMessage: dispatchMessage,
     configureSendSelectionMenu: configureSendSelectionMenu,
     enableButton: enableButton,
     disableButton: disableButton,
     enableTab: enableTab,
     disableTab: disableTab,
     disableAllTabsExcept: disableAllTabsExcept,
     getRandomInt: getRandomInt,
     getRandomFloat: getRandomFloat,
     intersectionOfArrays: intersectionOfArrays,
     uniqueElementsOfArray: uniqueElementsOfArray,
     send: send,
     setTitle: setTitle,
     getTabDivIDs: getTabDivIDs,
     getTabNames: getTabNames,
     raiseTab: raiseTab,
     hideTab: hideTab,
     hideTabNav: hideTabNav,
     showTab: showTab,
     addTab: addTab,
     sat: standAloneTest,
     start: start
     });

}); // HubModule
//----------------------------------------------------------------------------------------------------


var hub = HubModule();
hub.start();

hub.addOnDocumentReadyFunction(function() {
    console.log("====== tabapps document ready");
    window.tabsAppRunning = true
    $("#oncoscapeTabs").tabs({
         // todo: distinguish between tabs, only do needed resets
       activate: function(event, ui) {
            console.log(" tabsApp/code.js:activate");
            var tableRef = $("#historyTable").dataTable();
            var tableRef2 = $("#userDataStoreTable").dataTable();
            if (tableRef.length > 0) {
               console.log("   adjusting patient history table");
               tableRef.fnAdjustColumnSizing();
               } // if
            if (tableRef2.length > 0) {
               console.log("   skipping! - adjusting user data store table");
               tableRef2.fnAdjustColumnSizing();
               } // if
            //console.log(" ==== tab.activate, possible cyjs resize and fit");
            if(typeof(cwMarkers) != "undefined") {
               console.log("adjusting cwMarkers");
               cwMarkers.resize(); 
               console.log("after resize");
               cwMarkers.fit(50);
               console.log("done adjusting cwMarkers");
               }
            if(typeof(cyGbm) != "undefined") {
               //console.log("adjusting cwGbm");
               cyGbm.resize();
               cyGbm.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cwAngio) != "undefined") {
               //console.log("adjusting cwAngio");
               cwAngio.resize();
               cwAngio.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cyPathway) != "undefined") {
               cyPathway.resize();
               cyPathway.fit(50);
               }
            } // activate
        }); // tabs
    });  // ready



//----------------------------------------------------------------------------------------------------
var DataSummaryModule = (function () {

  var dataSummaryDiv;

  var outputDiv;
  var dataSetNamesOutputDiv;
  var thisModulesName = "datasets";
  var thisModulesOutermostDiv = "datasetsDiv";

  var tableElement;
  var tableRef;
  var datasetMenu;
  var selectedDataSet;
  var useThisDatasetButton;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";
  var passwordProtected = false;

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
  sendSelectionsMenu = hub.configureSendSelectionMenu("#datasetsSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

  hub.disableButton(sendSelectionsMenu);

  $(window).resize(handleWindowResize);
  datasetMenu = $("#datasetMenu");
  datasetMenu.change(selectManifest);

  dataSetNamesOutputDiv = $("#dataSetNamesOutputDiv");
  dataSummaryDiv = $("#dataSummaryOutputDiv");

  useThisDatasetButton = $("#selectDatasetButton");
  useThisDatasetButton.button();
  hub.disableButton(useThisDatasetButton);
  useThisDatasetButton.click(specifyCurrentDataset);

  outputDiv = $("#dataSummaryOutputDiv");
  tableElement = $("#datasetsManifestTable");
      
    // if no login tab is present, then allow unrestricted choice of datasets.
    // if it IS present, then that tab will control this.

  var loginRequired = $("#loginDiv").length === 1;
  console.log("loginRequired? " + loginRequired);

  if(!loginRequired){
    console.log(" enabling datasetMenu");
    hub.enableButton($("#datasetMenu"));
    }
  else{
    console.log(" disabling datasetMenu");
    hub.disableButton($("#datasetMenu"));
    }

   if(hub.socketConnected())
      populateDataSetMenu();
   else
     hub.addSocketConnectedFunction(populateDataSetMenu);

} // initializeUI
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
   $("#datasetsStatusDiv").text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  $("#"+thisModulesOutermostDiv).width($(window).width() * 0.95);
//  $("#"+thisModulesOutermostDiv).height($(window).height() * 0.95);

//  console.log("  div: " + outputDiv.width());
//  console.log("  tbl before: " + tableElement.width());
//  tableElement.width($(window).width() * 0.50);
//  console.log("  tbl after: " + tableElement.width());

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   var cmd = "sendSelectionTo_" + destination;
   payload = "dummy payload";
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//----------------------------------------------------------------------------------------------------
function selectManifest(event)
{
   selectedDataSet = datasetMenu.val();
   console.log("dataset '" + selectedDataSet + "'");

   if(selectedDataSet === ""){
      $("#datasetInstructions").css("display", "block")
      $("#datasetsManifestTable").css("display", "none")
      hub.disableButton(useThisDatasetButton);
      }
    else{
      $("#datasetInstructions").css("display", "none")
      $("#datasetsManifestTable").css("display", "block")      
      requestDataSetSummary(selectedDataSet);
    }

} // selectManifest
//----------------------------------------------------------------------------------------------------
function populateDataSetMenu()
{
   console.log("Module.datasets, entering populateDataSetMenu");

   console.log("      socket connected? " + hub.socketConnected());
   console.log("=== datasetMenu ready, now issuing populateDataSetMenu request to server");
   var msg = {cmd: "getDataSetNames",  callback: "handleDataSetNames", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // populateDataSetMenu
//----------------------------------------------------------------------------------------------------
function handleDataSetNames(msg)
{
   console.log("=== handleDataSetNames");
   
   var dataSetNames = msg.payload.datasets;
   console.log("dataSetNames length: " + dataSetNames.length);
   console.log("dataSetNames: " + JSON.stringify(dataSetNames));

   var passwordProtected = msg.payload.passwordProtected;

   if(!Array.isArray(dataSetNames))
      dataSetNames = [dataSetNames];

   for(var i=0; i < dataSetNames.length; i++){
      var s = dataSetNames[i];
      datasetMenu.append("<option value='" + s + "'>" + s + "</option>");
      }

  //if(passwordProtected)
  //   hub.disableButton($("#datasetMenu"));


} // handleDataSetNames
//----------------------------------------------------------------------------------------------------
function requestDataSetSummary(dataSetName)
{
   console.log("=== requestDataSetSummary");

   var msg = {cmd: "getDataManifest",  callback: "displayDataManifest", status: "request", 
              payload: dataSetName};

   hub.send(JSON.stringify(msg));

} // requestDataSetSummary
//----------------------------------------------------------------------------------------------------
function displayDataManifest(msg)
{
   var payload = msg.payload;
   var tblColumnNames = payload.colnames;

   var columnTitles = [];
     // convert simple strings to array of objects, each an sTitle
   for(var i=0; i < tblColumnNames.length; i++){
      columnTitles.push({sTitle: tblColumnNames[i]});
      }
     
   if(typeof(tableRef) != "undefined"){
      tableRef.destroy();
      tableElement.empty();
      }


   $(tableElement).ready(function() {
      tableRef = tableElement.DataTable({
        //sDom: 't',
        aoColumns: columnTitles,
        //scrollX: true,
        bPaginate: false,
        bFilter: false, 
        bAutoWidth: true,
        bSort: false,
        bInfo: false
        }); // dataTable

     tableRef = $("#datasetsManifestTable").DataTable();

     tableRef.rows.add(payload.mtx).draw();
     // tableRef.fnAddData(payload.mtx);

     $('#datasetsManifestTable tbody').on( 'click', 'tr', function (){ 
         console.log("=== click");
         var category = $('td', this).eq(0).text();
         var subcategory = $('td', this).eq(1).text();
         if($(this).hasClass("selected")){
            $(this).removeClass('selected');
            hub.disableButton(sendSelectionsMenu);
            }
         else{
            tableRef.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            hub.enableButton(sendSelectionsMenu);
            console.log("selected " + category + ", " + subcategory);
            }
         });

     handleWindowResize();
     hub.enableButton(useThisDatasetButton);
     postStatus("manifest table displayed");
     }); // tableElement.ready

} // displayDataManifest
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset()
{
   console.log("Module.datasets 'Use Dataset' button clicked, specifyCurrentDataset: " + selectedDataSet);

   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: selectedDataSet};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   console.log("--- Module.datasets:  datasetSpecified");

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function test(dataSetName)
{
   console.log("Module.datasets test, on datasetName: '" + dataSetName + "'");

   QUnit.test("choose dataset '" + dataSetName + "'", function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = dataSetName;
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value})

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset)
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         //testLoadPatientHistoryTable();
         }, 5000);
      });


} // test
//----------------------------------------------------------------------------------------------------
function moduleInit()
{
  hub.addOnDocumentReadyFunction(initializeUI);
  //hub.addSocketConnectedFunction(populateDataSetMenu);
  hub.addMessageHandler("handleDataSetNames", handleDataSetNames);
  hub.addMessageHandler("displayDataManifest", displayDataManifest);
  hub.addMessageHandler("datasetSpecified", datasetSpecified);

} // moduleInit
//----------------------------------------------------------------------------------------------------
return{
   init: moduleInit,
   test: test
   }; // DataSummaryModule return value

//----------------------------------------------------------------------------------------------------
}); // DataSummaryModule

var dataSummaryModule = DataSummaryModule();
dataSummaryModule.init();
hub.registerModule("Datasets", dataSummaryModule);

//----------------------------------------------------------------------------------------------------
// move these all back inside module scope when debugging is done

var cwMarkers;
var markersTester;

//----------------------------------------------------------------------------------------------------
var markersAndTissuesModule = (function () {

  var statusDiv; 
  var cyDiv;
  var searchBox;
  var hideEdgesButton, showEdgesButton, showAllEdgesButton, clearSelectionButton, sfnButton;
  var nodeRestriction = [];
  var subSelectButton;
  var helpButton;
  var infoMenu;
  var edgeTypeSelector;
  var mouseOverReadout;
  var graphOperationsMenu;
  var tumorCategorizationsMenu;
  var tumorCategorizationsMenuTitle = "Tumor Groups...";
  var sendSelectionsMenu;
  var layoutMenu;
  var thisModulesName = "MarkersAndPatients";
  var thisModulesOutermostDiv = "markersAndPatientsDiv";
  var userID = "NA";

      // sometimes a module offers multiple selection destinations.
      // usually there is just one:

  var selectionDestinations = [thisModulesName];


  var sendSelectionsMenuTitle = "Send selection...";

     // the user may specify that only certain tumors, and/or certain genes
     // are to be used in any subsequent network operations -- especially
     // "show edges from selected nodes"
     // to experiment with this capability, there are two new net ops menu
     // options, which assign zero or more selected nodes to these variables,
     // which are then used (if defined) to limit the subsequent network
     // operation


//--------------------------------------------------------------------------------------------
function initializeUI ()
{

  cyDiv = $("#cyMarkersDiv");
  statusDiv = $("#markersAndPatientsStatusDiv");

  sendSelectionsMenu = hub.configureSendSelectionMenu("#cyMarkersSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                      sendSelectionsMenuTitle);

  tumorCategorizationsMenu = $("#cyMarkersTumorCategorizationsMenu");
  tumorCategorizationsMenu.empty();
  tumorCategorizationsMenu.append("<option>" + tumorCategorizationsMenuTitle + "</option>");
  tumorCategorizationsMenu.change(requestTumorCategorization);

  graphOperationsMenu = $("#cyMarkersOperationsMenu");
  graphOperationsMenu.change(doGraphOperation);
  graphOperationsMenu.empty();
  graphOperationsMenu.append("<option>Network Operations...</option>");

  var operations = ["Show All Edges",
                    "Show Edges from Selected Nodes",
                    "Hide All Edges",
                    //"Connect to First Neighbors",
                    "Invert Node Selection",
                    "Clear Selections",
                    "Select All Connected Nodes",
                    "Select All Nodes with Selected Edges",
                    "Hide Unselected Nodes",
                    "Show All Nodes",
                    "Restrict Next Ops to Selected Nodes"];

  for(var i=0;i< operations.length; i++){
     var optionMarkup = "<option>" + operations[i] + "</option>";
     graphOperationsMenu.append(optionMarkup);
     } // for 


   layoutMenu = $("#markerLayouts");
   layoutMenu.change(performLayout);

   showEdgesButton = $("#cyMarkersShowEdgesButton");
   showEdgesButton.click(showEdges);
   
   showAllEdgesButton = $("#cyMarkersShowAllEdgesButton");
   showAllEdgesButton.click(showAllEdges);

   sfnButton = $("#cyMarkersSFNButton");
   sfnButton.click(selectFirstNeighbors);
   clearSelectionButton = $("#cyMarkersClearSelectionButton");
   clearSelectionButton.click(clearSelection);

   hideEdgesButton = $("#cyMarkersHideEdgesButton");
   hideEdgesButton.click(hideAllEdges);


   searchBox = $("#markersAndTissuesSearchBox");

   edgeTypeSelector = $("#markersEdgeTypeSelector");
   mouseOverReadout = $("#markersAndTissuesMouseOverReadout");
   configureCytoscape();
   $(".chosen-select").chosen();
   $(window).resize(handleWindowResize);

   subSelectButton = $("#markersSubSelectButton");
   subSelectButton.click(subSelectNodes);

  if(hub.socketConnected())
     runAutomatedTestsIfAppropriate();
  else
     hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);

   setInterval(function(){
      var count = cwMarkers.nodes("node:selected").length;
      var disable = (count === 0);
      sendSelectionsMenu.attr("disabled", disable);
      subSelectButton.attr("disabled", disable);
      }, 500);
 
} // initializeUI
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function configureLayoutsMenu(layoutMenu){

   console.log("--- configureLayoutsMenu");
   layoutMenu.append("<option>Layouts...</option>");
   layoutMenu.append("<option> Save Current</option>");

   var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
          var result = {id:n.id(), position:n.position()};
          return (result);  
          }) // map
       ); // stringify

   localStorage.markersDefault = defaultLayout;

   var existingLayouts = Object.keys(localStorage);
   for(var i=0; i < existingLayouts.length; i++){
      if(existingLayouts[i].match("markers") !== null){
        layoutMenu.append("<option>" + existingLayouts[i] + "</option>");
        }
      } // for i

} // configureLayoutsMenu
//----------------------------------------------------------------------------------------------------
function performLayout(event){

  var chosenLayoutName = layoutMenu.val();

  if(chosenLayoutName == "Save Current"){
     var uniqueNumber = Math.floor(new Date().getTime()/1000);   // number of seconds since 1970
     newName = "markers." + (uniqueNumber - 1420414900);    // since today, very roughly
     var positions = cwMarkers.nodes().map(function(n){
           var result = {id:n.id(), position:n.position()};
           return(result);
           }); // map
     currentLayout = JSON.stringify(positions);
     localStorage[newName] = currentLayout;
     layoutMenu.append("<option>" + newName + "</option>");
     layoutMenu.val(newName);
     return;
     } // if "Save Current"

  if(Object.keys(localStorage).indexOf(chosenLayoutName) >= 0){
     var newLayout;
     newLayout = JSON.parse(localStorage[chosenLayoutName]);
     cwMarkers.nodes().positions(function(i, node){
        return{x: newLayout[i].position.x, y:newLayout[i].position.y};
         });
     } // if requested layout name is recognized
  
  layoutMenu.val("Layouts...");   // restore the title

} // performLayout
//--------------------------------------------------------------------------------------------
function sendSelection()
{
   destinationModule = sendSelectionsMenu.val();
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }
   metadata = {};
   sendSelectionToModule(destinationModule, nodeNames, metadata);
   sendSelectionsMenu.val("Send Selection...");

} // sendSelectionsMenuChanged
//--------------------------------------------------------------------------------------------
function configureCytoscape ()
{
  cwMarkers = $("#cyMarkersDiv");
  cwMarkers.cytoscape({
     boxSelectionEnabled: true,
     showOverlay: false,
     minZoom: 0.01,
     maxZoom: 8.0,
     layout: {
       name: "preset",
       fit: true
       },
   ready: function() {
      console.log("cwMarkers ready");
      cwMarkers = this;
      cwMarkers.on('mouseover', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val(node.id());
         });
      cwMarkers.on('mouseout', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val("");
         });
      cwMarkers.on('mouseover', 'edge', function(evt){
         var edge = evt.cyTarget;
         var d = edge.data();
         var msg = d.edgeType + ": " + d.source + " - " + d.target;
         var mutation = d.mutation;
         if(typeof(mutation) == "string")
            msg = mutation + " " + msg;
         mouseOverReadout.val(msg);
         });

      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      searchBox.keydown(doSearch);

      console.log("cwMarkers.reset");
      cwMarkers.reset();
      handleWindowResize();
      cwMarkers.edges().selectify(); // this seems to hold through session, visibility notwithstanding
      //hideAllEdges();
      configureLayoutsMenu(layoutMenu);
      cwMarkers.fit(50);
      }, // cy.ready
     }) // .cytoscape
    .cytoscapePanzoom({ });   // need to learn about options

} // configureCytoscape
//----------------------------------------------------------------------------------------------------
function handleWindowResize ()
{
   cyDiv.width(0.95 * $(window).width());
   cyDiv.height(0.8 * $(window).height());
   cwMarkers.resize();
   cwMarkers.fit(50);

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
// there are often subgroups among a selected node.
// here we opreate only on those distinguished by different node border color
// the dialog posted here provided interactive select/deselect of those originally
// selected nodes, by color.
// this function could be made smarter by being made avaialble (via the subselect button) only
// if multiple border colors are found within the currently selected nodes
//
function subSelectNodes()
{
  var selectedNodes = cwMarkers.nodes("node:selected");
  var borderColors =  jQuery.unique(selectedNodes.map(function(node){return (node.style("border-color"));}));
  console.log(JSON.stringify(borderColors));

  var content = "<form action=''>";
  for(i=0; i < borderColors.length; i++){
     var color = borderColors[i];
     var e = "<input type='checkbox' class='markersSubSelectRadioButton' name='" + color + "' checked> " + color + "<br>";
     content = content + e;
     }
  content = content + "</form>";
  button = "<br><br><button id='markersSubSelectCloseButton'>Close</button>";

  content = content + button;

  var dialog =  $('<div id="markersSubSelectDialog" />').html(content).dialog();

  $("#markersSubSelectCloseButton").click(function(){
     console.log("close dialog");
     $("#markersSubSelectDialog").remove();
     });

  $(".markersSubSelectRadioButton").click(function(e) {
      console.log("radio!"); 
      console.log(this.name + " " + this.checked);
      var color = this.name;
      var selectSubset = this.checked;
      var subsetNodes = selectedNodes.filterFn(function(node) {return(node.style("border-color") == color);});
      if(selectSubset)
         subsetNodes.select();
      else
         subsetNodes.unselect();
      }); // radio button click

} // subSelectNodes
//----------------------------------------------------------------------------------------------------
function requestTumorCategorization()
{
  var categorizationName = tumorCategorizationsMenu.val();
  console.log("apply " + categorizationName);
  recordEvent(userID + " markersApplyTumorCategorization request");

  var msg = {cmd: "getSampleCategorization", callback: "markersApplyTumorCategorization",
             status: "request", payload: categorizationName};

  hub.send(JSON.stringify(msg));

  tumorCategorizationsMenu.val(tumorCategorizationsMenuTitle);

} // requestTumorCategorization
//----------------------------------------------------------------------------------------------------
function applyTumorCategorization(msg)
{
   console.log("=== applyTumorCategorization");
   var tumorsInGraph = cwMarkers.nodes("[nodeType='patient']");
   var tumorsInTable = msg.payload.rownames;
   var tbl = msg.payload.tbl;
   recordEvent(userID + " markersApplyTumorCategorization data received");

   tumorsInGraph.forEach(function(node, index){
      var nodeID = node.id();  // our convention is that this is the tumor name, eg, "TCGA.02.0014"
      var indexInTable = tumorsInTable.indexOf(nodeID);
      if(indexInTable >= 0){
         var cluster = tbl[indexInTable][0];
         node.data({subType: cluster});
         }
      else{
         node.data({subType: "unassigned"});
         }
       }); // forEach

  cwMarkers.style().update();
  recordEvent(userID + " markersApplyTumorCategorization complete");


} // applyTumorCategorization
//----------------------------------------------------------------------------------------------------
function doGraphOperation()
{
   var operation = graphOperationsMenu.val();

   switch(operation){
      case "Show All Edges":
         showAllEdges();
         break;
      case "Show Edges from Selected Nodes":
         //showEdgesFromSelectedNodes();
         showEdgesFromSelectedNodes();
         break;
      case "Hide All Edges":
         hideAllEdges();
         break;
      case "Invert Node Selection":
         invertSelection();
         break;
      case "Clear Selections":
         cwMarkers.filter('node:selected').unselect();
         break;
      case "Select All Connected Nodes":
         selectAllConnectedNodes();
         break;
      case "Select All Nodes with Selected Edges":
        selectAllNodesConnectedBySelectedEdges();
        break;
      case "Hide Unselected Nodes":
         cwMarkers.filter("node:unselected").hide();
         break;
      case "Show All Nodes":
         cwMarkers.filter('node:hidden').show();
         break;
      case "Restrict Next Ops to Selected Nodes":
         restrictNextOpsToSelectedNodes();
         break;
      default:
         console.log("unrecoginized graph operation requested from menu: " + operation);
      } // switch

      // restore menu to initial condition, with only title showing
   graphOperationsMenu.val("Network Operations...");

} // doGraphOperation
//----------------------------------------------------------------------------------------------------
function clearSelection ()
{
   cwMarkers.elements().unselect();
}
//----------------------------------------------------------------------------------------------------
function selectFirstNeighbors ()
{
  selectedNodes = cwMarkers.filter('node:selected');
  showEdgesForNodes(cwMarkers, selectedNodes);

}
//----------------------------------------------------------------------------------------------------
function invertSelection ()
{
   selected = cwMarkers.filter("node:selected");
   unselected = cwMarkers.filter("node:unselected");
   selected.unselect();
   unselected.select();
}
//----------------------------------------------------------------------------------------------------
function hideAllEdges ()
{
     // hide all edges besides chromsome edges
  cwMarkers.edges().fnFilter(function(edge) {
     return(edge.data("edgeType") != "chromosome");
     }).hide();

} // hideAllEdges
//----------------------------------------------------------------------------------------------------
function showAllEdges ()
{
   var edgeTypesToDisplay = edgeTypeSelector.val();

   console.log("edgeTypeToDisplay: " + edgeTypesToDisplay);

   if(edgeTypesToDisplay === null){
      return;
      }

   for(var e=0; e < edgeTypesToDisplay.length; e++){
      var type =  edgeTypesToDisplay[e];
      selectionString = '[edgeType="' + type + '"]';
      //console.log(" showAllEdges selection string: " + selectionString);
      cwMarkers.edges(selectionString).show();
      } // for e

} // showAllEdges
//----------------------------------------------------------------------------------------------------
function zoomSelected()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 100);
}
//----------------------------------------------------------------------------------------------------
function handleIncomingIdentifiers(msg)
{
   console.log("Module.markers, handleIncomingIdentifiers");
      // expect 3 payload fields: value, count, source
   var ids = msg.payload.value; 
   if(typeof(ids) == "string")
      ids = [ids];
   //intersectingIDs = hub.intersectionOfArrays(ids, nodeNames())
   intersectingIDs = hub.intersectionOfArrays(ids, nodeIDs());
   console.log("found ids: " + intersectingIDs.length);

   if(intersectingIDs.length > 0)
      selectNodesByID(intersectingIDs);
   else{
      errorMessage = "No overlap with genes or tissue sample IDs:  <br><br>" +
                      ids.join(", ");
      title = ids.length + " unrecognized identifiers";
      $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
      }

   hub.raiseTab(thisModulesOutermostDiv);

} // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
  // run all that should happen when this module receives an incoming selection of patientIDs
function demoMarkersIncomingSelectionOfIDs()
{

   names = ["TCGA.06.0210", "TCGA.02.0106", "TCGA.02.0111",
            "TCGA.06.0194", "TCGA.06.0164", "TCGA.06.0409", "TCGA.02.0004",
            "TCGA.02.0051", "TCGA.08.0390", "TCGA.02.0025", "TCGA.08.0392",
            "TCGA.02.0079", "TCGA.12.0620", "TCGA.08.0373", "TCGA.06.0645",
            "TCGA.06.0192", "TCGA.12.0776", "TCGA.12.0778", "TCGA.06.0750",
            "TCGA.06.0878", "TCGA.14.0789", "TCGA.06.0881", "BCL11A",
            "BRCA1", "MDM2", "PIK3R1", "ABCA1", "CDK6", "CNTRL", "FH",
            "IFNA1", "LMO2", "PRKCA", "RELA", "STK11", "ZEB1", "CCNB1IP1",
            "CREB3L1", "GDF2", "OR4K2", "PRKCH", "WAS"];

   subset = [];
   for(var i=0; i < 10; i++)
     subset.push(names[getRandomInt(0, names.length -1)]);

   selectNodes(subset);

} // demoIncomingSelectionOfPatientIDs
//----------------------------------------------------------------------------------------------------
function allNodeIDs()
{
   ids = [];
   allNodes = cwMarkers.nodes();

   for(i=0; i < allNodes.length; i++)
       ids.push(allNodes[i].data("id"));

   return(ids);

} // allNodeIDs
//----------------------------------------------------------------------------------------------------
function showEdges()
{
   hideAllEdges();   // is this wise?

   var edgeTypesToDisplay = edgeTypeSelector.val();
   if(edgeTypesToDisplay === null){
      hideAllEdges();
      return;
      }

   var selectedNodes = selectedNodeIDs(cwMarkers);

   //console.log(" newEdgeTypeSelection (" + edgeTypesToDisplay.length + 
   //            "), selectedNodes: " + selectedNodes.length);

   if(selectedNodes.length > 0) { // show edges to and from all selected nodes
     showEdgesForNodes(cwMarkers, selectedNodes);
     }

} // showEdges
//----------------------------------------------------------------------------------------------------
// function showEdgesFromSelectedNodes()
// {
//    var selectedNodes = cwMarkers.filter('node:selected');
// 
//       // break out the selected nodes into the two groups we care about: 
//       //    genes & tumors (aka, patients)
// 
//    var tumorNodes = selectedNodes.filter("[nodeType='patient']");
//    var geneNodes  = selectedNodes.filter("[nodeType='gene']");
// 
//       // if any tumor node restriction is in force, only 
//       // the intersecton of that with our current selection is kept
// 
//    if(tumorNodeRestriction.length > 0){
//       var correctedTumorNodes = [];
//       tumorNodes.forEach(function(node){
//         if(tumorNodeRestriction.indexOf(node.id()) >= 0){
//            console.log("match!");
//            correctedTumorNodes.push(node);
//           } // if matched
//         }); // forEach
//      console.log("some tumor nodes restricted, some selected");
//      tumorNodes = correctedTumorNodes;   // 0 or more
//      } // some tumor nodes restricted
// 
//    if(geneNodeRestriction.length > 0){
//       var correctedGeneNodes = [];
//       geneNodes.forEach(function(node){
//        if(geneNodeRestriction.indexOf(node.id()) >= 0){
//          console.log("match!");
//          correctedTumorNodes.push(node);
//           } // if matched
//        }); // forEach
//     console.log("some gene nodes restricted, some selected");
//     geneNodes = correctedGeneNodes;   // 0 or more
//     } // some gene node restriction
//        
//    selectedNodes = tumorNodes;
//    geneNodes.forEach(function(node){selectedNodes.push(node)});
// 
//    if(selectedNodes.length == 0) {
//       return;
//       }
// 
//       // "closed" means that we have tumors and genes specified, and
//       // only want to find connections among them
// 
//    //var closedCandidates = FALSE;
// 
//    //if(tumorNodes.length > 0 & geneNodes.length > 0)
//    //   closedCandidates = TRUE;
// 
//    debugger;
//    showEdgesForNodes(cwMarkers, selectedNodes);
// 
// } // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 50);

}
//----------------------------------------------------------------------------------------------------
function selectedNodeIDs(cw)
{
   ids = [];
   noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     ids.push(noi[n].data('id'));
     }
  return(ids);

} // selectedNodeIDs
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }
  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
function showEdgesFromSelectedNodes()
{
   var targets = nodeRestriction;
   var selectedNodes = cwMarkers.nodes("node:selected");
   var neighbors = selectedNodes.neighborhood();
   var candidateEdges = neighbors.filterFn(function(e){
       if(e.isEdge()) return (e);
       });

   candidateEdges = candidateEdges.fnFilter(function(edge){
      return(edgeTypeSelector.val().indexOf(edge.data("edgeType")) >= 0);
      });

   if(targets.length === 0){
      candidateEdges.show();
      return;
      }

   function intersects(array1, array2){
      var size = array1.filter(function(n) {return (array2.indexOf(n) != -1);}).length;
      return(size > 0);
      }

   candidateEdges.filterFn(function(edge){
      var actual=edge.connectedNodes().map(function(node){return node.id();});
      return(intersects(actual, targets));
       }).show();

} // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function selectSourceAndTargetNodesOfEdges(cw, edges)
{
  //var eoi = cwMarkers.filter('edge:visible');
  var notChromosomal = function(edge){return(edge.data("edgeType") !== "chromosome");};
  eoi = edges.filterFn(notChromosomal);

  var filterStrings = [];

  for(var i=0; i < eoi.length; i++){
     edge = eoi[i];
     targetID = edge.target().data("id");
     sourceID = edge.source().data("id");
     var sourceFilterString = '[id="' + sourceID + '"]';
     var targetFilterString = '[id="' + targetID + '"]';
     filterStrings.push(sourceFilterString);
     filterStrings.push(targetFilterString);
     } // for i

   var nodesToSelect = cw.nodes(filterStrings.join());
   nodesToSelect.select();

} // selecteSourceAndTargetNodesOfEdge
//----------------------------------------------------------------------------------------------------
  // todo: massive inefficiencies here
function showEdgesForNodes(cw, nodes)
{

  var edgeTypes = edgeTypeSelector.val();
  console.log("=== showEdgesForNodes, edgeType count: " + edgeTypes.length);
  console.log(edgeTypes);

  if(edgeTypes.length === 0)
      return;

  var filterStrings = [];

  $("body").toggleClass("wait");

  setTimeout(function(){
     for(var e=0; e < edgeTypes.length; e++){
        var edgeType = edgeTypes[e];
        for(var n=0; n < nodes.length; n++){
          var nodeID = nodes[n].data("id");
          var sourceFilterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
          var targetFilterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
          filterStrings.push(sourceFilterString);
          filterStrings.push(targetFilterString);
          } // for n
        } // for e

      console.log("filterString count: " + filterStrings.length);
      filter = filterStrings.join();
      console.log("filter created, about to apply...");
      var existingEdges = cw.edges(filter);
      console.log("filtering complete");
      if(existingEdges.length > 0) {
         console.log("about to show edges");
         existingEdges.show();
         console.log("edges shown...");
         }
     }, 1000); // setTimeout

  $("body").toggleClass("wait");

} // showEdgesForNodes
//----------------------------------------------------------------------------------------------------
function selectAllConnectedNodes()
{
    var selectedEdges = cwMarkers.filter("edge:visible");
    selectedEdges = selectedEdges.filterFn(function(e){return (e.data("edgeType") !== "chromosome");});
    if(selectedEdges.length > 0)
       selectSourceAndTargetNodesOfEdges(cwMarkers, selectedEdges);

} // selectAllConnectedNodes
//----------------------------------------------------------------------------------------------------
function selectAllNodesConnectedBySelectedEdges()
{
    edges = cwMarkers.filter("edge:selected");
    console.log(" selected edge count: " + edges.length);
    if(edges.length === 0)
      return;
    for(var e=0; e < edges.length; e++){
       selectNodes(edges[e].target().data("name"));
       selectNodes(edges[e].source().data("name"));
       } // for e

} //selectAllNodesConnectedBySelectedEdges
//----------------------------------------------------------------------------------------------------
function showEdgesForSelectedNodes(cw, edgeTypes)
{
   var nodeIDs = selectedNodeIDs(cw);
   for(var n=0; n < nodeIDs.length; n++){
      nodeID = nodeIDs[n];
      for(var e=0; e < edgeTypes.length; e++){
         edgeType = edgeTypes[e];
         filterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         filterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         } // for e
      } // for n

} // showEdgesForSelectedNodes
//----------------------------------------------------------------------------------------------------
function restrictNextOpsToSelectedNodes()
{
  var nodes = cwMarkers.nodes("node:selected"); // .filter("[nodeType='gene']");
  if(nodes.length === 0){
     nodeRestriction = [];
     }
  else{
     nodeRestriction = nodes.map(function(node){return (node.id());});
     }

} // restrictNextOpsToSelectedNodes
//----------------------------------------------------------------------------------------------------
function nodeNames()
{
  var nodes = cwMarkers.filter("node:visible");
  var result = [];
  for(var i=0; i < nodes.length; i++){
    result.push(nodes[i].data().label);
    } // for i

  return(result);

} // nodeNames
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
   return(cwMarkers.nodes().map(function(node){return (node.id());}));
}
//----------------------------------------------------------------------------------------------------
function upperCaseNodeIDs()
{
   return(nodeIDs().map(function(node){return(node.toUpperCase());}));
}
//----------------------------------------------------------------------------------------------------
// todo: build up the filter string first, then send it all at once
function selectNodes(nodeNames)
{
  console.log("Module.markers::selectNodes");
  //console.log(nodeNames);

  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  var allNodes = cwMarkers.nodes().map(function(n){return (n.id());});
  var allNodesUpperCase = allNodes.map(function(name){return (name.toUpperCase());});

  for(var i=0; i < nodeNames.length; i++){
    var nodeName = nodeNames[i].toUpperCase();  // depends upon this conv
    var index = allNodesUpperCase.indexOf(nodeName);
    if(index >= 0){
      var actualNodeID = allNodes[index];
      var s = "cwMarkers.filter('node[id=\"" + actualNodeID + "\"]').select()";
       //console.log("markers selectNodes: " + s);
       eval (s);
       } // if found, index >= 0
    } // for i

} // selectNodes
//----------------------------------------------------------------------------------------------------
   // todo: build up the filter string first, then send it all at once
function selectNodesByID(nodeIDs) {

  if(typeof(nodeIDs) == "string")   // trap scalar, but expect and support arrays
     nodeIDs = [nodeIDs];

  console.log("about to select nodes by id: " + nodeIDs.length);
  console.log(nodeIDs);

  for(var i=0; i < nodeIDs.length; i++){
    s = "cwMarkers.filter('node[id=\"" + nodeIDs[i] + "\"]').select()";
    console.log(s);
    eval (s);
    } // for i

} // selectNodesByID
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
   var keyCode = e.keyCode || e.which;

   if (keyCode == 13) {
      var searchString = searchBox.val().toUpperCase();
      console.log("searchString: " + searchString);
      var idsActual = nodeIDs();
      var idsUpper = upperCaseNodeIDs();
      var hits = idsUpper.filter(function(id) {return(id.startsWith(searchString));});
      var hitIndices = hits.map(function(hit) {return(idsUpper.indexOf(hit));});
      var hitsActual = hitIndices.map(function(hit) {return(idsActual[hit]);});
      selectNodes(hitsActual);
      } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function displayMarkersNetwork(msg)
{
   console.log("--- Module.markers: displayMarkersNetwork");
   //console.log(msg)
   if(msg.status == "success"){
      console.log("nchar(network): " + msg.payload.length);
      s = msg.payload;
      XXX = msg.payload;
      console.log("      1:40: " + s.substring(1, 40));
      var json = JSON.parse(msg.payload);
      cwMarkers.remove(cwMarkers.edges());
      cwMarkers.remove(cwMarkers.nodes());
      console.log(" after JSON.parse, json.length: " + json.length);
      console.log("  about to add json.elements");
      cwMarkers.add(json.elements);
      console.log("  about to add  json.style");
      cwMarkers.style(json.style);
      console.log("   hiding edges");
      cwMarkers.edges().hide();
      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      cwMarkers.nodes().unselect();
        // map current node degree into a node attribute of that name
      cwMarkers.nodes().map(function(node){node.data({degree: node.degree()});});

      var edgeTypes = hub.uniqueElementsOfArray(cwMarkers.edges().map(function(edge){
                               return(edge.data("edgeType"));}
                               ));
      updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
      cwMarkers.fit(20);
      var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
                                         return({id:n.id(), position:n.position()});}));
      localStorage.markersDefault = defaultLayout;
      postStatus("markers network displayed");
      recordEvent(userID + " display markers network complete");
      }
   else{
     console.log("displayMarkersNetwork error: " + msg.payload);
     }

} // displayMarkersNetwork
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// ensure that only edgeTypes in current network are offered in the selection widget
function updateEdgeSelectionWidget(edgeTypes)
{
     // loop over currently offered edge types
   var options = $("#markersEdgeTypeSelector").children();
   for(var i=0; i < options.length; i++){
      var optionElement = options[i];
      var optionValue = optionElement.value;
      var found = jQuery.inArray(optionValue, edgeTypes) >= 0;
      console.log("checking option '" + optionValue + "':  " + found);
      if(!found){
         console.log("  deleting selector option " + optionValue);
         $("#markersEdgeTypeSelector option[value='" + optionValue + "']").remove();
         } // unrecognized edge type
      }
   $("#markersEdgeTypeSelector").trigger("chosen:updated");

} // updateEdgeSelectionWidget
//----------------------------------------------------------------------------------------------------
function recordEvent(payload)
{
   console.log("about to recordEvent: " + payload);

   hub.send(JSON.stringify({cmd: "recordEvent", callback:"", status:"request", payload: payload}));

} // recordEvent
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the g.markers.json network from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

   recordEvent(userID + " display markers network request ");
   var newMsg = {cmd: "getMarkersNetwork",  callback: "displayMarkersNetwork", status: "request", payload: datasetName};
   hub.send(JSON.stringify(newMsg));

   recordEvent(userID + " getSampleCategorizationNames ");

   var msg2 = {cmd: "getSampleCategorizationNames", callback: "configureSampleCategorizationMenu",
               status: "request", payload: ""};

   hub.send(JSON.stringify(msg2));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function configureSampleCategorizationMenu(msg)
{
   console.log("=== configureSampleCategorizationMenu");
   //console.log(msg.payload);
   tumorCategorizationsMenu.empty();
   var categorizations = msg.payload;

   if(typeof categorizations == "string") 
   	 categorizations = [categorizations];

   var titleOption = "Tumor Groups...";

   tumorCategorizationsMenu.append("<option>" + titleOption + "</option>");

   for(var i=0; i < categorizations.length; i++){
     tumorCategorizationsMenu.append("<option>" + categorizations[i] + "</option>");
     } // for i

   tumorCategorizationsMenu.val(titleOption);
   recordEvent(userID + " getSampleCategorizationNames complete");

} // configureSampleCategorizationMenu
//----------------------------------------------------------------------------------------------------
function gbmLggDzSpecificTests()
{
   QUnit.test("markersAndSamples: basic network test", function(assert){
      console.log("============= starting basic network test");
      assert.expect(2);
      console.log("about to check node count");
      assert.ok(cwMarkers.nodes().length > 1500);
      console.log("about to check edge count");
      assert.ok(cwMarkers.edges().length > 13000);
      console.log("end of test");
      });

  QUnit.test("markersAndSamples: select EGFR", function(assert){
     cwMarkers.nodes().unselect();
     assert.ok(cwMarkers.filter("node:selected").length === 0);
     cwMarkers.$("#EGFR").select();
     assert.ok(cwMarkers.filter("node:selected").length === 1);
     });


  QUnit.test("markersAndSamples: choose edge types", function(assert){
     edgeTypes = $("#markersEdgeTypeSelector option").map(function(opt){return(this.value);});
     var desiredEdgeType = "chromosome";

     if($.inArray(desiredEdgeType, edgeTypes) < 0){
        alert("cannot run tests:  " + desiredEdgeType + " edgeType not available");
        return;
        }

     $("#markersEdgeTypeSelector").val(desiredEdgeType);
     $("#markersEdgeTypeSelector").trigger("change");
     console.log("=== edge type selected: " + $("#markersEdgeTypeSelector").val());
     assert.equal($("#markersEdgeTypeSelector").val(), desiredEdgeType);
     assert.equal(cwMarkers.filter("node:selected").length, 1);
       // now restore the original settings. 
     $("#markersEdgeTypeSelector").val(["chromosome", "mutation", "cnGain.2", "cnLoss.2", "cnGain.1", "cnLoss.1"]);
     $("#markersEdgeTypeSelector").trigger("change");
     });

  QUnit.test("markersAndSamples: select chrom edges from EGFR", function(assert){
      var desiredAction = "Show Edges from Selected Nodes";
      var actions = $("#cyMarkersOperationsMenu option").map(function(x) {return(this.value);});

      if($.inArray(desiredAction, actions) < 0){
         alert("cannot run tests:  " + desiredAction + " not available");
         return;
         }

     cwMarkers.edges().hide();
     assert.equal(cwMarkers.filter("edge:visible").length, 0);
     $("#cyMarkersOperationsMenu").val(desiredAction);
     $("#cyMarkersOperationsMenu").trigger("change");
     assert.expect(1); // specify number of assertions which should run
     setTimeout(function() {  // takes a little while for the edge to be rendered
        assert.equal(cwMarkers.filter("edge:visible").length, 1);
        }, 2000);
     });


  QUnit.test("markersAndSamples: search and select EGFR", function(assert){
     cwMarkers.nodes().unselect();
     assert.equal(cwMarkers.filter("node:selected").length, 0);
     var targetNode = "EGFR";
     $("#markersAndTissuesSearchBox").val(targetNode);
     var e = jQuery.Event("keydown");
     e.which = 13;  
     $("#markersAndTissuesSearchBox").trigger(e);
     var selectedNode = cwMarkers.filter("node:selected");
     assert.equal(selectedNode.length, 1);
     assert.equal(selectedNode.data().id, targetNode);
     });


} // gbmLggDzSpecificTests
//----------------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserId",  callback: "markersAssessUserIdForTesting", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   userID = msg.payload;
   userID = userID.toLowerCase();

   console.log("markersAndSamples/Module.js assesUserIdForTesting: " + userID);
   
   if(userID.indexOf("autotest") === 0){
      console.log("markersAndSamples/Module.js running tests for user " + userID);
      var datasetNames = $("#datasetMenu").children().map(function() {return $(this).val();}).get();
         // delete any empty strings
      datasetNames = datasetNames.filter(function(e) {return (e.length > 0);});
      markersTester.run(datasetNames);
      console.log("back from markersTester.run()");
      }

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
 return{
     init: function(){
        hub.addMessageHandler("sendSelectionTo_MarkersAndPatients", handleIncomingIdentifiers);
        hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
        hub.addMessageHandler("datasetSpecified", datasetSpecified);
        hub.addMessageHandler("displayMarkersNetwork", displayMarkersNetwork);
        hub.addMessageHandler("configureSampleCategorizationMenu", configureSampleCategorizationMenu);
        hub.addMessageHandler("markersApplyTumorCategorization", applyTumorCategorization);
        hub.addMessageHandler("markersAssessUserIdForTesting", assessUserIdForTesting);
        //hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);
        //hub.addDocumentReadyFunction(runAutomatedTestsIfAppropriate);
        hub.addOnDocumentReadyFunction(initializeUI);
       }
     };

   }); // markersAndTissuesModule
//----------------------------------------------------------------------------------------------------
markersModule = markersAndTissuesModule();
markersModule.init();

// markersAndSamples/Test.js
//------------------------------------------------------------------------------------------------------------------------
var MarkersAndSamplesTestModule = (function () {

       // for observing relatively small scale status changes: i.e., network loaded and displayed
       // the div watched here is in widget.html

    var markersAndSamplesStatusObserver = null;

       // to detect when the full test of a dataset is complete, so that the next dataset can be tested
       // the div watched here is in test.html
    var testStatusObserver = null;   // modified at the end of each dataset test

//------------------------------------------------------------------------------------------------------------------------
function runTests(datasetNames)
{
     // run through some repetitions of the test
     // condition the next test upon the completion of the preceeding one,
     // which is detected by a change to the "status div"
      
   //var datasetNames = $("#datasetMenu").children().map(function() {return $(this).val();}).get();
     // delete any empty strings
   //datasetNames = datasetNames.filter(function(e) {return (e.length > 0);});
   var datasetIndex = -1;
   
   var config = {attributes: true, childList: true, characterData: true};
   var target =  document.querySelector("#markersTestStatusDiv");

      // define the function called whenever the testStatusDiv changes,
      // which is our signal that the next test is ready to run.
      // the first test is kicked off when we -- after setting up and
      // configuring the observer -- manually (see below: "start testing")
      // change the target which the observer watches.
      // there may be a better way, but for now we delete and recreate
      // the observer at the end of each test.
      // note also that the next dataset is determined inside this function
      // and that the function refers to itself.

   var onMutation = function(mutations){
      mutation = mutations[0];
      testStatusObserver.disconnect();
      testStatusObserver = null;
      var id = mutation.target.id;
      var msg = $("#markersTestStatusDiv").text();
      console.log("test status changed, text: " + msg);
      datasetIndex++;
      if(datasetIndex < datasetNames.length){
         console.log("about to test dataset " + datasetNames[datasetIndex]);      
         if(datasetIndex < datasetNames.length)
            testLoadDataSetDisplayNetwork(datasetNames[datasetIndex]);
	 testStatusObserver = new MutationObserver(onMutation);
         testStatusObserver.observe(target, config);
	 }
      else{
         console.log("mutation observer function detected end of datasets");
	 }
      };

   testStatusObserver = new MutationObserver(onMutation);
   testStatusObserver.observe(target, config);

   $("#markersTestStatusDiv").text("start testing");

} // runTests
//------------------------------------------------------------------------------------------------------------------------
function showTests()
{
   hub.raiseTab("markersTestDiv");

  // $("#qunit").css({"display": "block"});

} // showTests
//------------------------------------------------------------------------------------------------------------------------
function hideTests()
{
   $("#qunit").css({"display": "none"});

} // hide
//------------------------------------------------------------------------------------------------------------------------
function testLoadDataSetDisplayNetwork(dzName)
{
   var testTitle = "testLoadDataSetDisplayNetwork";
   console.log(testTitle);

      // when our module receives the resulting 'datasetSpecified' msg, which includes the dataset's manifest
      // in its payload, it requests 
      //   - the markers network: to be displayed by cyjs
      //   - sampleCategorizationNames, to popbulate the dropdeon menu
      // when the network is loaded, the statusDiv is updated, which is detected here, and we
      // check to see that a reasonable number of nodes are contained in the loaded graph.
      // when those tests are over, we then cascade through a number of gui operations: search, node selections
      // network operations

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        hub.raiseTab("markersAndPatientsDiv");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#markersAndSamplesStatusDiv").text();
        QUnit.test("markersAndSamples loaded", function(assert) {
           var nodeCount = cwMarkers.nodes().length;
           var edgeCount = cwMarkers.edges().length;
           console.log("markersAndSamples loaded, with " + nodeCount + " nodes and " + edgeCount + " edges.");
           assert.ok(nodeCount > 10);
           assert.ok(edgeCount > 10);
           testSearch();
           });
        }); // new MutationObserver
      } // if null mutation observer


   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector("#markersAndPatientsStatusDiv");
   markersAndSamplesStatusObserver.observe(target, config);

   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload:  dzName};

   console.log("about to send specifyCurrentDataset msg to server: " + dzName);
   hub.send(JSON.stringify(msg));

} // testLoadDataSetThenProceed
//------------------------------------------------------------------------------------------------------------------------
// new approach
//   1) clear selection
//   2) find the node with highest degree
//   3) select that node
//   4) show edges, select all connected
//   5) make sure selected node code -1 is equal to degree of the original node
function testSearch()
{
   console.log("--- Test.markers testSearch");
   var searchBox = $("#markersAndTissuesSearchBox");
   var netOpsMenu = $("#cyMarkersOperationsMenu");
   var nodes = cwMarkers.nodes().filterFn(function(node){return (node.data("nodeType") === "patient");});
   var nodesByDegree = nodes.map(function(node){return {id:node.data("id"), degree:node.degree()};});
   var mySort = function(a,b) {return(b.degree - a.degree);};
   var mostConnectedNode = nodesByDegree.sort(mySort)[0];
   console.log("mostConnectedNode: " + JSON.stringify(mostConnectedNode));

   QUnit.test("markers testSearch", function(assert){
     netOpsMenu.val("Hide All Edges");
     netOpsMenu.trigger("change");
     assert.equal(cwMarkers.filter("node:selected").length, 0);
     searchBox.val(mostConnectedNode.id);
     searchBox.trigger(jQuery.Event("keydown", {which: 13}));
     assert.equal(cwMarkers.filter("node:selected").length, 1);
     netOpsMenu.val("Show Edges from Selected Nodes");
     netOpsMenu.trigger("change");
     netOpsMenu.val("Select All Connected Nodes");
     netOpsMenu.trigger("change");
     console.log("about to check for selected nodes");
     var expectedSelectionCount = mostConnectedNode.degree + 1; // include self
     assert.ok(cwMarkers.filter("node:selected").length == expectedSelectionCount);
     //testColorTumorsByClassification();
     recordEndOfTest();
     });

}  // testSearch
//------------------------------------------------------------------------------------------------------------------------
function testColorTumorsByClassification()
{
   var testTitle = "testColorTumorsByClassifictaion";
   console.log(testTitle);

      // TCGA.02.0033 is in all three of our current gbm-related, public, TCGA datasets

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        hub.raiseTab("markersAndPatientsDiv");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#markersAndSamplesStatusDiv").text();
        QUnit.test(title, function(assert) {
           assert.ok(10 === 10);
           });
        }); // new MutationObserver
      } // if null mutation observer


   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector("#markersAndPatientsStatusDiv");
   markersAndSamplesStatusObserver.observe(target, config);

   var dz = "TCGAbrain";
   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload:  dzName};

   hub.send(JSON.stringify(msg));

} // testColorTumors
//------------------------------------------------------------------------------------------------------------------------
function recordEndOfTest()
{
  console.log("end of test");
  $("#markersTestStatusDiv").text("test complete");

} // recordEndOfTest
//------------------------------------------------------------------------------------------------------------------------
function initialize()
{
   console.log("--- initializing markersAndSamples/Test.js");

} // initialize
//------------------------------------------------------------------------------------------------------------------------
return{
   init: initialize,
   run: runTests,
   show: showTests,
   hide: hideTests
   }; // module return value

//------------------------------------------------------------------------------------------------------------------------
}); // MarkersAndSamplesTestModule
markersTester = MarkersAndSamplesTestModule();



</script>

<body>

<div id="oncoscapeTabs">
   <ul>
     <li><a href="#datasetsDiv">Datasets</a></li>
     <li><a href="#markersAndPatientsDiv">Markers</a></li>
     <li><a href="#markersTestDiv">Tests</a></li>
   </ul>

<style>
</style>

<div id="datasetsDiv" style="height:auto">
  <div id="datasetsStatusDiv" style="display:none"></div>
  <div id="dataSummaryControlsDiv">
     <span id="selectDataSetMenuLabel" style="margin-left: 20px;">Available Datasets</span>
     <select type="button" id="datasetMenu" style="margin: 5px;"><option> </option></select>
     <button id="selectDatasetButton">Use Dataset</button>
	 <span id="loadingDatasetMessage" style="display:none; margin-left:10px">Loading Dataset...</span>
     <select type="button" id="datasetsSendSelectionsMenu" style="float:right; margin:15px; display: none"></select>
    <div id="oncoscapeLogo" style="float:right; margin-right:0.5em">	<img width="175" src="http://oncoscape.sttrcancer.org/oncoscape/images/oncoscape_logo_TM.png" alt="Oncoscape"/></div>
  </div>

   <div id="dataSetNamesOutputDiv" style="margin: 20px;"></div>

   <div id="dataSummaryOutputDiv" style="margin: 20px;overflow-x:auto">
      <div id="datasetInstructions">Please select a dataset from the above menu.</div>
      <table id="datasetsManifestTable" class="display" cellpadding="0" cellspacing="0" style="margin:0px; width:auto; display:none; border:none"></table>
   </div>
</div>

<style>

div {
   display: block;
   }

body.wait, body.wait *{
   cursor: wait !important;   
}

#markersAndPatientssDiv{
  }

button {font-size:10pt !important;}

#cyMarkersDiv {
  background-color: #FAFAFA;  // light gray
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  margin-top: 2px;
  margin-left: 0px;
  padding: 0px;
  }

#markersAndTissuesSearchBox{
  border: 1px solid #aaa;
  width: 80px;
  height: 20px;
  }

markersAndTissuesMouseOverReadout{
  border: 1px solid #aaa;
  width: 400px !important;
  height: 24px;
  font-size: 12pt !important;
  font-weight: bold;
  }


#cyMarkersClearSelectionButton #cyMarkersHideEdgesButton #cyMarkersShowEdgesButton #cyMarkersShowAllEdgesButton {
   font-size:8pt  !important;
   }

#markersAndTissuesbuttonDiv{
  margin-top: 1px;
  margin-bottom: 1px;
  }

#hiddenmarkersEdgeTypeSelector {
  width: 100% !important;
  }

.chosen-container, .chosen-drop, .chosen-drop .chosen-search, .chosen-drop .chosen-search input {
  width: 100% !important;
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}

.chosen-container { width:350px !important; 
                    height:auto;
                    font-size:8pt;}
iframe {
display: initial !important;
}


#MTNavForm{
  padding:4px !important;
  margin-top:4px !important;
  margin-bottom:0px !important;
  margin-left:0px !important;
}
#bottomMargin{
  height:18px;
}
</style>


<div id="markersAndPatientsDiv" class="container-fluid">
   <div id="markersAndTissuesButtonDiv" style="margin-bottom: 0px; margin-top: 8px;">
      <input type="text" id="markersAndTissuesMouseOverReadout" disabled value="(names displayed here)"></input>

     <select id="cyMarkersOperationsMenu" type="button" class="btn btn-primary navbar-form selectpicker SelectionMenu" style="font-size:11pt"></select>
     <select id="cyMarkersTumorCategorizationsMenu" class="SelectionMenu" style="font-size:8pt;"></select>
      
     <select class="chosen-select form-control dropdown navbar-form selectpicker SelectionMenu" 
                    style="width:280px;font-size:12pt"
                    data-placeholder="Select edge types to display" 
                    multiple id="markersEdgeTypeSelector">
           <option value="mutation" class="btn-info" selected>Mut</option>
           <option value="cnGain.2" class="btn-info" selected>Copy+2</option>
           <option value="cnLoss.2" class="btn-info" selected>Copy-2</option>
           <option value="cnGain.1" class="btn-info" selected>C+1</option>
           <option value="cnLoss.1" class="btn-info" selected>C-1</option>
       </select>
     
 
   <input  type="text" id="markersAndTissuesSearchBox" placeholder="search" style="width:100px;font-size:11pt"></input>
   <select class="SelectionMenu" type="button" id="cyMarkersSendSelectionsMenu" style="float:right; margin-right:15px"></select>
 
   <select class="btn btn-primary selectpicker SelectionMenu" type="button" id="markerLayouts"
            name="markerLayoutMenu"></select>
   <button id="markersSubSelectButton">Subselect</button>
 
   </div>
   
   
 <div id="cyMarkersDiv" data-toggle="tooltip" class="content" style="margin:0 auto" ></div>
 <div id="bottomMargin" style="width:100%;height:30px margin:0 auto"></div>

</div>




<div id="markersTestDiv">
  <div id="markersTestStatusDiv"        style="display:none"></div>
  <div id="markersAndPatientsStatusDiv" style="display:none"></div>
  <div id="qunit" style="display:block"></div>
  <div id="qunit-fixture"></div>
</div>



</div>

</body>
</html>
