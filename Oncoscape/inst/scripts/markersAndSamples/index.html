




<!DOCTYPE html> 
<html>

<head>
   <meta charset="UTF-8">
   <meta property="og:title" content="Oncoscape" />

   <title> OncoDev 1.4</title>

   <script src="http://code.jquery.com/qunit/qunit-1.18.0.js"></script>
   <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.18.0.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-2.1.3.min.js"></script>
   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-1.11.2.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-ui-1.11.4.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.7/themes/smoothness/jquery-ui.css">

   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.4.4.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.5.1.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.cytoscape.js-panzoom.js"></script>
   <link   href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.cytoscape.js-panzoom.css" 
           rel="stylesheet" 
           type="text/css">


   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/d3.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.dataTables-1.10.5.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.dataTables-1.10.5.min.css">

   <script src="http://cdn.datatables.net/colvis/1.1.0/js/dataTable.colVis.js"></script>

   <link   rel="stylesheet" type="text/css"
           href="http://cdn.datatables.net/colvis/1.1.0/css/dataTables.colVis.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.multi-select.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/multi-select.css" media="screen" rel="stylesheet" type="text/css">
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/chosen.jquery.min.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/chosen.min.css" media="screen" rel="stylesheet" type="text/css">

    <link rel="SHORTCUT ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>
    <link rel="ICON" type="image/x-icon" href="http://oncoscape.sttrcancer.org/oncoscape/images/favicon.ico"/>


<script> 
//--------------------------------------------------------------------------------------------------
// hooks for google analytics

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-528883-29', 'auto');
  ga('send', 'pageview');
//--------------------------------------------------------------------------------------------------
</script> 

<script>
navigator.sayswho= (function(){
    var ua= navigator.userAgent, tem,
    M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
    }
    if(M[1]!== 'Chrome'){
       alert("Oncoscape is currently developed and tested under Chrome.  For best results, please use Chrome version 45.0 and later.")
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
    }
    M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();
</script>

</head>

<style>

.flex-container {
  display: -webkit-flex;
  display: flex;
  }

.ui-slider-range {
   background-image: none;
   background: lightgrey;
   }

th,td {
   font-size:12px;
   }

.patientDataFilterSliderReadout{
   font-size: 10px;
   height:16px;
   }

.ui-tabs .ui-tabs-nav li a{
   font-size:10pt !important;
   }

.ui-button .ui-button-text{
   font-size:10pt !important;
   }

.ui-dialog .ui-dialog-titlebar-close span{ margin:0 }

.SelectionMenu{
color: rgb(0, 0, 0); 
background-color: rgb(255, 255, 255);
}

</style>



<script>

//----------------------------------------------------------------------------------------------------
// These javascript functions and variables are arranged into a simple module so that
// implementation details are kept private from the public API other oncoscape 
// browser modules will use.  common services and utility functions are provided here
//----------------------------------------------------------------------------------------------------
var HubModule = (function () {

  var name = "HubModule";
     // keys are module names, their outermost divs are the values.
     // providing these outermost divs allows was inspired by 
     // the need to allow raising of tabs by the sending tab.
     // TODO: not sure that's still needed

  var selectionDestinations = {};
  var dispatchOptions = {};
  var socketIsConnected = false;
  var socketConnectedFunctions = [];
  var onDocumentReadyFunctions = [];
  var socketURI = window.location.href.replace("http://", "ws://");
  var socket;
  
  var  messagingRestrictedToLogin = false;

  var modules = {};
//----------------------------------------------------------------------------------------------------
function registerModule(name, moduleObject)
{
   modules[name] = moduleObject;

} // registerModule
//----------------------------------------------------------------------------------------------------
function getModuleNames()
{
   return(Object.getOwnPropertyNames(modules));

} // getModuleNames
//----------------------------------------------------------------------------------------------------
function getModules()
{
   return modules;

} // getModules
//----------------------------------------------------------------------------------------------------
// TODO: add 3rd argument: acceptsIncomingMessages
//       datasets, for instance, seems to have no need for incoming json/websocket messages
function registerSelectionDestination(names, outermostDivID)
{
  if(typeof(names) == "string")
    names = [names];

  for(var i=0; i < names.length; i++)
     selectionDestinations[names[i]] = outermostDivID;

} // registerSelectionDestination
//----------------------------------------------------------------------------------------------------
function getRegisteredSelectionDestinations()
{
  return(selectionDestinations);

} // getRegisteredSelectionDestinations
//----------------------------------------------------------------------------------------------------
function setupSocket(socket)
{
  console.log("=== Module.hub setupSocket");

  try {
     socket.onopen = function() {
        console.log("websocket connection now open");
        socketIsConnected = true;
        for(var f=0; f < socketConnectedFunctions.length; f++){
           console.log("calling the next sockectConnectedFunction");
           socketConnectedFunctions[f]();
           } // for f
        } // socked.onopen

     socket.onmessage = function got_packet(msg) {
        var msg = JSON.parse(msg.data)
        dispatchMessage(msg)
        } // socket.onmessage, got_packet

     socket.onclose = function(){
        alert("Web socket connection to server has closed");
        } // socket.onclose
     } // try
  catch(exception) {
    console.log("Error: " + exception);
    }
 
  return(socket);

} // setupSocket
//----------------------------------------------------------------------------------------------------
function socketConnected()
{
   return(socketIsConnected);

} // socketConnected
//----------------------------------------------------------------------------------------------------
function addSocketConnectedFunction(func)
{
   socketConnectedFunctions.push(func)

} // addSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function getSocketConnectedFunctions()
{
   return(socketConnectedFunctions)

} // getSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function addOnDocumentReadyFunction(func)
{
   onDocumentReadyFunctions.push(func)

} // addOnDocumentReadyFunction
//----------------------------------------------------------------------------------------------------
function getOnDocumentReadyFunctions()
{
   return(onDocumentReadyFunctions)

} // getOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
// the nginx proxy server, used by fhcrc IT for the publicly-visible version of Oncoscape
// times out web sockets at 90 seconds.
// this function, when called more often that that, will keep the websocket open.
keepAlive = function()
{   
    //console.log("keep alive"); 
    msg = {cmd: "keepAlive", callback: "", status:"request", payload:""}
    socket.send(JSON.stringify(msg));

} // keepAlive
//--------------------------------------------------------------------------------------------------
function runOnDocumentReadyFunctions()
{
  setInterval(keepAlive, 10000);  // 10 seconds
  var funcs = getOnDocumentReadyFunctions()
  console.log("==== Module.hub: " + funcs.length + " onDocumentReadyFunctions");

  for (var f = 0; f < funcs.length; f++) {
     console.log("calling on ready function");
     funcs[f]();
     }

} // runOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
function runningInNode()
{
    // a not very sophisticated test, but adequate for our purposes thus far
  return(typeof(window) == "undefined")

} // functionRunningInNode
//----------------------------------------------------------------------------------------------------
function initializeWebSocket()
{
   if(runningInNode()){
     console.log("--- web socket not currently available when runing in Node");
     process.exit(code=1)
     }

   socket = new WebSocket(socketURI);
   socket = setupSocket(socket);

} // initializeWebSocket
//----------------------------------------------------------------------------------------------------
function getSocket()
{
  return(socket);

} // getSocket
//----------------------------------------------------------------------------------------------------
function addMessageHandler(cmd, func)
{
  if(cmd in dispatchOptions){
     dispatchOptions[cmd].push(func)
     }
  else{
     dispatchOptions[cmd] = [func]
     }
  
} // addMessageHandler
//----------------------------------------------------------------------------------------------------
function getRegisteredMessageNames()
{
   return(Object.keys(dispatchOptions));
  
} // getRegisteredMessageNames
//----------------------------------------------------------------------------------------------------
function getDispatchOptions()
{
   return(dispatchOptions);
  
} // getDispatchOptions
//----------------------------------------------------------------------------------------------------
function dispatchMessage(msg)
{
   var cmd = msg.cmd;
   var status = msg.status;
   console.log("====== Module.hub dispatchMessage '" + cmd + "' [" + Date() + "]" );

   var dispatchKeys = Object.keys(dispatchOptions);
   var cmdIndex = dispatchKeys.indexOf(cmd);
   console.log("hub.dispatchMessage(" + cmd + "): " + cmdIndex);

   if(cmdIndex === -1){
      console.log("unrecognized socket request: " + msg.cmd);
      console.log(" --- msg:");
      console.log(msg);
      console.log(" --- dispatchOptions");
      console.log(dispatchOptions);
      }
   else{
     var funcs = dispatchOptions[cmd];
     //console.log(" func count for msg cmd " + cmd + ": " + funcs.length);
      for(var i=0; i < funcs.length; i++){
         //console.log("--- Module.hub executing func # " + i + " for cmd " + msg.cmd);
         funcs[i](msg); // dispatchOptions[msg.cmd](msg)
         } // for i
      }

}  // dispatchMessage
//----------------------------------------------------------------------------------------------------
function restrictMessagingToLogin(newState)
{
   messagingRestrictedToLogin = newState;

} // restrictMessagingToLogin
//----------------------------------------------------------------------------------------------------
function send(msg)
{
   var cmd = JSON.parse(msg).cmd;
   if(messagingRestrictedToLogin && cmd === "checkPassword"){
      console.log("hub.send drops non-login msg");
      return;
      }

   var browserLocalCommand = Object.keys(dispatchOptions).indexOf(cmd) >= 0;
   var mode = "server";
   if(browserLocalCommand)
      mode = "browser local";

   console.log("--- hub.send: '" + cmd + "' (" + mode + ")");

   if(browserLocalCommand)
      dispatchMessage(JSON.parse(msg));
   else{
      socket.send(msg);
      }

}  // send
//----------------------------------------------------------------------------------------------------
function setTitle (newTitle)
{
  window.document.title = newTitle;

}  // setTitle
//----------------------------------------------------------------------------------------------------
// add a pulldown menu to the specified menuSelector, which has been provided by the caller, which
// is assumed to be an Oncoscape module.  append the names of all previously-registered divs, 
// except for those explicitly excluded in the incoming argument "excludedModules".
// This supports the usual (but not universal) case: a module does not want to send selections
// to itself.
// this argument will often be an array of one element, the name of the calling module.
// some modules may have multiple send destinations (eg, "PCA" & "PCA (highlight)".
function configureSendSelectionMenu(menuSelector, excludedModules, changeFunction, menuTitle)
{
  var menu = $(menuSelector);
  menu.append("<option>" + menuTitle + "</option>");
  menu.change(changeFunction);
  var otherModules = Object.keys(hub.getRegisteredSelectionDestinations());

  for(var i=0; i < otherModules.length; i++){
     var moduleName = otherModules[i];
     var excluded = excludedModules.indexOf(moduleName) >= 0;
     if(!excluded){
        menu.append("<option>" + moduleName + "</option>");
        }
     } // for i

  return(menu);

} // createSendSelectionMenu
//--------------------------------------------------------------------------------------------
// from http://stackoverflow.com/questions/4068373/center-a-popup-window-on-screen
function openCenteredBrowserWindow(url, title, w, h, replaceAnyExistingPopup) {
      // Fixes dual-screen position                       Most browsers      Firefox
    var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
    var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
    width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
    height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

    var left = ((width / 2) - (w / 2)) + dualScreenLeft;
    var top = ((height / 2) - (h / 2)) + dualScreenTop;
    var options = 'scrollbars=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left;

    var newWindow;

      // warning, a bug: when multiple popup windows are created, they
      // all have the same content -- not what we want.  fix this
      // by severing their relationship, and/or switching to jQuery dialog

    if(replaceAnyExistingPopup)
      newWindow = window.open(url, title, options);
    else // leave any existing popup windows untouched
      newWindow = window.open(url, "_blank", options);

    if (window.focus) {
       newWindow.focus();
       }
       
    return newWindow;

} // openCenteredBrowserWindow
//--------------------------------------------------------------------------------------------
function disableButton(button)
{
   button.prop("disabled", true);
   button.css({"background-color": "lightgray", "color": "gray"});

} // disableButton
//--------------------------------------------------------------------------------------------
function enableButton(button)
{
   button.prop("disabled", false);
   //button.css({ 'color': 'black'})
   button.css({"background-color": "white", "color": "black"});

} // enableButton
//--------------------------------------------------------------------------------------------
function disableAllTabsExcept(tabIDstring)
{
  if(typeof tabIDstring == "string") tabIDstring = [tabIDstring]
  var allDivIDs = getTabDivIDs()
  allDivIDs = allDivIDs.filter(function(i, id){ return(tabIDstring.indexOf(id) == -1) })
  for(var i=0;i<allDivIDs.length; i++){  	disableTab(allDivIDs[i]) }
  
  return allDivIDs;  //returns divIDs that have been disabled
  
} // disableTab
//--------------------------------------------------------------------------------------------
function disableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "disable", "#" + tabIDstring  )

} // disableTab
//--------------------------------------------------------------------------------------------
function enableTab(tabIDstring)
{
  $( "#oncoscapeTabs" ).tabs( "enable", "#" + tabIDstring   )
} // enableTab

//--------------------------------------------------------------------------------------------
// if jQuery-style tabs are in use with Oncoscape, this function raised the named tab to the
// the front (visible) position in the tabset
// the argument, "tabIDString" is the tab id used in the module's widget.html, reproduced exactly
// in tabsApp/widget.html, with some current examples being
//  pcaDiv, patientTimeLinesDiv, gbmPathwaysDiv
//
function raiseTab(tabIDString)
{
  var tabsWidget = $("#oncoscapeTabs");

  if(tabsWidget.length > 0){
     var selectionString = '#oncoscapeTabs a[href="#' + tabIDString + '"]';
     var tabIndex = $(selectionString).parent().index ();
     if(tabIndex < 0) throw "Module.hub does not recognize tabIDString '" + tabIDString + "'";
     console.log("Module.hub:raiseTab for '" + tabIDString + "' (" + tabIndex + ") set to active'");
     setTimeout(function(){tabsWidget.tabs( "option", "active", tabIndex);}, 0);
     } // if tabs exist

} // raiseTab
//----------------------------------------------------------------------------------------------------
// each of our tabs is a div, nested directly within $("oncoscapeTabs").  
// this function returns an array of each of the div ids
function getTabNames()
{
  var tabNames = $("#oncoscapeTabs").children()[0].textContent.trim().split("\n")
  for (i=0;i< tabNames.length; i++){ tabNames[i] = tabNames[i].trim()}
  tabNames =tabNames.filter(function(name){return name != ""})

	return tabNames;

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// each of our tabs has a title within the $("oncoscapeTabs") nav bar
// this function returns an array of each tab Title
function getTabDivIDs()
{
   return ($("#oncoscapeTabs").children("div").map(function(index,dom){return dom.id}));

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTab("Login", "#loginDiv");
function hideTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideTab
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTabNav("Login");
function hideTabNav(tabTitle)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()

} // hideTab
//----------------------------------------------------------------------------------------------------
function hideAllTabsButOne(tabTitle, tabDivIDstring)
{
  var divIDs = getTabDivIDs();
  
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideAllTabsButOne
//----------------------------------------------------------------------------------------------------
function showTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").show()
  $(tabDivIDstring).show();

} // showTab
//----------------------------------------------------------------------------------------------------
function addTab(tabTitle, tabDivIDstring,  content)
{
  var tabs = $("#oncoscapeTabs").tabs()
  var listItem = "<li><a href='#" + tabDivIDstring + "}'>" + tabTitle + "</a>";

  tabs.find(".ui-tabs-nav").append(listItem);
  tabs.append("<div id='" + tabDivIDstring + "'><p>" + content + "</p></div>");
  tabs.tabs("refresh");

} // addTab
//----------------------------------------------------------------------------------------------------
function getRandomFloat (min, max)
{
    return Math.random() * (max - min) + min;
}
//----------------------------------------------------------------------------------------------------
function getRandomInt (min, max) 
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
//----------------------------------------------------------------------------------------------------
String.prototype.beginsWith = function (string) 
{
    return(this.toLowerCase().indexOf(string.toLowerCase()) === 0);
};
//----------------------------------------------------------------------------------------------------
uniqueElementsOfArray = function(vector)
{
  var u = {}, a = [];

  for(var i = 0, l = vector.length; i < l; ++i){
     if(u.hasOwnProperty(vector[i])){
       continue;
       }
     a.push(vector[i]);
     u[vector[i]] = 1;
     } // for i

   return a;

} // uniqueElementsOfArray
//----------------------------------------------------------------------------------------------------
// return the targets matched by the candidates, where match is tolerant of differences by suffix
// thus incoming id "TCGA.06.0649.01" matches existing id "TCGA.06.0649" and
//      incoming id "TCGA.06.0649"    matches existing id "TCGA.06.0649.01" 
// this may cause problems with gene names, eg, MYC would mach MYCL and MYCA
// todo: make this suffix-tolerant match suffix-specific 
function intersectionOfArrays(candidates, targets) {

  hits=[]; 

  for(var i=0; i < candidates.length; i++){
    for (var j=0; j < targets.length; j++){
       candidate = candidates[i];
       target = targets[j];
       index1 = candidate.indexOf(target);   // "abc".indexOf("ab") -> 0
       index2 = target.indexOf(candidate); 
       //console.log("c(t): " + candidate + " contains " + target + ": " + index1);
       //console.log("t(c): " + target + " contains " + candidate + ": " + index2);
       if (index1 == 0)
          hits.push(target)
       else if (index2 == 0)
          hits.push(target)
         } // for j
     } // for i

  return(hits)

} // intersectionOfArays
//----------------------------------------------------------------------------------------------------
function setupGlobalExceptionHandler()
{
   window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {

      var title = "Oncoscape Error";
      var options = {buttons: { "Ok": function () { $(this).dialog("close"); } },
                     title: title};
      var text = "<i>" + errorMsg + "</i><br>" +
                 "<br><b>Script</b>: " + url + 
                 "<br><b>Line:</b> " + lineNumber + 
                 "<br><b>Column:</b> " + column + 
                 "<br><b>StackTrace:</b> " +  errorObj;
      $("<div></div>").dialog(options).html(text);
      };
 
} // setupGlobalExceptionHandler
//----------------------------------------------------------------------------------------------------
function start()
{
  setupGlobalExceptionHandler();
  initializeWebSocket();
  $(document).ready(runOnDocumentReadyFunctions);
  QUnit.config.altertitle = false;

}  // start
//----------------------------------------------------------------------------------------------------
function logEventOnServer(moduleOfOrigin, eventName, eventStatus, comment)
{
   console.log("about to logEvent: " + eventName);
   payload= {eventName: eventName, eventStatus: eventStatus, 
             moduleOfOrigin: moduleOfOrigin, comment: comment};

   hub.send(JSON.stringify({cmd: "logEvent", callback: "", status: "request", payload: payload}));

} // logEventOnServer
//----------------------------------------------------------------------------------------------------
function test_intersectionOfArrays()
{
   console.log("---  test_intersectionOfArrays");
   var targets = ["TCGA.02.0006"];
   var candidates = ["TCGA.02.0006"];

   QUnit.test("test_intersectionOfArrays 1", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   targets = ["TCGA.02.0006"];
   candidates = ["bogus"];
   QUnit.test("test_intersectionOfArrays 2", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });

   targets = ["bogus"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 3", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });


   targets = ["TCGA.02.0006.01"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 4", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   //targets = ["MAP2"];   this test will fail because sometimes we want incomplete matches:
   //  see test4 just above
   //candidates = ["MAP2K4", "abc"];
   //QUnit.test("test_intersectionOfArrays 5", function(assert) {
   //   assert.equal(hub.intersectionOfArrays(candidates, targets), []);
   //   });


} //  test_intersectionOfArrays
//----------------------------------------------------------------------------------------------------
function standAloneTest()
{
   test_intersectionOfArrays();

}  // standaloneTest
//----------------------------------------------------------------------------------------------------

  return({
     getName: function() {return(name)},
     restrictMessagingToLogin: restrictMessagingToLogin,
     registerModule: registerModule,
     getModules: getModules,
     registerSelectionDestination: registerSelectionDestination,
     getRegisteredSelectionDestinations: getRegisteredSelectionDestinations,
     socketConnected: socketConnected,
     addSocketConnectedFunction: addSocketConnectedFunction,
     getSocketConnectedFunctions: getSocketConnectedFunctions,
     addOnDocumentReadyFunction: addOnDocumentReadyFunction,
     getOnDocumentReadyFunctions: getOnDocumentReadyFunctions,
     runningInNode: runningInNode,
     initializeWebSocket: initializeWebSocket,
     getSocket: getSocket,
     addMessageHandler: addMessageHandler,
     getRegisteredMessageNames: getRegisteredMessageNames,
     getDispatchOptions: getDispatchOptions,
     dispatchMessage: dispatchMessage,
     configureSendSelectionMenu: configureSendSelectionMenu,
     openCenteredBrowserWindow: openCenteredBrowserWindow,
     enableButton: enableButton,
     disableButton: disableButton,
     enableTab: enableTab,
     disableTab: disableTab,
     disableAllTabsExcept: disableAllTabsExcept,
     getRandomInt: getRandomInt,
     getRandomFloat: getRandomFloat,
     intersectionOfArrays: intersectionOfArrays,
     uniqueElementsOfArray: uniqueElementsOfArray,
     send: send,
     setTitle: setTitle,
     getTabDivIDs: getTabDivIDs,
     getTabNames: getTabNames,
     raiseTab: raiseTab,
     hideTab: hideTab,
     hideTabNav: hideTabNav,
     showTab: showTab,
     addTab: addTab,
     sat: standAloneTest,
     start: start,
     logEventOnServer: logEventOnServer
     });

}); // HubModule
//----------------------------------------------------------------------------------------------------


var hub = HubModule();
hub.start();

// testManager/Module.js
//----------------------------------------------------------------------------------------------------
var moduleTests = [];
//----------------------------------------------------------------------------------------------------
var TestManagerModule = (function () {

   var loopStatusObserver = null;

   var loopStatusDiv = "#testManagerLoopStatusDiv";

//----------------------------------------------------------------------------------------------------
function initializeModule()
{
  console.log("--- entering Module.testManager.initializeModule");
  
  hub.addMessageHandler("testManagerAssessUserIdForTesting", assessUserIdForTesting);

  if(hub.socketConnected())
     runAutomatedTestsIfAppropriate();
  else
     hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);
    
} // initializeModule
//----------------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserInfo",  callback: "testManagerAssessUserIdForTesting", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   console.log("---- Module.testManager, payload: ");
   console.log(JSON.stringify(msg.payload));
   
   var userID = msg.payload.userID;
   userID = userID.toLowerCase();

   var datasetNames = msg.payload.datasets;
   if(typeof(datasetNames) === "string")
      datasetNames = [datasetNames];

     // currently restricted to just one module:
     // mutation observer pacing not yet worked out with multiple modules tested successively
     
   console.log("testManager/Module.js assessUserIdForTesting: " + userID);
   if(userID.indexOf("autotest") === 0){
      console.log("testManager/Module.js running tests for user " + userID);
      var start = userID.indexOf(".");
      var end = userID.indexOf("@");
      var reps = 1;
      if(start > 0 && end > 0)
        reps = parseInt(userID.slice(start+1, end));
      var exitOnCompletion = false;
      if(userID.indexOf("exitoncompletion") > 0)
          exitOnCompletion = true;

      console.log("runTests: " + JSON.stringify(datasetNames));
      console.log("reps: " + reps);
      console.log("exitOnCompletion: " + exitOnCompletion);
      //runTests(datasetNames, reps, exitOnCompletion);

        // the individual modules should not exitOnCompletion
      var modulesExitOnCompletion = false;
      for(var i=0; i < moduleTests.length; i++){
         console.log("about to run <module>Tester.run(), loop " + i);
         moduleTests[0].run(datasetNames, reps, exitOnCompletion);
         } // var i
       
      //if(exitOnCompletion){
      //   var payload = {errorCount: Object.keys(sessionStorage).length,
      //                  errors: JSON.stringify(sessionStorage)};
      //   var exitMsg = {cmd: "exitAfterTesting", callback: "", status: "request", payload: payload};
      //   console.log("about to send exitAfterTesting msg to server");
      //   hub.send(JSON.stringify(exitMsg));
      //   } // if exitOnCompletion
      } // if userID == autotest

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
function runTests(datasetNames, reps, exitOnCompletion)
{

   var config = {attributes: true, childList: true, characterData: true};
   var target =  document.querySelector(loopStatusDiv);

   var testIndex = -1;

   var onMutation = function(mutations){
      mutation = mutations[0];
      loopStatusObserver.disconnect();
      loopStatusObserver = null;
      var id = mutation.target.id;
      var msg = $(loopStatusDiv).text();
      console.log("test status changed, text: " + msg);
      testIndex++;
      if(testIndex < moduleTests.length){
         console.log("about to test module " + testIndex);
	 loopStatusObserver = new MutationObserver(onMutation);
         loopStatusObserver.observe(target, config);
         var moduleExitOnCompletion = false;
         moduleTests[testIndex].run(datasetNames, reps, moduleExitOnCompletion);
	 }
      else{
         console.log("mutation observer function detected end of moduleTests array");
         if(exitOnCompletion){
            var payload = {errorCount: Object.keys(sessionStorage).length,
	                   errors: JSON.stringify(sessionStorage)};
            var exitMsg = {cmd: "exitAfterTesting", callback: "", status: "request", payload: payload};
            console.log("about to send exitAfterTesting msg to server");
            hub.send(JSON.stringify(exitMsg));
	    } // if exitOnCompletion
	 } // else: datasets exhaused
      }; // onMutation function

   loopStatusObserver = new MutationObserver(onMutation);
   loopStatusObserver.observe(target, config);

   $(loopStatusDiv).text("start testing");   // mutate the target

} // runTests
//----------------------------------------------------------------------------------------------------

  return({
     init: initializeModule,
     run: runTests
     });

});  // TestManagerMdoule
//----------------------------------------------------------------------------------------------------
testManager = TestManagerModule();
hub.addOnDocumentReadyFunction(testManager.init);
hub.addOnDocumentReadyFunction(function() {
    console.log("====== tabapps document ready");
    window.tabsAppRunning = true
    $("#oncoscapeTabs").tabs({
         // todo: distinguish between tabs, only do needed resets
       activate: function(event, ui) {
            console.log(" tabsApp/code.js:activate");
            var tableRef = $("#historyTable").dataTable();
            var tableRef2 = $("#userDataStoreTable").dataTable();
            if (tableRef.length > 0) {
               console.log("   adjusting patient history table");
               tableRef.fnAdjustColumnSizing();
               } // if
            if (tableRef2.length > 0) {
               console.log("   skipping! - adjusting user data store table");
               tableRef2.fnAdjustColumnSizing();
               } // if
            //console.log(" ==== tab.activate, possible cyjs resize and fit");
            if(typeof(cwMarkers) != "undefined") {
              console.log("adjusting cwMarkers? " + cwMarkers.width() + " * " + cwMarkers.height());
               if(cwMarkers.width() > 0){
                  cwMarkers.resize(); 
                  console.log("after resize");
                  cwMarkers.fit(50);
                  console.log("done adjusting cwMarkers");
		  }
               }
            if(typeof(cyGbm) != "undefined") {
               //console.log("adjusting cwGbm");
               cyGbm.resize();
               cyGbm.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cwAngio) != "undefined") {
               //console.log("adjusting cwAngio");
               cwAngio.resize();
               cwAngio.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cyPathway) != "undefined") {
               cyPathway.resize();
               cyPathway.fit(50);
               }
            } // activate
        }); // tabs
    });  // ready



//----------------------------------------------------------------------------------------------------
var DataSummaryModule = (function () {

  var dataSummaryDiv;

  var outputDiv;
  var dataSetNamesOutputDiv;
  var thisModulesName = "Datasets";
  var thisModulesOutermostDiv = "datasetsDiv";

  var tableElement;
  var tableRef;
  var datasetMenu;
  var selectedDataSet;
  var useThisDatasetButton;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";
  var passwordProtected = false;

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
  sendSelectionsMenu = hub.configureSendSelectionMenu("#datasetsSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

  hub.disableButton(sendSelectionsMenu);

  $(window).resize(handleWindowResize);
  datasetMenu = $("#datasetMenu");
  datasetMenu.change(selectManifest);

  dataSetNamesOutputDiv = $("#dataSetNamesOutputDiv");
  dataSummaryDiv = $("#dataSummaryOutputDiv");

  useThisDatasetButton = $("#selectDatasetButton");
  useThisDatasetButton.button();
  hub.disableButton(useThisDatasetButton);
  useThisDatasetButton.click(specifyCurrentDataset);

  outputDiv = $("#dataSummaryOutputDiv");
  tableElement = $("#datasetsManifestTable");
      
    // if no login tab is present, then allow unrestricted choice of datasets.
    // if it IS present, then that tab will control this.

  var loginRequired = $("#loginDiv").length === 1;
  console.log("loginRequired? " + loginRequired);

  if(!loginRequired){
    console.log(" enabling datasetMenu");
    hub.enableButton($("#datasetMenu"));
    }
  else{
    console.log(" disabling datasetMenu");
    hub.disableButton($("#datasetMenu"));
    }

   if(hub.socketConnected())
      populateDataSetMenu();
   else
     hub.addSocketConnectedFunction(populateDataSetMenu);

} // initializeUI
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
   $("#datasetsStatusDiv").text(msg);   // todo: this is obsolete
   $("#datasetsMinorStatusDiv").text(msg);
   
} // postStatus
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  $("#"+thisModulesOutermostDiv).width($(window).width() * 0.95);
//  $("#"+thisModulesOutermostDiv).height($(window).height() * 0.95);

//  console.log("  div: " + outputDiv.width());
//  console.log("  tbl before: " + tableElement.width());
//  tableElement.width($(window).width() * 0.50);
//  console.log("  tbl after: " + tableElement.width());

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   var cmd = "sendSelectionTo_" + destination;
   payload = "dummy payload";
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//----------------------------------------------------------------------------------------------------
function selectManifest(event)
{
   selectedDataSet = datasetMenu.val();
   console.log("dataset '" + selectedDataSet + "'");

   if(selectedDataSet === ""){
      $("#datasetInstructions").css("display", "block");
      $("#datasetsManifestTable").css("display", "none");
      hub.disableButton(useThisDatasetButton);
      }
    else{
      $("#datasetInstructions").css("display", "none");
      $("#datasetsManifestTable").css("display", "block");
      requestDataSetSummary(selectedDataSet);
    }

} // selectManifest
//----------------------------------------------------------------------------------------------------
function populateDataSetMenu()
{
   console.log("Module.datasets, entering populateDataSetMenu");

   console.log("      socket connected? " + hub.socketConnected());
   console.log("=== datasetMenu ready, now issuing populateDataSetMenu request to server");
   var msg = {cmd: "getDataSetNames",  callback: "handleDataSetNames", status: "request", payload: ""};
   hub.send(JSON.stringify(msg));

} // populateDataSetMenu
//----------------------------------------------------------------------------------------------------
function handleDataSetNames(msg)
{
   console.log("=== handleDataSetNames");
   
   var dataSetNames = msg.payload.datasets;
   console.log("dataSetNames length: " + dataSetNames.length);
   console.log("dataSetNames: " + JSON.stringify(dataSetNames));

   var passwordProtected = msg.payload.passwordProtected;

   if(!Array.isArray(dataSetNames))
      dataSetNames = [dataSetNames];

   for(var i=0; i < dataSetNames.length; i++){
      var s = dataSetNames[i];
      datasetMenu.append("<option value='" + s + "'>" + s + "</option>");
      }

  $("#datasetsMinorStatusDiv").text("datasetMenu loaded");

} // handleDataSetNames
//----------------------------------------------------------------------------------------------------
function requestDataSetSummary(dataSetName)
{
   console.log("=== requestDataSetSummary");

   var msg = {cmd: "getDataManifest",  callback: "displayDataManifest", status: "request", 
              payload: dataSetName};
   hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "request", dataSetName);

   hub.send(JSON.stringify(msg));

} // requestDataSetSummary
//----------------------------------------------------------------------------------------------------
function displayDataManifest(msg)
{
   var payload = msg.payload;
   var tblColumnNames = payload.colnames;

   var columnTitles = [];
     // convert simple strings to array of objects, each an sTitle
   for(var i=0; i < tblColumnNames.length; i++){
      columnTitles.push({sTitle: tblColumnNames[i]});
      }
     
   if(typeof(tableRef) != "undefined"){
      tableRef.destroy();
      tableElement.empty();
      }


   $(tableElement).ready(function() {
      tableRef = tableElement.DataTable({
        //sDom: 't',
        aoColumns: columnTitles,
        //scrollX: true,
        bPaginate: false,
        bFilter: false, 
        bAutoWidth: true,
        bSort: false,
        bInfo: false
        }); // dataTable

     tableRef = $("#datasetsManifestTable").DataTable();

     tableRef.rows.add(payload.mtx).draw();
     // tableRef.fnAddData(payload.mtx);

     $('#datasetsManifestTable tbody').on( 'click', 'tr', function (){ 
         console.log("=== click");
         var category = $('td', this).eq(0).text();
         var subcategory = $('td', this).eq(1).text();
         if($(this).hasClass("selected")){
            $(this).removeClass('selected');
            hub.disableButton(sendSelectionsMenu);
            }
         else{
            tableRef.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            hub.enableButton(sendSelectionsMenu);
            console.log("selected " + category + ", " + subcategory);
            }
         });

     handleWindowResize();
     hub.enableButton(useThisDatasetButton);
     postStatus("manifest table displayed");
     hub.logEventOnServer(thisModulesName, "datasets requestDataSummary", "complete", "");
     }); // tableElement.ready

} // displayDataManifest
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset()
{
   console.log("Module.datasets 'Use Dataset' button clicked, specifyCurrentDataset: " + selectedDataSet);
 
   hub.disableAllTabsExcept([thisModulesOutermostDiv, "userDataStoreDiv", "ericTestDiv"]);
   $("#loadingDatasetMessage").css("display", "inline");
	
   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: selectedDataSet};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   $("#loadingDatasetMessage").css("display", "none");
   console.log("--- Module.datasets:  datasetSpecified");

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function test(dataSetName)
{
   console.log("Module.datasets test, on datasetName: '" + dataSetName + "'");

   QUnit.test("choose dataset '" + dataSetName + "'", function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = dataSetName;
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value;});

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset);
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         //testLoadPatientHistoryTable();
         }, 5000);
      });


} // test
//----------------------------------------------------------------------------------------------------
function moduleInit()
{
  hub.addOnDocumentReadyFunction(initializeUI);
  //hub.addSocketConnectedFunction(populateDataSetMenu);
  hub.addMessageHandler("handleDataSetNames", handleDataSetNames);
  hub.addMessageHandler("displayDataManifest", displayDataManifest);
  hub.addMessageHandler("datasetSpecified", datasetSpecified);

} // moduleInit
//----------------------------------------------------------------------------------------------------
return{
   init: moduleInit,
   test: test
   }; // DataSummaryModule return value

//----------------------------------------------------------------------------------------------------
}); // DataSummaryModule

var dataSummaryModule = DataSummaryModule();
dataSummaryModule.init();
hub.registerModule("Datasets", dataSummaryModule);

//----------------------------------------------------------------------------------------------------
// declare the cytoscape object in global scope, permitting	 easy manipulation in the javascript console.
var cwMarkers;

//----------------------------------------------------------------------------------------------------
var markersAndTissuesModule = (function () {

  var statusDiv; 
  var cyDiv;
  var searchBox;
  var hideEdgesButton, showEdgesButton, showAllEdgesButton, clearSelectionButton, sfnButton;
  var markersFitViewButton, markersHideEdgesButton, markersShowEdgesButton, markersZoomSelectedButton;

  var nodeRestriction = [];
  var subSelectButton;
  var helpButton;
  var infoMenu;
  var zoomMode = "Spread";
  var initialZoom;
  var oldZoom;
  var edgeTypeSelector;
  var mouseOverReadout;
  var graphOperationsMenu;
  var tumorCategorizationsMenu;
  var tumorCategorizationsMenuTitle = "Tumor Groups...";
  var sendSelectionsMenu;
  var layoutMenu;
  var thisModulesName = "MarkersAndPatients";
  var thisModulesOutermostDiv = "markersAndPatientsDiv";
  var userID = "NA";

     // assigned on first load, used when tumor groups are cleared
  var defaultPatientNodeColor = "black";  

      // sometimes a module offers multiple selection destinations.
      // usually there is just one:

  var selectionDestinations = [thisModulesName];


  var sendSelectionsMenuTitle = "Send selection...";

     // the user may specify that only certain tumors, and/or certain genes
     // are to be used in any subsequent network operations -- especially
     // "show edges from selected nodes"
     // to experiment with this capability, there are two new net ops menu
     // options, which assign zero or more selected nodes to these variables,
     // which are then used (if defined) to limit the subsequent network
     // operation


//--------------------------------------------------------------------------------------------
function initializeUI ()
{

  cyDiv = $("#cyMarkersDiv");
  statusDiv = $("#markersAndPatientsStatusDiv");

  sendSelectionsMenu = hub.configureSendSelectionMenu("#cyMarkersSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                      sendSelectionsMenuTitle);

  markersFitViewButton = $("#markersFitViewButton");
  markersFitViewButton.click(function(){cwMarkers.fit(50);});
  
  markersZoomSelectedButton = $("#markersZoomSelectedButton");
  markersZoomSelectedButton.click(zoomSelected);

  markersHideEdgesButton = $("#markersHideEdgesButton");
  markersHideEdgesButton.click(hideAllEdges);
  hub.disableButton(markersHideEdgesButton);
  
  markersShowEdgesFromButton = $("#markersShowEdgesFromSelectedButton");
  markersShowEdgesFromButton.click(showEdgesFromSelectedNodes);
  hub.disableButton(markersShowEdgesFromButton);

  tumorCategorizationsMenu = $("#cyMarkersTumorCategorizationsMenu");
  tumorCategorizationsMenu.empty();
  tumorCategorizationsMenu.append("<option>" + tumorCategorizationsMenuTitle + "</option>");
  tumorCategorizationsMenu.change(requestTumorCategorization);

  graphOperationsMenu = $("#cyMarkersOperationsMenu");
  graphOperationsMenu.change(doGraphOperation);
  graphOperationsMenu.empty();
  graphOperationsMenu.append("<option>Network Operations...</option>");

  var operations = ["Show All Edges",
                    "Show Edges from Selected Nodes",
                    "Hide All Edges",
                    //"Connect to First Neighbors",
                    "Invert Node Selection",
                    "Clear Selections",
                    "Select All Connected Nodes",
                    "Select All Nodes with Selected Edges",
                    "Hide Unselected Nodes",
                    "Show All Nodes",
                    "Restrict Next Ops to Selected Nodes"];

  for(var i=0;i< operations.length; i++){
     var optionMarkup = "<option>" + operations[i] + "</option>";
     graphOperationsMenu.append(optionMarkup);
     } // for 


   layoutMenu = $("#markerLayouts");
   layoutMenu.change(performLayout);

   showEdgesButton = $("#cyMarkersShowEdgesButton");
   showEdgesButton.click(showEdges);
   
   showAllEdgesButton = $("#cyMarkersShowAllEdgesButton");
   showAllEdgesButton.click(showAllEdges);

   sfnButton = $("#cyMarkersSFNButton");
   sfnButton.click(selectFirstNeighbors);
   clearSelectionButton = $("#cyMarkersClearSelectionButton");
   clearSelectionButton.click(clearSelection);

   hideEdgesButton = $("#cyMarkersHideEdgesButton");
   hideEdgesButton.click(hideAllEdges);


   searchBox = $("#markersAndTissuesSearchBox");

   edgeTypeSelector = $("#markersEdgeTypeSelector");
   edgeTypeSelector.chosen();

   mouseOverReadout = $("#markersAndTissuesMouseOverReadout");
   configureCytoscape();
   $(window).resize(handleWindowResize);

   subSelectButton = $("#markersSubSelectButton");
   subSelectButton.click(subSelectNodes);

   setInterval(buttonAndMenuStatusSetter, 500);
      
   hub.disableTab(thisModulesOutermostDiv);
 
} // initializeUI
//----------------------------------------------------------------------------------------------------
// some buttons and menu are live or disabled depending on the presence of e.g., selected nodes
// or visible (non-chromosome) edges.   check those things and set their states appropriately

function buttonAndMenuStatusSetter()
{
   var selectedNodes = cwMarkers.nodes("node:selected");
   var selectedNodeCount = selectedNodes.length;
   $("#markersSelectionCountReadout").val(selectedNodeCount);
   
   var selectedPatientNodes = cwMarkers.nodes("node[nodeType='patient']:selected");
   var selectedPatientNodeCount = selectedPatientNodes.length;
   
   if(selectedNodeCount === 0){
      hub.disableButton(sendSelectionsMenu);
      hub.disableButton(markersShowEdgesFromButton);
      hub.disableButton(markersZoomSelectedButton);
      }
   else{
      hub.enableButton(sendSelectionsMenu);
      hub.enableButton(markersShowEdgesFromButton);
      hub.enableButton(markersZoomSelectedButton);
      }
      
      // the Subselect button is only on if a primary selection has been made
   var categories = selectedPatientNodes.map(function(e) {return e.data().category;});
   var categoriesPresent = categories.filter(function(e){return e;}).length > 0;  // undefined & null filtered out

   if(selectedPatientNodeCount > 0 & categoriesPresent)
      hub.enableButton(subSelectButton);
   else
      hub.disableButton(subSelectButton);
   

   var visibleEdges = cwMarkers.edges().fnFilter(function(e){return(e.visible());})
                                       .fnFilter(function(e){return(e.data("edgeType") != "chromosome");}).length;
   if(visibleEdges > 0)
       hub.enableButton(markersHideEdgesButton);
   else
       hub.disableButton(markersHideEdgesButton);

} // buttonAndMenuStatusSetter
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length === 0){
      console.log("no nodes selected!");
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
// we currently support a limited amount cyjs layout save and restore.
// among the limitations are:
//   a) they are saved on the user's computer
//   b) they can only be retrieved if the same computer, the same browser, and the same url
//      is used
function configureLayoutsMenu(layoutMenu)
{
   console.log("--- configureLayoutsMenu");
   layoutMenu.append("<option>Layouts...</option>");
   layoutMenu.append("<option> Save Current</option>");

   var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
       var result = {id:n.id(), position:n.position()};
       return (result);  
       }) // map
     ); // stringify

   localStorage.markersDefault = defaultLayout;

   var existingLayouts = Object.keys(localStorage);
   for(var i=0; i < existingLayouts.length; i++){
      if(existingLayouts[i].match("markers") !== null){
        layoutMenu.append("<option>" + existingLayouts[i] + "</option>");
        }
      } // for i

} // configureLayoutsMenu
//----------------------------------------------------------------------------------------------------
function performLayout(event){

  var chosenLayoutName = layoutMenu.val();

  if(chosenLayoutName == "Save Current"){
     var uniqueNumber = Math.floor(new Date().getTime()/1000);   // number of seconds since 1970
     newName = "markers." + (uniqueNumber - 1420414900);    // since today, very roughly
     var positions = cwMarkers.nodes().map(function(n){
           var result = {id:n.id(), position:n.position()};
           return(result);
           }); // map
     currentLayout = JSON.stringify(positions);
     localStorage[newName] = currentLayout;
     layoutMenu.append("<option>" + newName + "</option>");
     layoutMenu.val(newName);
     return;
     } // if "Save Current"

  if(Object.keys(localStorage).indexOf(chosenLayoutName) >= 0){
     var newLayout;
     newLayout = JSON.parse(localStorage[chosenLayoutName]);
     cwMarkers.nodes().positions(function(i, node){
        return{x: newLayout[i].position.x, y:newLayout[i].position.y};
         });
     } // if requested layout name is recognized
  
  layoutMenu.val("Layouts...");   // restore the title

} // performLayout
//--------------------------------------------------------------------------------------------
function configureCytoscape ()
{
  cwMarkers = $("#cyMarkersDiv");
  cwMarkers.cytoscape({
     hideEdgesOnViewport: false,
     hideLabelsOnViewport: false,
     boxSelectionEnabled: true,
     showOverlay: false,
     minZoom: 0.001,
     maxZoom: 1000.0,
     layout: {
       name: "preset",
       fit: true
       },
   ready: function() {
      console.log("cwMarkers ready");
      cwMarkers = this;
      initialZoom = cwMarkers.zoom();
      var debouncedSmartZoom = debounce(smartZoom, 20);
      cwMarkers.on('zoom', debouncedSmartZoom);
      cwMarkers.on('pan', debouncedSmartZoom);

      cwMarkers.on('mouseover', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val(node.id());
         });
      cwMarkers.on('mouseout', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val("");
         });
      cwMarkers.on('mouseover', 'edge', function(evt){
         var edge = evt.cyTarget;
         var d = edge.data();
         var msg = d.edgeType + ": " + d.source + " - " + d.target;
         var mutation = d.mutation;
         if(typeof(mutation) == "string")
            msg = mutation + " " + msg;
         mouseOverReadout.val(msg);
         });

      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      searchBox.keydown(doSearch);

      console.log("cwMarkers.reset");
      cwMarkers.reset();
      handleWindowResize();
      cwMarkers.edges().selectify(); // this seems to hold through session, visibility notwithstanding
      //hideAllEdges();
      configureLayoutsMenu(layoutMenu);
      cwMarkers.fit(50);
      }, // cwMarkers.ready
     }); // .cytoscape

} // configureCytoscape
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
   cyDiv.width(0.95 * $(window).width());
   cyDiv.height(0.8 * $(window).height());
      // todo: should preserve preceeding view.
   cwMarkers.resize();
   cwMarkers.fit(50);  

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate)
{
   var timeout;
   return function() {
      var context = this, args = arguments;
      var later = function() {
         timeout = null;
         if (!immediate) func.apply(context, args);
          };
       var callNow = immediate && !timeout;
       clearTimeout(timeout);
       timeout = setTimeout(later, wait);
       if (callNow) func.apply(context, args);
       };
}
//----------------------------------------------------------------------------------------------------
// expand node size and display node labels when:
//   1) the user's coordinate space, due to zooming, has shrunk to < 600 pixels
//   2) the zoom factor is so large relative to the initial zoom (a global variable, set on startup)
//
// the current implemetation is decidely imperfect.  the operations accomplished here take too
// long, creating a sometimes quite unsatisfying user experience.
// this has been mitigated somewhat by
//    - deboucncing (at some interval)
//    - expanding nodes, adjusting font, node border and edge width only when well zoomed in
//      AND a modest number of nodes are onscreen
//    - trying to avoid layout when possible in the base network.
//  
function smartZoom(event)
{
   var zoomRatio = cwMarkers.zoom()/initialZoom;
   console.log("zoomRatio: " + zoomRatio);

   if(zoomRatio < 1.0){
      defaultStyle();
      return;
      }
      
   var visibleCoords = cwMarkers.extent();
   var visibleOnScreen = function(node){
      if(node.data("landmark"))
         return(false);
      var bbox = node.boundingBox();
      var visibleX = (bbox.x1 >= visibleCoords.x1 && bbox.x1 <= visibleCoords.x2) |
                     (bbox.x2 >= visibleCoords.x1 && bbox.x2 <= visibleCoords.x2);
      if(!visibleX)
        return false;
      var visibleY = (bbox.y1 >= visibleCoords.y1 && bbox.y1 <= visibleCoords.y2) |
                     (bbox.y2 >= visibleCoords.y1 && bbox.y2 <= visibleCoords.y2);
      return(visibleY);
      };
      
   var visibleNodes = cwMarkers.nodes().fnFilter(function(node){return(visibleOnScreen(node));});		
   console.log("visibleNode count: " + visibleNodes.length);
   if(visibleNodes.length > 400){
      defaultStyle();
      return;
      }
   var newZoom = 1.0 + cwMarkers.zoom() - oldZoom;
   oldZoom = cwMarkers.zoom(); // keep this for next time

      // TODO: these two ratios might be reduced to just one
      
   var windowRatio = cwMarkers.width()/cwMarkers.extent().h;
   
   var fontSize = cwMarkers.extent().h/60;
   if(fontSize < 0.6)
     fontSize = 0.6;
     
   var fontSizeString = fontSize + "px";
   var borderWidthString = cwMarkers.extent().h/600 + "px";
   cwMarkers.edges().style({"width": borderWidthString});
   
   var newWidth, newHeight, id;
   var factor = 1.5; // 3
   cwMarkers.batch(function(){
      visibleNodes.map(function(node){
         newWidth = factor *  node.data("trueWidth") / zoomRatio;
         newHeight = factor *  node.data("trueHeight") / zoomRatio;
         id = node.id();
         node.data({zoomed: true});
         node.style({width: newWidth, height: newHeight, label: id, "font-size": fontSizeString,
                    "border-width": borderWidthString});
         });
       });

} // smartZoom
//----------------------------------------------------------------------------------------------------
// undo any changes brought about during smartZoom.
// TODO: it seems a better approach would be to remove the zoomed attribute, and apply the style rules
// everywhere with which the network was initialized.
function defaultStyle()
{
   var zoomedNodes = cwMarkers.nodes("[zoomed]");
   cwMarkers.edges().style({"width": "1px"});
   
   zoomedNodes.map(function(node){node.style({width: node.data("trueWidth"),
                                              height: node.data("trueHeight"),
                                              zoomed: false,
                                             "border-width": "1px",
                                             "font-size":    "3px"});});

} // defaultStyle
//----------------------------------------------------------------------------------------------------
// tumor (patient, sample) nodes can be categorized, usually based upon independent biology,
// expressed in simple named tables included in each data package.  Each sample group in these
// tables is assigned a color for distinctive display.
// here we present a simple dialog so that one or more categories within the current selection
// can be subselected
//
function subSelectNodes()
{
  var selectedPatientNodes = cwMarkers.nodes("node[nodeType=patient']:selected");
  var categories = jQuery.unique(selectedPatientNodes.map(function(e){return e.data("category");}));

  var colors = jQuery.unique(selectedPatientNodes.map(function(node){return (node.style("background-color"));}));

  var content = "<form action=''>";
  for(i=0; i < categories.length; i++){
     var category = categories[i];
     var color = colors[i];
     var selector = "[category='" + category + "']:selected";
     var count = cwMarkers.nodes(selector).length;
     var id = "cb" + i;
     var e = "<html><body><input id='" + id + "' type='checkbox' class='markersSubSelectRadioButton' name='" + category + "'" +
             " style='background':'" + color + "'" + " checked> " +
             "<label for='" + id + "' style='color:" + color + "'>" + category + " (" + count + ")</label><br></body></html>";
     content = content + e;
     }
  content = content + "</form>";
  button = "<br><br><button id='markersSubSelectCloseButton'>Close</button>";

  content = content + button;

  var dialog = $('<div id="markersSubSelectDialog" />').html(content).dialog({title:"Subselect by Sample Category",
                                                                              width: "500px"});

  $("#markersSubSelectCloseButton").click(function(){
     console.log("about to remove subselect dialog");
     $("#markersSubSelectDialog").remove();
     });

  $(".markersSubSelectRadioButton").click(function(e) {
      var category = this.name;
      var doSelectNodes = this.checked;
      var subsetNodes = selectedPatientNodes.filterFn(function(e){return(e.data("category") === category);});
      if(doSelectNodes)
         subsetNodes.select();
      else
         subsetNodes.unselect();
      }); // radio button click

} // subSelectNodes
//----------------------------------------------------------------------------------------------------
// patient (sample, tumor) nodes sometimes get category data attached: the tumorCategorizationsMenu
// initiates that process.  the server supplies (nodeID, cluster|group, color) triples, one for
// each categorized tumor.  we place the group into a category field in the node's data, and collapse
// all the color/category assignments down into a few style rules.
// in this function, all of that (possibly) present information is stripped out.
function clearTumorCategoriesAndCategoryStyles()
{
   var patientNodes = cwMarkers.nodes("node[nodeType ='patient']");
   cwMarkers.batch(function(){
      patientNodes.map(function(e){if("category" in e.data()) delete e.data().category;});
      });
      
   var oldStyle = cwMarkers.style().json();
   var newStyle = oldStyle.filter(function(e){return(e.selector.indexOf("node[category"));});
   cwMarkers.style(newStyle);

} // clearTumorCategoriesAndCategoryStyles
//----------------------------------------------------------------------------------------------------
function requestTumorCategorization()
{
  var allCategoryNames = tumorCategorizationsMenu.children().map(function() {return $(this).val();}).get();
  var menuTitle = allCategoryNames[0];
  var categorizationName = tumorCategorizationsMenu.val();

  console.log("--- requestTumorCategorization, name: " + categorizationName);

  if(categorizationName === menuTitle || categorizationName === "Clear"){
     clearTumorCategoriesAndCategoryStyles();
     return;
     } // clear
     
  console.log("apply " + categorizationName);
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "request", "");

  var msg = {cmd: "getSampleCategorization", callback: "markersApplyTumorCategorization",
             status: "request", payload: categorizationName};

  hub.send(JSON.stringify(msg));

} // requestTumorCategorization
//----------------------------------------------------------------------------------------------------
// msg.payload has 3 fields: colnames, rownames, tbl
//   colnames: ["cluster", "color"]
//   rownames: possibly large number of tumors (samples) with category (cluster) & color assigned
//   tbl: a matrix, rownames.length x colnames.lenght, of cluster and color assignments
// representing this data structure
//                    cluster         color
//  TCGA.08.0525    Classical     chocolate
//   ...
//
// strategy:
//    get unique cluster/color pairs (far fewer of these, typically, than sample ids (tbl rows).
//    each sample named in the tbl, and also found in the network, will get a "category" (aka "cluster")
//    attribute assigned to it near the end of this function.
//    first, however, cyjs/css style rules are handcrafted, one for unique cluster value, and one
//    for each cluster value if the node is selected.

function applyTumorCategorization(msg)
{
   console.log("=== applyTumorCategorization");

   var tumorsInGraph = cwMarkers.nodes("[nodeType='patient']");
   var tumorsInTable = msg.payload.rownames;
   var tbl = msg.payload.tbl;
   var categoryRules = {};

      // this forEach loop inelegantly reduces many rows to a unique set
      // by overwriting, e.g., categoryRules["G-CIMP"] = "purple" each of
      // the time it is seen.  this inefficiency could be eliminated by
      // sending across just the unique rules from R as a payload field
      // (and also removing the color column from tbl).
      
   tbl.forEach(function(row){categoryRules[row[0]] = row[1];});


   categoryRuleNames = Object.keys(categoryRules);
     // e.g. ["G-CIMP", "Classical", "null", "Proneural", "Neural", "Mesenchymal"]
   categoryRuleNames.filter(function(name){return name !== "null";});
   categoryRuleNames.filter(function(name){return name !== null;});
   var newRules = [];

     // translate the categoryRules into cyjs/css style rules, which
     // look like this:
     // {"selector":"node[category='Classical']","style":{"background-color":"chocolate"}}
     // {"selector":"node[category='Classical']:selected",
     //     "style":{"border-color":"red","background-color":"chocolate","border-width":"10px"}}"
     
   categoryRuleNames.forEach(function(name){
      var selector = "node[category='" + name + "']";
      color=categoryRules[name];
      console.log(selector + ": " + color);
      newRules.push({"selector": selector, "style": {"background-color": color}});
      var selector2 = selector + ":selected";
      newRules.push({"selector": selector2, "style": {"border-color": "red",
                                                      "background-color": color,
                                                      "border-width": "10px"}});
      });

      // category=unassigned nodes are rendered in grey
   newRules.push({"selector": "node[category='unassigned']",
                     style: {"background-color": "lightgray"}});

     // but get the standard treatment when selected
   newRules.push({"selector": "node[category='unassigned']:selected",
                     style: {"border-color": "red",
                             "background-color": "lightgray",
                             "border-width": "10px"}});

   hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "data received", "");

      // iterate across the tumor ('patient') nodes, add a category attribute, assign
      // a cluster value from the tbl, which will select one of the style rules just
      // created above.

   console.log("starting tumorsInGraph.forEach");
   cwMarkers.batch(function() {
      tumorsInGraph.forEach(function(node, index){
        var nodeID = node.id();  // our convention is that this is the tumor name, eg, "TCGA.02.0014"
        var indexInTable = tumorsInTable.indexOf(nodeID);
        if(indexInTable >= 0){
           var cluster = tbl[indexInTable][0];
           node.data({category: cluster});
           }
        else{
           node.data({category: "unassigned"});
           }
         }); // forEach
       }); // batch

  console.log("ending tumorsInGraph.forEach");

    // get a copy of the current style, remove any old node-category style rules, add the new ones
    // set this new style

  var oldStyle = cwMarkers.style().json();
     // remove any pre-existing node category rules
  var oldStyleClean = oldStyle.filter(function(e){return(e.selector.indexOf("node[category"));});

  var newStyle = oldStyleClean.concat(newRules);
  cwMarkers.style(newStyle);
  
  postStatus("applyTumorCategorization complete");
  hub.logEventOnServer(thisModulesName, "markersApplyTumorCategorization", "node category assigned", "");

} // applyTumorCategorization
//----------------------------------------------------------------------------------------------------
function doGraphOperation()
{
   var operation = graphOperationsMenu.val();

   switch(operation){
      case "Show All Edges":
         showAllEdges();
         break;
      case "Show Edges from Selected Nodes":
         //showEdgesFromSelectedNodes();
         showEdgesFromSelectedNodes();
         break;
      case "Hide All Edges":
         hideAllEdges();
         break;
      case "Invert Node Selection":
         invertSelection();
         break;
      case "Clear Selections":
         cwMarkers.filter('node:selected').unselect();
         break;
      case "Select All Connected Nodes":
         selectAllConnectedNodes();
         break;
      case "Select All Nodes with Selected Edges":
        selectAllNodesConnectedBySelectedEdges();
        break;
      case "Hide Unselected Nodes":
         cwMarkers.filter("node:unselected").hide();
         break;
      case "Show All Nodes":
         cwMarkers.filter('node:hidden').show();
         break;
      case "Restrict Next Ops to Selected Nodes":
         restrictNextOpsToSelectedNodes();
         break;
      default:
         console.log("unrecoginized graph operation requested from menu: " + operation);
      } // switch

      // restore menu to initial condition, with only title showing
   graphOperationsMenu.val("Network Operations...");

} // doGraphOperation
//----------------------------------------------------------------------------------------------------
function clearSelection ()
{
   cwMarkers.elements().unselect();
}
//----------------------------------------------------------------------------------------------------
function selectFirstNeighbors ()
{
  selectedNodes = cwMarkers.filter('node:selected');
  showEdgesForNodes(cwMarkers, selectedNodes);
}
//----------------------------------------------------------------------------------------------------
function invertSelection ()
{
   selected = cwMarkers.filter("node:selected");
   unselected = cwMarkers.filter("node:unselected");
   selected.unselect();
   unselected.select();
}
//----------------------------------------------------------------------------------------------------
function hideAllEdges ()
{
     // hide all edges besides chromsome edges
  cwMarkers.edges().fnFilter(function(edge) {
     return(edge.data("edgeType") != "chromosome");
     }).hide();

} // hideAllEdges
//----------------------------------------------------------------------------------------------------
function showAllEdges ()
{
   var edgeTypesToDisplay = edgeTypeSelector.val();

   console.log("edgeTypeToDisplay: " + edgeTypesToDisplay);

   if(edgeTypesToDisplay === null){
      return;
      }

   for(var e=0; e < edgeTypesToDisplay.length; e++){
      var type =  edgeTypesToDisplay[e];
      selectionString = '[edgeType="' + type + '"]';
      //console.log(" showAllEdges selection string: " + selectionString);
      cwMarkers.edges(selectionString).show();
      } // for e

} // showAllEdges
//----------------------------------------------------------------------------------------------------
function zoomSelected()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 100);
}
//----------------------------------------------------------------------------------------------------
function handleIncomingIdentifiers(msg)
{
   console.log("Module.markers, handleIncomingIdentifiers");
      // expect 3 payload fields: value, count, source
   var ids = msg.payload.value; 
   if(typeof(ids) == "string")
      ids = [ids];
   //intersectingIDs = hub.intersectionOfArrays(ids, nodeNames())
   intersectingIDs = hub.intersectionOfArrays(ids, nodeIDs());
   console.log("found ids: " + intersectingIDs.length);

   if(intersectingIDs.length > 0){
      selectNodesByID(intersectingIDs);
      }
   else{
      errorMessage = "No overlap with genes or tissue sample IDs:  <br><br>" +
                      ids.join(", ");
      title = ids.length + " unrecognized identifiers";
      console.log("+++++++++++ creating error div");
      $('<div id="markersIncomingIdentifiersErrorDialog" />').html(errorMessage).dialog({title: title, width:600, height:300});
      }

   console.log("about to post status from incoming identifiers");
   postStatus("incoming identifiers: " + ids.length);

   hub.raiseTab(thisModulesOutermostDiv);

} // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
function showEdges()
{
   hideAllEdges();   // is this wise?

   var edgeTypesToDisplay = edgeTypeSelector.val();
   if(edgeTypesToDisplay === null){
      hideAllEdges();
      return;
      }

   var selectedNodes = selectedNodeIDs(cwMarkers);

   //console.log(" newEdgeTypeSelection (" + edgeTypesToDisplay.length + 
   //            "), selectedNodes: " + selectedNodes.length);

   if(selectedNodes.length > 0) { // show edges to and from all selected nodes
     showEdgesForNodes(cwMarkers, selectedNodes);
     }

} // showEdges
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 50);
}
//----------------------------------------------------------------------------------------------------
function selectedNodeIDs(cw)
{
   ids = [];
   noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     ids.push(noi[n].data('id'));
     }
  return(ids);

} // selectedNodeIDs
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }

  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
function showEdgesFromSelectedNodes()
{
   
   var targets = nodeRestriction;
   var selectedNodes = cwMarkers.nodes("node:selected");
   var neighbors = selectedNodes.neighborhood();
   var candidateEdges = neighbors.filterFn(function(e){
       if(e.isEdge()) return (e);
       });

   candidateEdges = candidateEdges.fnFilter(function(edge){
      return(edgeTypeSelector.val().indexOf(edge.data("edgeType")) >= 0);
      });

   if(targets.length === 0){
      candidateEdges.show();
      postStatus("showEdgesFromSelectedNodes");
      return;
      }

   function intersects(array1, array2){
      var size = array1.filter(function(n) {return (array2.indexOf(n) != -1);}).length;
      return(size > 0);
      }

   candidateEdges.filterFn(function(edge){
      var actual=edge.connectedNodes().map(function(node){return node.id();});
      return(intersects(actual, targets));
       }).show();

   postStatus("showEdgesFromSelectedNodes");

} // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function selectSourceAndTargetNodesOfEdges(cw, edges)
{
  //var eoi = cwMarkers.filter('edge:visible');
  var notChromosomal = function(edge){return(edge.data("edgeType") !== "chromosome");};
  eoi = edges.filterFn(notChromosomal);

  var filterStrings = [];

  for(var i=0; i < eoi.length; i++){
     edge = eoi[i];
     targetID = edge.target().data("id");
     sourceID = edge.source().data("id");
     var sourceFilterString = '[id="' + sourceID + '"]';
     var targetFilterString = '[id="' + targetID + '"]';
     filterStrings.push(sourceFilterString);
     filterStrings.push(targetFilterString);
     } // for i

   var nodesToSelect = cw.nodes(filterStrings.join());
   nodesToSelect.select();

} // selecteSourceAndTargetNodesOfEdge
//----------------------------------------------------------------------------------------------------
// todo: massive inefficiencies here
function showEdgesForNodes(cw, nodes)
{

  var edgeTypes = edgeTypeSelector.val();
  console.log("=== showEdgesForNodes, edgeType count: " + edgeTypes.length);
  //console.log(edgeTypes);

  if(edgeTypes.length === 0)
      return;

  var filterStrings = [];

  setTimeout(function(){
     for(var e=0; e < edgeTypes.length; e++){
        var edgeType = edgeTypes[e];
        for(var n=0; n < nodes.length; n++){
          var nodeID = nodes[n].data("id");
          var sourceFilterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
          var targetFilterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
          filterStrings.push(sourceFilterString);
          filterStrings.push(targetFilterString);
          } // for n
        } // for e

      //console.log("filterString count: " + filterStrings.length);
      filter = filterStrings.join();
      //console.log("filter created, about to apply...");
      var existingEdges = cw.edges(filter);
      //console.log("filtering complete");
      if(existingEdges.length > 0) {
         //console.log("about to show edges");
         existingEdges.show();
         //console.log("edges shown...");
         }
     }, 0); // setTimeout

} // showEdgesForNodes
//----------------------------------------------------------------------------------------------------
function selectAllConnectedNodes()
{
    var selectedEdges = cwMarkers.filter("edge:visible");
    selectedEdges = selectedEdges.filterFn(function(e){return (e.data("edgeType") !== "chromosome");});
    if(selectedEdges.length > 0)
       selectSourceAndTargetNodesOfEdges(cwMarkers, selectedEdges);

} // selectAllConnectedNodes
//----------------------------------------------------------------------------------------------------
function selectAllNodesConnectedBySelectedEdges()
{
    edges = cwMarkers.filter("edge:selected");
    console.log(" selected edge count: " + edges.length);
    if(edges.length === 0)
      return;
    for(var e=0; e < edges.length; e++){
       selectNodes(edges[e].target().data("name"));
       selectNodes(edges[e].source().data("name"));
       } // for e

} //selectAllNodesConnectedBySelectedEdges
//----------------------------------------------------------------------------------------------------
function showEdgesForSelectedNodes(cw, edgeTypes)
{
   var nodeIDs = selectedNodeIDs(cw);
   for(var n=0; n < nodeIDs.length; n++){
      nodeID = nodeIDs[n];
      for(var e=0; e < edgeTypes.length; e++){
         edgeType = edgeTypes[e];
         filterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         filterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         } // for e
      } // for n

} // showEdgesForSelectedNodes
//----------------------------------------------------------------------------------------------------
function restrictNextOpsToSelectedNodes()
{
  var nodes = cwMarkers.nodes("node:selected"); // .filter("[nodeType='gene']");
  if(nodes.length === 0){
     nodeRestriction = [];
     }
  else{
     nodeRestriction = nodes.map(function(node){return (node.id());});
     }

} // restrictNextOpsToSelectedNodes
//----------------------------------------------------------------------------------------------------
function nodeNames()
{
  var nodes = cwMarkers.filter("node:visible");
  var result = [];
  for(var i=0; i < nodes.length; i++){
    result.push(nodes[i].data().label);
    } // for i

  return(result);

} // nodeNames
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
   return(cwMarkers.nodes().map(function(node){return (node.id());}));
}
//----------------------------------------------------------------------------------------------------
function upperCaseNodeIDs()
{
   return(nodeIDs().map(function(node){return(node.toUpperCase());}));
}
//----------------------------------------------------------------------------------------------------
// todo: build up the filter string first, then send it all at once
function selectNodes(nodeNames)
{
  console.log("Module.markers::selectNodes");
  //console.log(nodeNames);

  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  var allNodes = cwMarkers.nodes().map(function(n){return (n.id());});
  var allNodesUpperCase = allNodes.map(function(name){return (name.toUpperCase());});

  for(var i=0; i < nodeNames.length; i++){
    var nodeName = nodeNames[i].toUpperCase();  // depends upon this conv
    var index = allNodesUpperCase.indexOf(nodeName);
    if(index >= 0){
      var actualNodeID = allNodes[index];
      var s = "cwMarkers.filter('node[id=\"" + actualNodeID + "\"]').select()";
       //console.log("markers selectNodes: " + s);
       eval (s);
       } // if found, index >= 0
    } // for i

   postStatus("nodes selected: " + allNodes.length);

} // selectNodes
//----------------------------------------------------------------------------------------------------
// todo: build up the filter string first, then send it all at once
function selectNodesByID(nodeIDs) {

  if(typeof(nodeIDs) == "string")   // trap scalar, but expect and support arrays
     nodeIDs = [nodeIDs];

  console.log("about to select nodes by id: " + nodeIDs.length);
  console.log(nodeIDs);

  for(var i=0; i < nodeIDs.length; i++){
    s = "cwMarkers.filter('node[id=\"" + nodeIDs[i] + "\"]').select()";
    console.log(s);
    eval (s);
    } // for i

} // selectNodesByID
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
   var keyCode = e.keyCode || e.which;

   if (keyCode == 13) {
      var searchString = searchBox.val().toUpperCase();
      if(searchString.length === 0)
         return;
      console.log("searchString: " + searchString);
      var idsActual = nodeIDs();
      var idsUpper = upperCaseNodeIDs();
      var hits = idsUpper.filter(function(id) {return(id.indexOf(searchString) === 0);});
      var hitIndices = hits.map(function(hit) {return(idsUpper.indexOf(hit));});
      var hitsActual = hitIndices.map(function(hit) {return(idsActual[hit]);});
      selectNodes(hitsActual);
      } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function displayMarkersNetwork(msg)
{
   console.log("--- Module.markers: displayMarkersNetwork");

   hub.logEventOnServer(thisModulesName, "display markers network", "data received", "");

   if(msg.status == "success"){
         console.log("nchar(network): " + msg.payload.length);
         var json = JSON.parse(msg.payload);
             cwMarkers.remove(cwMarkers.edges());
           cwMarkers.remove(cwMarkers.nodes());
           console.log(" after JSON.parse, json.length: " + json.length);
           console.log("  about to add json.elements");
           cwMarkers.add(json.elements);
           cwMarkers.style(json.style);
           cwMarkers.edges().hide();
         cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
         cwMarkers.filter("edge[edgeType='chromosome']").show();
         cwMarkers.nodes().unselect();
           // map current node degree into a node attribute of that name, 
           // save the initial width and height to restore values after zooming.
         cwMarkers.nodes().map(function(node){node.data({degree: node.degree(), 
                                                         trueWidth: node.width(), 
                                                         trueHeight: node.height()});});
   
         var edgeTypes = hub.uniqueElementsOfArray(cwMarkers.edges().map(function(edge){
                                  return(edge.data("edgeType"));}
                                  ));
         updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
         cwMarkers.fit(20);
         
      var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
                                         return({id:n.id(), position:n.position()});}));
      localStorage.markersDefault = defaultLayout;
      defaultPatientNodeColor = cwMarkers.nodes("[nodeType='patient']").style("background-color");

      hub.logEventOnServer(thisModulesName, "display markers network", "complete", "");

        //postStatus("markers network displayed");  // deferred; set when the category menu is configured

      hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames", "request", "");

      var msg2 = {cmd: "getSampleCategorizationNames", callback: "configureSampleCategorizationMenu",
                  status: "request", payload: ""};
      hub.send(JSON.stringify(msg2));
      }
   else{
     console.log("displayMarkersNetwork error: " + msg.payload);
     }

} // displayMarkersNetwork
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// ensure that only edgeTypes in current network are offered in the selection widget
function updateEdgeSelectionWidget(edgeTypes)
{
     // loop over currently offered edge types
     //             <option value="mutation" class="btn-info" selected>Mut</option>

   var edgeTypeMenu = $("#markersEdgeTypeSelector");
   edgeTypeMenu.find('option').remove();
   edgeTypeMenu.trigger("chosen:updated");
   
   edgeTypes = edgeTypes.filter(function(e){return(e !== "chromosome");});

   for(var i=0; i < edgeTypes.length; i++){
      var name = edgeTypes[i];
      var optionMarkup =  "<option value='" + name + "' class='btn-info' selected>" + name + "</option>";
      $("#markersEdgeTypeSelector").append(optionMarkup);
      }
      
   $("#markersEdgeTypeSelector").trigger("chosen:updated");

} // updateEdgeSelectionWidget
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the g.markers.json network from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

   hub.logEventOnServer(thisModulesName, "display markers network", "request", "");

   var newMsg = {cmd: "getMarkersNetwork",  callback: "displayMarkersNetwork", status: "request", payload: datasetName};
   hub.send(JSON.stringify(newMsg));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function configureSampleCategorizationMenu(msg)
{
   console.log("=== configureSampleCategorizationMenu");
   //console.log(msg.payload);
   tumorCategorizationsMenu.empty();
   var categorizations = msg.payload;

   if(typeof categorizations == "string") 
   	 categorizations = [categorizations];

   var titleOption = "Tumor Groups...";

   tumorCategorizationsMenu.append("<option>" + titleOption + "</option>");
   tumorCategorizationsMenu.append("<option>Clear</option>");

   for(var i=0; i < categorizations.length; i++){
     tumorCategorizationsMenu.append("<option>" + categorizations[i] + "</option>");
     } // for i

   tumorCategorizationsMenu.val(titleOption);
   hub.logEventOnServer(thisModulesName, "getSampleCategorizationNames",  "complete", "");
   
   hub.enableTab(thisModulesOutermostDiv);
   postStatus("markers network displayed");

} // configureSampleCategorizationMenu
//----------------------------------------------------------------------------------------------------

 return{
     init: function(){
        hub.addMessageHandler("sendSelectionTo_MarkersAndPatients", handleIncomingIdentifiers);
        hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
        hub.addMessageHandler("datasetSpecified", datasetSpecified);
        hub.addMessageHandler("displayMarkersNetwork", displayMarkersNetwork);
        hub.addMessageHandler("configureSampleCategorizationMenu", configureSampleCategorizationMenu);
        hub.addMessageHandler("markersApplyTumorCategorization", applyTumorCategorization);
        hub.addOnDocumentReadyFunction(initializeUI);
       }
     };

   }); // markersAndTissuesModule
//----------------------------------------------------------------------------------------------------
markersModule = markersAndTissuesModule();
markersModule.init();

// markersAndSamples/Test.js
//------------------------------------------------------------------------------------------------------------------------
var MarkersAndSamplesTestModule = (function () {

       // for observing relatively small scale status changes: i.e., network loaded and displayed
       // the div watched here is in widget.html

    var markersAndSamplesStatusObserver = null;
    var testStatusObserver = null;   // modified at the end of each dataset test

    var minorStatusDiv = "#markersAndPatientsStatusDiv";
    var majorStatusDiv = "#markersTestStatusDiv";

       // to detect when the full test of a dataset is complete, so that the next dataset can be tested
       // the div watched here is in test.html


//------------------------------------------------------------------------------------------------------------------------
function runTests(datasetNames, reps, exitOnCompletion)
{
     // run through <reps> repetitions of the test
     // condition the next test upon the completion of the preceeding one,
     // which is detected by a change to the majorStatusDiv
     // minorStatusDiv is used to gate successive tests applied -within-
     // a dataset
     
      
   console.log("===================================== Test.markers: runTests");
   console.log("Test.markers: runTests: " + JSON.stringify(datasetNames));
   console.log("reps: " + reps);
   console.log("exitOnCompletion: " + exitOnCompletion);
   
   var datasetIndex = -1;
   
   var config = {attributes: true, childList: true, characterData: true};
   var target =  document.querySelector(majorStatusDiv);

      // define a function to be called whenever the testStatusDiv changes,
      // which is our signal that the next test is ready to run.
      // the first test is kicked off when we -- after setting up and
      // configuring the observer -- manually (see below: "start testing")
      // change the target which the observer watches.
      // there may be a better way, but for now we delete and recreate
      // the observer at the end of each test.
      // note also that the next dataset is determined inside this function
      // and that the function refers to itself.

   var onMutation = function(mutations){
      mutation = mutations[0];
      testStatusObserver.disconnect();
      testStatusObserver = null;
      var id = mutation.target.id;
      var msg = $(majorStatusDiv).text();
      console.log("test status changed, text: " + msg);
      datasetIndex++;
      if(datasetIndex < (datasetNames.length * reps)){
         console.log("about to test dataset " + datasetNames[datasetIndex]);      
         testStatusObserver = new MutationObserver(onMutation);
         testStatusObserver.observe(target, config);
         if(datasetIndex < (datasetNames.length * reps))
            testLoadDataSetDisplayNetworkSendIDs(datasetNames[datasetIndex % datasetNames.length]);
         }
      else{
         console.log("mutation observer function detected end of datasets");
         if(exitOnCompletion){
            var payload = {errorCount: Object.keys(sessionStorage).length,
                           errors: JSON.stringify(sessionStorage)};
            var exitMsg = {cmd: "exitAfterTesting", callback: "", status: "request", payload: payload};
            console.log("about to send exitAfterTesting msg to server");
            hub.send(JSON.stringify(exitMsg));
            } // if exitOnCompletion
         } // else: datasets exhaused
      };

   testStatusObserver = new MutationObserver(onMutation);
   testStatusObserver.observe(target, config);

   $(majorStatusDiv).text("start testing");

} // runTests
//------------------------------------------------------------------------------------------------------------------------
function testLoadDataSetDisplayNetworkSendIDs(dataSetName)
{
   var testTitle = "testLoadDataSetDisplayNetworkSendIDs";
   console.log(testTitle);

      // when our module receives the resulting 'datasetSpecified' msg, which includes the dataset's manifest
      // in its payload, it requests 
      //   - the markers network: to be displayed by cyjs
      //   - sampleCategorizationNames, to populate the dropdown menu
      // when the network is loaded, the statusDiv is updated, which is detected here, and we
      // check to see that a reasonable number of nodes are contained in the loaded graph.
      // when those tests are over, we then cascade through a number of gui operations: search, node selections
      // network operations

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        hub.raiseTab("markersAndPatientsDiv");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#markersAndSamplesStatusDiv").text();
        QUnit.test("markersAndSamples loaded: " + dataSetName, function(assert) {
           var nodeCount = cwMarkers.nodes().length;
           var edgeCount = cwMarkers.edges().length;
           console.log("markersAndSamples loaded, with " + nodeCount + " nodes and " + edgeCount + " edges.");
           assert.ok(nodeCount > 10, dataSetName + " nodeCount > 10");
           assert.ok(edgeCount > 10, dataSetName + " edgeCount > 10");
           testSearchAndSelect();
           });
        }); // new MutationObserver
      } // if null mutation observer


   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload:  dataSetName};

   console.log("about to send specifyCurrentDataset msg to server: " + dataSetName);
   hub.send(JSON.stringify(msg));

} // testLoadDataSetDisplayNetworkSendIDs
//------------------------------------------------------------------------------------------------------------------------
//   1) clear selection
//   2) find the node with highest degree
//   3) select that node
//   4) test that it is selected
function testSearchAndSelect()
{
   var title = "testSearchAndSelect";
   console.log("--- Test.markers " + title);
   var searchBoxID = "#markersAndTissuesSearchBox";
   var searchBox = $(searchBoxID);
   cwMarkers.nodes().unselect();
   searchBox.val("");

      // all nodes have a "degree" data attribute, a count of its edges.  find the 
      // most connected patient node

   var nodes = cwMarkers.nodes().filterFn(function(node){return (node.data("nodeType") === "patient");});
   var nodesByDegree = nodes.map(function(node){return {id:node.data("id"), degree:node.degree()};});
   var mySort = function(a,b) {return(b.degree - a.degree);};
   var mostConnectedNode = nodesByDegree.sort(mySort)[0];
   var highestDegree = mostConnectedNode.degree;
   console.log("mostConnectedNode: " + JSON.stringify(mostConnectedNode));

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
         mutation = mutations[0];
         markersAndSamplesStatusObserver.disconnect();
         markersAndSamplesStatusObserver = null;
         var id = mutation.target.id;
         var statusMsg = $(minorStatusDiv).text();
         QUnit.test(title, function(assert) {
            console.log("-- in QUnit.test for testSearchAndSelect " + 7 + "  statusMsg: " + statusMsg);
            var selectedNode = cwMarkers.filter("node:selected").map(function(node){return node.id();});
            assert.equal(selectedNode.length, 1, "exactly 1 selected node");
            assert.equal(selectedNode, mostConnectedNode.id, "selected node has highest degree");
            testShowEdgesFromSelectedNode();
            });
         }); // new MutationObserver
      } // if observer null
      
   markersAndSamplesStatusObserver.observe(target, config);
   searchBox.val(mostConnectedNode.id);
   searchBox.trigger(jQuery.Event("keydown", {which: 13}));

}  // testSearchAndSelect
//------------------------------------------------------------------------------------------------------------------------
//   1) one and only one node, the one with highest degree, is already selected.
//   2) manipulate the graphOperations menu to "Show Edges from Selected Nodes"
//   3) the number of edges should equals sum of
//       a) the always-visible chromsome edges
//       b) the degree of the selected node
function testShowEdgesFromSelectedNode()
{
   var title = "testShowEdgesFromSelectedNode";
   console.log("--- Test.markers " + title);

   var degree = -1;
   var chromosomeEdgeCount = -1;

   QUnit.test(title + " initially just one node selected, chromomsome edges visible", function(assert){
      var selectedNode = cwMarkers.filter("node:selected");
      assert.equal(selectedNode.length, 1, "still just one node selected");
      degree = selectedNode.degree();
      assert.ok(degree > 0, "degree > 0");
        // our convention is that chromosome edges are always visible.  get the count
      chromosomeEdgeCount = cwMarkers.edges("edge[edgeType='chromosome']:visible").length;
      console.log("chrom edge count: " + chromosomeEdgeCount);
      assert.ok(chromosomeEdgeCount > 23, "permanently visible chromosome edges found");  // 48 (on 7 dec 2015)
      });
      
   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
    
   if(markersAndSamplesStatusObserver === null){
     console.log("observer is null");
     markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
         mutation = mutations[0];
         markersAndSamplesStatusObserver.disconnect();
         markersAndSamplesStatusObserver = null;
         var id = mutation.target.id;
         var statusMsg = $(minorStatusDiv).text();
         QUnit.test(title, function(assert) {
            var totalEdgeCount = cwMarkers.edges().length;
            var visibleEdgeCount = cwMarkers.edges("edge:visible").length;
            assert.equal(degree + chromosomeEdgeCount, visibleEdgeCount, "visibleEdgeCount correct");
            testSendGoodIDs();
            });
         }); // new MutationObserver
     } // if observer null
      
   markersAndSamplesStatusObserver.observe(target, config);
   var netOpsMenu = $("#cyMarkersOperationsMenu");
   netOpsMenu.val("Show Edges from Selected Nodes");
   netOpsMenu.trigger("change");

}  // testShowEdgesFromSelectedNode
//------------------------------------------------------------------------------------------------------------------------
function testSendGoodIDs()
{
   console.log("entering Test.markers:testSendGoodIDs");

   var title = "testSendIDs";
   console.log(title);
   var maxNodes = 10;
   var totalNodes = cwMarkers.nodes().length; 
   if(maxNodes > totalNodes)
      maxNodes = totalNodes;

      // first test is to clear any existing selection, then send 10 node
      // ids (simple name strings) taken from the network itself.
      // these nodes are sent to the network using hub.send
      // we then check to see that these 10 nodes are selected in cyjs

   cwMarkers.filter("node:selected").unselect();
   var ids = cwMarkers.nodes().map(function(node) {return node.id();}).slice(0, maxNodes);
     // selection of incoming identifiers can be a bit promiscuous.  for instance,
     // sending "Y" will select "Y" and "YWHAE"

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testSendIDs " + 7 + "  statusMsg: " + statusMsg);
           var selectedNodes = cwMarkers.filter("node:selected").map(function(node){return node.id();});
           assert.ok(selectedNodes.length >= maxNodes, "incoming " + maxNodes + " nodes, selected: " +
                     selectedNodes.length);
           testSendBadIDs();
           });
        }); // new MutationObserver
      } // if null mutation observer

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   console.log("testSendIDs, sending " + JSON.stringify(ids));
   var payload = {value: ids, count: ids.length, source: "markers/Test.js::testSendIDs"};
   var msg = {cmd: "sendSelectionTo_MarkersAndPatients", callback: "", status: "request", payload:  payload};

   hub.send(JSON.stringify(msg));

} // testSendGoodIDs
//------------------------------------------------------------------------------------------------------------------------
function testSendBadIDs()
{
   console.log("entering Test.markers:testSendBadIDs");

   var title = "testSendBadIDs";
   console.log(title);
   var maxNodes = 10;
   var totalNodes = cwMarkers.nodes().length; 
   if(maxNodes > totalNodes)
      maxNodes = totalNodes;

      // first test is to clear any existing selection, then send 10 node
      // ids (simple name strings) taken from the network itself.
      // these nodes are sent to the network using hub.send
      // we then check to see that these 10 nodes are selected in cyjs

   cwMarkers.filter("node:selected").unselect();
   var badIDs = ["bogus1", "bogus2", "bogus3"];

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testSendIDs " + 7 + "  statusMsg: " + statusMsg);
           var selectedNodes = cwMarkers.filter("node:selected").map(function(node){return node.id();});
           assert.equal(selectedNodes.length, 0);
           var errorDialog = $("#markersIncomingIdentifiersErrorDialog");
           console.log("error dialog count: " + errorDialog.length);
           var errorText = errorDialog.text();
           console.log("======== badIDs errorText");
           console.log(errorText);
           for(var i=0; i < badIDs.length; i++){
              assert.ok(errorText.indexOf(badIDs[i]) > 0);
              } // for i
           errorDialog.remove();
           testSendMixedIDs();
           });
        }); // new MutationObserver
      } // if null mutation observer

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   console.log("testSendBadIDs, sending " + JSON.stringify(badIDs));
   var payload = {value: badIDs, count: badIDs.length, source: "markers/Test.js::testSendIDs"};
   var msg = {cmd: "sendSelectionTo_MarkersAndPatients", callback: "", status: "request", payload:  payload};

   hub.send(JSON.stringify(msg));

} // testSendBadIDs
//------------------------------------------------------------------------------------------------------------------------
function testSendMixedIDs()
{
   console.log("entering Test.markers:testSendMixedIDs");

   var title = "testSendMixedDs";
   console.log(title);
   var maxNodes = 3;
   var totalNodes = cwMarkers.nodes().length; 
   if(maxNodes > totalNodes)
      maxNodes = totalNodes;

   var goodIDs = cwMarkers.nodes().map(function(node) {return node.id();}).slice(0, maxNodes);

      // first test is to clear any existing selection, then send 10 node
      // ids (simple name strings) taken from the network itself.
      // these nodes are sent to the network using hub.send
      // we then check to see that these 10 nodes are selected in cyjs

   cwMarkers.filter("node:selected").unselect();
   var badIDs = ["bagus1", "begus2", "bigus3"];
   var ids = goodIDs.concat(badIDs);

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testSendIDs " + 7 + "  statusMsg: " + statusMsg);
           var selectedNodes = cwMarkers.filter("node:selected").map(function(node){return node.id();});
           assert.ok(selectedNodes.length >= goodIDs.length);
              // at present (we may wish to change) when some ids work, no error dialog is posted
              /************
              var errorDialog = $("#markersIncomingIdentifiersErrorDialog");
              console.log("error dialog count: " + errorDialog.length);
              var errorText = errorDialog.text();
              console.log("======== mixedIDs errorText");
              console.log(errorText);
              for(var i=0; i < badIDs.length; i++)
                 assert.ok(errorText.indexOf(badIDs[i]) >= 0);
              for(i=0; i < goodIDs.length; i++)
                 assert.equal(errorText.indexOf(goodIDs[i]), -1);
              errorDialog.remove();
              **************/
           testColorTumorsByCategory();
           });
        }); // new MutationObserver
      } // if null mutation observer

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   console.log("testSendIDs, sending " + JSON.stringify(ids));
   var payload = {value: ids, count: ids.length, source: "markers/Test.js::testSendIDs"};
   var msg = {cmd: "sendSelectionTo_MarkersAndPatients", callback: "", status: "request", payload:  payload};

   hub.send(JSON.stringify(msg));

} // testSendMixedIDs
//------------------------------------------------------------------------------------------------------------------------
// the ui provides a pulldown menu for all of the tumor categorizations.  choosing an item from this menu
// causes some or all of the tumor nodes to be rendered in color by category.
// set that menu programmatically, test to see that 
function testColorTumorsByCategory()
{
   console.log("entering Test.markers:testColorTumorsByCategory");

   var title = "testColorTumorsByCategory";
   console.log(title);
     
      // the default state is: no category data attributes on nodes, no category style rules.
      // test the former:
      
   var tumorNodes = cwMarkers.nodes().fnFilter(function(node){ return(node.data("nodeType") == "patient");});
   QUnit.test("no tumor categories to start", function(assert){
      var categories = tumorNodes.map(function(node){node.data("category");});
      var nonNullCategories = categories.filter(function(val){return val;});
      assert.equal(nonNullCategories.length, 0);
      });
      
   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        console.log("mutation observer for testColorTumorsByCategory");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var statusMsg = $(minorStatusDiv).text();
        QUnit.test(title, function(assert) {
           console.log("-- in QUnit.test for testColorTumorsByCategory");
           var categories = hub.uniqueElementsOfArray(tumorNodes.map(function(node){return(node.data("category"));}));
           console.log(" during tumor category test, should be > one category: " + categories.length);
           assert.ok(categories.length > 1);  // more than just the single "unassigned" enforced above;
           //testColorTumorsByClassification();
           markEndOfTestingDataSet();
           });
        }); // new MutationObserver
      } // if null mutation observer

     // the menu value has been changed above.  now elicit action

   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   var allCategoryNames = $("#cyMarkersTumorCategorizationsMenu").children().map(function() {return $(this).val();}).get();
   console.log("--- still setting up testColorTumorsByCateory, names: ");
   console.log(JSON.stringify(allCategoryNames));
   var firstCategory = allCategoryNames[2];  // the 0th name is always the menu title. 1st is "Clear". choose the next one
   $("#cyMarkersTumorCategorizationsMenu").val(firstCategory);
   $("#cyMarkersTumorCategorizationsMenu").trigger("change");

} // testColorTumorsByCategory
//------------------------------------------------------------------------------------------------------------------------
function testColorTumorsByClassification()
{
   var testTitle = "testColorTumorsByClassifictaion";
   console.log(testTitle);

      // TCGA.02.0033 is in all three of our current gbm-related, public, TCGA datasets

   if(markersAndSamplesStatusObserver === null){
      markersAndSamplesStatusObserver = new MutationObserver(function(mutations) {
        //hub.raiseTab("markersAndPatientsDiv");
        mutation = mutations[0];
        markersAndSamplesStatusObserver.disconnect();
        markersAndSamplesStatusObserver = null;
        var id = mutation.target.id;
        var msg = $("#markersAndSamplesStatusDiv").text();
        QUnit.test(title, function(assert) {
           assert.ok(10 === 10, msg);
           });
        markEndOfTestingDataSet();
        }); // new MutationObserver
      } // if null mutation observer


   var config = {attributes: true, childList: true, characterData: true};
   var target = document.querySelector(minorStatusDiv);
   markersAndSamplesStatusObserver.observe(target, config);

   var dataSetName = "TCGAbrain";
   var msg = {cmd: "specifyCurrentDataset", callback: "datasetSpecified", status: "request", payload:  dataSetName};

   hub.send(JSON.stringify(msg));

} // testColorTumors
//------------------------------------------------------------------------------------------------------------------------
function markEndOfTestingDataSet()
{
  console.log("end of testing dataset");
  $(majorStatusDiv).text("dataset complete");
  $("#testManagerLoopStatusDiv").text("Test.markers, datasets complete");
  
} // markEndOfTestingDataSet
//------------------------------------------------------------------------------------------------------------------------
function initialize()
{
   console.log("--- initializing markersAndSamples/Test.js");

} // initialize
//------------------------------------------------------------------------------------------------------------------------
return{
   init: initialize,
   run: runTests
   }; // module return value

//------------------------------------------------------------------------------------------------------------------------
}); // MarkersAndSamplesTestModule
markersTester = MarkersAndSamplesTestModule();
moduleTests.push(markersTester);


//----------------------------------------------------------------------------------------------------
var BlankTabModule = (function () {

  var blankTabDiv;
  var controlsDiv;
  var outputDiv;

  var testButton;

  var sendSelectionsMenu;

  var thisModulesName = "blankTab";
  var thisModulesOutermostDiv = "blankTabDiv";

  var sendSelectionsMenuTitle = "Send selection...";

      // sometimes a module offers multiple selection destinations
      // but usually just the one entry point
  var selectionDestinations = [thisModulesName];
      // make sure to register, eg,
      // hub.addMessageHandler("sendSelectionTo_blankTab", handleSelections);

//--------------------------------------------------------------------------------------------
function initializeUI()
{
  $(window).resize(handleWindowResize);

  blankTabDiv = $("#blankTabDiv");
  controlsDiv = $("#blankTabControlsDiv");
  outputDiv = $("#blankTabOutputDiv");

  testButton = $("#testBlankTabButton");
  testButton.click(runTests);

  sendSelectionsMenu = hub.configureSendSelectionMenu("#blankTabSendSelectionsMenu", 
                                                      selectionDestinations, 
                                                      sendSelections,
                                                      sendSelectionsMenuTitle);

  handleWindowResize();

} // initializeUI
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  blankTabDiv.width($(window).width() * 0.95);
  blankTabDiv.height($(window).height() * 0.90);  // leave room for tabs above

  controlsDiv.width(blankTabDiv.width()); //  * 0.95);
  controlsDiv.height("100px");

  outputDiv.width(blankTabDiv.width()); //  * 0.95);
  outputDiv.height(blankTabDiv.height() - 130);

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();

  var cmd = "sendSelectionTo_" + destination;
  var dummySelections = ["dummy selection 1", "dummy selection 2"];

  payload = {value: dummySelections, count: dummySelections.length, 
             source: thisModulesName};

  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

      // restore default (informational) title of the menu
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function handleSelections(msg)
{
   hub.enableTab(thisModulesOutermostDiv);
   hub.raiseTab(thisModulesOutermostDiv);
   var msgAsString = JSON.stringify(msg.payload);
   
   outputDiv.html("<pre>" + msgAsString + "</pre");


} // handleSelections
//----------------------------------------------------------------------------------------------------
runTests = function()
{
    // tests depend upon the presence of 2 tabs in addition to the present one.
  var datasetsTabPresent = $("#datasetsDiv").length > 0
  var patientHistoryTabPresent = $("#patientHistoryDiv").length > 0

  if(!(datasetsTabPresent && patientHistoryTabPresent)){
     alert("Need both datasets & patientHistory tabs for QUnit testing");
     return;
     } // check for other needed tabs

   outputDiv.css({display: "block"});

   QUnit.test('choose DEMOdz dataset', function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = "DEMOdz";
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value})

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset)
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         testLoadPatientHistoryTable();
         }, 5000);
      });

} // runTests
//----------------------------------------------------------------------------------------------------
function testLoadPatientHistoryTable()
{
   QUnit.test('load patient history table', function(assert) {
       console.log("=============  starting load pt tbl test");
       hub.enableButton($("#selectDatasetButton"));
       $("#selectDatasetButton").trigger("click");
       var done1 = assert.async();
       assert.expect(1);

       setTimeout(function(){
          console.log("-- starting async check");
          assert.equal($("#patientHistoryTable tr").length, 21);
          done1();
          testSelectLongSurvivors();
          }, 5000);
       });

} // testLoadPatientHistoryTable
//----------------------------------------------------------------------------------------------------
function testSelectLongSurvivors()
{
   QUnit.test('testSelectLongSurvivors', function(assert) {
      tbl = $("#patientHistoryTable").DataTable();
      $("#survivalMinSliderReadout").text("8");  // just two DEMOdz patients lived > 8 years
      tbl.draw()
      hub.raiseTab("patientHistoryDiv");
      assert.expect(1);
      var done1 = assert.async()
      setTimeout(function(){
         assert.equal($("#patientHistoryTable tbody tr").length, 2);
         done1();
         testSendToBlankTab();
         }, 5000);
      });

} // testSelectLongSurvivors
//----------------------------------------------------------------------------------------------------
function testSendToBlankTab()
{
   QUnit.test('testSendToBlankTab', function(assert) {
      $("#patientHistorySendSelectionsMenu").val("blankTab");
      $("#patientHistorySendSelectionsMenu").trigger("change");
      assert.expect(0);   // tests (assertions) in next function, testContentsOfBlankTab
      setTimeout(function(){
         hub.raiseTab("blankTabDiv");
         testContentsOfBlankTab();
         }, 5000);
      });

} // testSendToBlankTab
//----------------------------------------------------------------------------------------------------
function testContentsOfBlankTab()
{
   QUnit.test('testContensOfBlankTab', function(assert) {
      assert.equal($("#blankTabOutputDiv").text(), 
                   '{"value":["TCGA.02.0114","TCGA.08.0344"],"count":2,"source":"patient history module"}');
      $("#testingOutputDiv").css({display: "block"});
      });

} // testContentsOfBlankTab
//----------------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
//
function runAutomatedTestsIfAppropriate()
{
   var msg = {cmd: "getUserId",  callback: "blankTabAssessUserIdForTesting",
              status: "request", payload: ""};

   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   var userID = msg.payload;
   console.log("blankTab/Module.js assesUserIdForTesting: " + userID)

   if(userID.indexOf("autoTest") === 0){
      console.log("blankTab/Module.js running tests for user " + userID)
      runTests();
      }

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
   hub.addOnDocumentReadyFunction(initializeUI);
   hub.addMessageHandler("sendSelectionTo_blankTab", handleSelections);
   hub.addMessageHandler("blankTabAssessUserIdForTesting", assessUserIdForTesting)
   hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);
   hub.enableTab(thisModulesOutermostDiv);

} // initializeModule
//----------------------------------------------------------------------------------------------------
return{
   init: initializeModule
   }; // BlankTabModule return value

//----------------------------------------------------------------------------------------------------
}); // BlankTabModule

blankTabModule = BlankTabModule();
blankTabModule.init();



</script>

<body>

<div id="oncoscapeTabs">
   <ul>
     <li><a href="#datasetsDiv">Datasets</a></li>
     <li><a href="#markersAndPatientsDiv">Markers</a></li>
     <li><a href="#markersTestDiv">Tests</a></li>
     <li><a href="#blankTabDiv">Blank Tab</a></li>
   </ul>

<style>
</style>

<div id="datasetsDiv" style="height:auto">
  <div id="datasetsStatusDiv" style="display:none"></div>
  <div id="dataSummaryControlsDiv">
     <span id="selectDataSetMenuLabel" style="margin-left: 20px;">Available Datasets</span>
     <select type="button" id="datasetMenu" style="margin: 5px;"><option> </option></select>
     <button id="selectDatasetButton">Use Dataset</button>
	 <span id="loadingDatasetMessage" style="display:none; margin-left:10px">Loading Dataset...</span>
     <select type="button" id="datasetsSendSelectionsMenu" style="float:right; margin:15px; display: none"></select>
    <div id="oncoscapeLogo" style="float:right; margin-right:0.5em">	<img width="175" src="http://oncoscape.sttrcancer.org/oncoscape/images/oncoscape_logo_TM.png" alt="Oncoscape"/></div>
  </div>

   <div id="dataSetNamesOutputDiv" style="margin: 20px;"></div>

   <div id="dataSummaryOutputDiv" style="margin: 20px;overflow-x:auto">
      <div id="datasetInstructions">Please select a dataset from the above menu.</div>
      <table id="datasetsManifestTable" class="display" cellpadding="0" cellspacing="0" style="margin:0px; width:auto; display:none; border:none"></table>
   </div>
</div>

<style>

#cyMarkersDiv {
  background-color: white;  // medium light gray
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  margin-top: 2px;
  margin-left: 0px;
  padding: 0px;
  }

#cyMarkersDiv select, input, button{
  font-size: 14px;
  }
  
#markersControlsLayoutTable{
  border: 1px solid black;
  margin: 2px;
  width: 100%;
  }

.chosen-container, .chosen-drop .chosen-search input {
   width: 100% !important;
   -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
           box-sizing: border-box;
  }

</style>


<div id="markersAndPatientsDiv">
   <div id="markersAndTissuesControlsDiv">
      <table id="markersControlsLayoutTable">
         <tr>
           <td style="width:25%">
             <input type="text" id="markersAndTissuesMouseOverReadout" disabled
                    title="Edge and node names displayed here on hover"  style="width:80%; margin-right:2px"></input>
             <input type="text" id="markersSelectionCountReadout", disabled
                    title="Selected node count" style="width: 40px;"></input>

           </td>
   
           <td style="width:20%">
             <select id="cyMarkersOperationsMenu" style="float:right; margin-right:5px">
             </select>
           </td>

           <td style="width:10%">
             <select id="cyMarkersTumorCategorizationsMenu">
             </select>
           </td>
         
           <td style="width:30%">
             <select class="SelectionMenu" type="button" id="cyMarkersSendSelectionsMenu"
                     style="float:right; margin-right:5px">
            </select>
          </td>
         </tr>
    
      <tr>
          <td>
           <input type="text" id="markersAndTissuesSearchBox" placeholder="search" ></input>
           <button id="markersFitViewButton" title="Restore Initial View">Fit</button>
           <button id="markersShowEdgesFromSelectedButton" title="Show Edges from Selected Nodes">Show</button>
           <button id="markersHideEdgesButton" title="Hide Edges">Hide</button>
           <button id="markersZoomSelectedButton" title="Zoom into selected nodes">Zoom</button>
          </td>
    
          <td>
           <select id="markerLayouts" style="float:right; margin-right:5px">
           </select>
          </td>
          <td>
            <button id="markersSubSelectButton">Subselect</button>
          </td>

          <td>
             <select id="markersEdgeTypeSelector" 
                class="chosen-select form-control dropdown navbar-form selectpicker SelectionMenu"
                 multiple>
            </select>
          </td>
      </tr>
    
    </table>
    </div>
   
   
 <div id="cyMarkersDiv" data-toggle="tooltip" class="content" style="margin:0 auto" ></div>

 <div id="bottomMargin" style="width:100%;height:30px margin:0 auto"></div>

</div>




<div id="markersTestDiv">
  <div id="markersTestStatusDiv"        style="display:none"></div>
  <div id="markersAndPatientsStatusDiv" style="display:none"></div>
  <div id="qunit" style="display:block"></div>
  <div id="qunit-fixture"></div>
</div>



<style>


#blankTabDiv{
   width: 600px;
   height: 400px;
   background-color: #f0f0f0;
   margin: auto;
   padding: 5px;
   }


#blankTabControlsDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  border-radius: 5px;
  margin-right: auto;
  margin-left: auto;
  margin-top: 10px;
  margin-bottom: 5px;
  padding: 0px;
  }

#blankTabOutputDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  border-radius: 5px;
  margin-right: auto;
  margin-left: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  padding: 0px;
  }

</style>


<div id="blankTabDiv">


  <div id="blankTabControlsDiv">  
     <button id="testBlankTabButton" style="margin: 20px">QUnit test</button>
     <select type="button" id="blankTabSendSelectionsMenu" style="float:right; margin:15px"></select>
  </div>

  <div id="testingOutputDiv" style="display: none">
     <div id="qunit"></div>
     <div id="qunit-fixture"></div>
  </div>

  <div id="blankTabOutputDiv">  
  </div>



</div>

</div>

</body>
</html>
