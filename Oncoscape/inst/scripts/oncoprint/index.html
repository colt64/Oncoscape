




<!DOCTYPE html> 
<html>

<head>
   <meta charset="UTF-8">
   <title> OncoDev 1.4</title>

   <script src="http://code.jquery.com/qunit/qunit-1.18.0.js"></script>
   <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.18.0.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-2.1.3.min.js"></script>
   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-1.11.2.min.js"></script-->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery-ui-1.11.4.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.7/themes/smoothness/jquery-ui.css">

   <!-- script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.3.10.min.js"></script -->
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/cytoscape-2.4.4.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.cytoscape.js-panzoom.js"></script>
   <link   href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.cytoscape.js-panzoom.css" 
           rel="stylesheet" 
           type="text/css">


   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/d3.min.js"></script>

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.dataTables-1.10.5.min.js"></script>
   <link   rel="stylesheet" type="text/css"
           href="http://oncoscape.sttrcancer.org/oncoscape/css/jquery.dataTables-1.10.5.min.css">

   <script src="http://cdn.datatables.net/colvis/1.1.0/js/dataTable.colVis.js"></script>

   <link   rel="stylesheet" type="text/css"
           href="http://cdn.datatables.net/colvis/1.1.0/css/dataTables.colVis.css">

   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/jquery.multi-select.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/multi-select.css" media="screen" rel="stylesheet" type="text/css">
   <script src="http://oncoscape.sttrcancer.org/oncoscape/js/chosen.jquery.min.js" type="text/javascript"></script>
   <link href="http://oncoscape.sttrcancer.org/oncoscape/css/chosen.min.css" media="screen" rel="stylesheet" type="text/css">


<script> 
//--------------------------------------------------------------------------------------------------
// hooks for google analytics

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-528883-29', 'auto');
  ga('send', 'pageview');
//--------------------------------------------------------------------------------------------------
</script> 

</head>

<style>

.flex-container {
  display: -webkit-flex;
  display: flex;
  }

.ui-slider-range {
   background-image: none;
   background: lightgrey;
   }

th,td {
   font-size:12px;
   }

.patientDataFilterSliderReadout{
   font-size: 10px;
   height:16px;
   }

.ui-tabs .ui-tabs-nav li a{
   font-size:10pt !important;
   }

.ui-button .ui-button-text{
   font-size:10pt !important;
   }


</style>


<style>
.oncoprint-toolbar-ctr {
	display: inline-block;
	vertical-align: top;
	float: right;
}
.oncoprint-label-area-ctr {
	float:left;
	overflow: auto;
	width: auto;
}
.oncoprint-cell-area-ctr {
	overflow: auto;
	width: auto;
	position:relative;
}

.oncoprint-cell-area {
	background-color: transparent;
    	position: relative;
}

.oncoprint-column-highlight {
	position:absolute;
	width: 1px;
	border-left: 1px dashed rgba(0,0,0,0.75);
	top: 0px;
}

.oncoprint-cell {
	position: absolute;
}

.oncoprint-animated {
	-webkit-transition: 0.5s ease-out;
	-moz-transition: 0.5s ease-out;
	-o-transition: 0.5s ease-out;
	transition: 0.5s ease-out;
}

.oncoprint-cell-hover {
	outline: 1px solid DarkGray;
	position: absolute;
}

.oncoprint-legend-header {
	font-family: Arial !important;
	font-weight: bold !important;
	fill: gray !important;
	text-anchor: start;
	alignment-baseline: hanging;
	font-size: 12px;
	padding-right: 30px;
}

.oncoprint-legend-label {
	font-family: Arial;
	alignment-baseline: hanging;
	font-size: 12px;
}

.oncoprint-legend-block {
	display: inline-block;
}
.oncoprint-legend-element {
	display: inline-block;
}

.oncoprint-track-label {
	font-size: 12px;
}

.oncoprint-track-label-draggable {
	cursor: move;
}
.oncoprint-label-dragging {
	font-weight: bold !important;
	color: #ff0000;
}

.noselect {
	-webkit-touch-callout: none;
    	-webkit-user-select: none;
    	-khtml-user-select: none;
    	-moz-user-select: none;
    	-ms-user-select: none;
    	user-select: none;
}

.oncoprint-cell-qtip {
	background-color: rgba(0,0,0,0) !important;
	//border: none !important;
}
.oncoprint-cell-qtip .qtip-content {
	background-color: rgba(255,255,255,0.92) !important;
	font-size: 13px !important;
}
</style>
<link rel="stylesheet" type="text/css" href="http://cdn.jsdelivr.net/qtip2/2.2.1/jquery.qtip.min.css">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
<script type="text/javascript" src="http://cdn.jsdelivr.net/qtip2/2.2.1/jquery.qtip.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore.js"></script>
<script>
//----------------------------------------------------------------------------------------------------
// These javascript functions and variables are arranged into a simple module so that
// implementation details are kept private from the public API other oncoscape 
// browser modules will use.  common services and utility functions are provided here
//----------------------------------------------------------------------------------------------------
var HubModule = (function () {

  var name = "HubModule";
     // keys are module names, their outermost divs are the values.
     // providing these outermost divs allows was inspired by 
     // the need to allow raising of tabs by the sending tab.
     // TODO: not sure that's still needed

  var selectionDestinations = {};
  var dispatchOptions = {};
  var socketIsConnected = false;
  var socketConnectedFunctions = [];
  var onDocumentReadyFunctions = [];
  var socketURI = window.location.href.replace("http://", "ws://");
  var socket;

  var  messagingRestrictedToLogin = false;

  var modules = {};
//----------------------------------------------------------------------------------------------------
function registerModule(name, moduleObject)
{
   modules[name] = moduleObject;

} // registerModule
//----------------------------------------------------------------------------------------------------
function getModules()
{
   return modules;

} // getModules
//----------------------------------------------------------------------------------------------------
// TODO: add 3rd argument: acceptsIncomingMessages
//       datasets, for instance, seems to have no need for incoming json/websocket messages
function registerSelectionDestination(names, outermostDivID)
{
  if(typeof(names) == "string")
    names = [names];

  for(var i=0; i < names.length; i++)
     selectionDestinations[names[i]] = outermostDivID;

} // registerSelectionDestination
//----------------------------------------------------------------------------------------------------
function getRegisteredSelectionDestinations()
{
  return(selectionDestinations);

} // getRegisteredSelectionDestinations
//----------------------------------------------------------------------------------------------------
function setupSocket(socket)
{
  console.log("=== Module.hub setupSocket");

  try {
     socket.onopen = function() {
        console.log("websocket connection now open");
        socketIsConnected = true;
        for(var f=0; f < socketConnectedFunctions.length; f++){
           console.log("calling the next sockectConnectedFunction");
           socketConnectedFunctions[f]();
           } // for f
        } // socked.onopen

     socket.onmessage = function got_packet(msg) {
        var msg = JSON.parse(msg.data)
        dispatchMessage(msg)
        } // socket.onmessage, got_packet

     socket.onclose = function(){
        console.log("socket closing");
        } // socket.onclose
     } // try
  catch(exception) {
    console.log("Error: " + exception);
    }
 
  return(socket);

} // setupSocket
//----------------------------------------------------------------------------------------------------
function socketConnected()
{
   return(socketIsConnected);

} // socketConnected
//----------------------------------------------------------------------------------------------------
function addSocketConnectedFunction(func)
{
   socketConnectedFunctions.push(func)

} // addSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function getSocketConnectedFunctions()
{
   return(socketConnectedFunctions)

} // getSocketConnectedFunction
//----------------------------------------------------------------------------------------------------
function addOnDocumentReadyFunction(func)
{
   onDocumentReadyFunctions.push(func)

} // addOnDocumentReadyFunction
//----------------------------------------------------------------------------------------------------
function getOnDocumentReadyFunctions()
{
   return(onDocumentReadyFunctions)

} // getOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
// the nginx proxy server, used by fhcrc IT for the publicly-visible version of Oncoscape
// times out web sockets at 90 seconds.
// this function, when called more often that that, will keep the websocket open.
keepAlive = function()
{   
    //console.log("keep alive"); 
    msg = {cmd: "keepAlive", callback: "", status:"request", payload:""}
    socket.send(JSON.stringify(msg));

} // keepAlive
//--------------------------------------------------------------------------------------------------
function runOnDocumentReadyFunctions()
{
  setInterval(keepAlive, 30000);
  var funcs = getOnDocumentReadyFunctions()
  console.log("==== Module.hub: " + funcs.length + " onDocumentReadyFunctions");

  for (var f = 0; f < funcs.length; f++) {
     console.log("calling on ready function");
     funcs[f]();
     }

} // runOnDocumentReadyFunctions
//----------------------------------------------------------------------------------------------------
function runningInNode()
{
    // a not very sophisticated test, but adequate for our purposes thus far
  return(typeof(window) == "undefined")

} // functionRunningInNode
//----------------------------------------------------------------------------------------------------
function initializeWebSocket()
{
   if(runningInNode()){
     console.log("--- web socket not currently available when runing in Node");
     process.exit(code=1)
     }

   socket = new WebSocket(socketURI);
   socket = setupSocket(socket);

} // initializeWebSocket
//----------------------------------------------------------------------------------------------------
function getSocket()
{
  return(socket);

} // getSocket
//----------------------------------------------------------------------------------------------------
function addMessageHandler(cmd, func)
{
  if(cmd in dispatchOptions){
     dispatchOptions[cmd].push(func)
     }
  else{
     dispatchOptions[cmd] = [func]
     }
  
} // addMessageHandler
//----------------------------------------------------------------------------------------------------
function getRegisteredMessageNames()
{
   return(Object.keys(dispatchOptions));
  
} // getRegisteredMessageNames
//----------------------------------------------------------------------------------------------------
function getDispatchOptions()
{
   return(dispatchOptions);
  
} // getDispatchOptions
//----------------------------------------------------------------------------------------------------
function dispatchMessage(msg)
{
   var cmd = msg.cmd;
   var status = msg.status;
   console.log("====== Mondule.hub dispatchMessage '" + cmd + "' [" + Date() + "]" );

   var dispatchKeys = Object.keys(dispatchOptions);
   var cmdIndex = dispatchKeys.indexOf(cmd);
   console.log("hub.dispatchMessage(" + cmd + "): " + cmdIndex);

   if(cmdIndex === -1){
      console.log("unrecognized socket request: " + msg.cmd);
      console.log(" --- msg:");
      console.log(msg);
      console.log(" --- dispatchOptions");
      console.log(dispatchOptions);
      }
   else{
     var funcs = dispatchOptions[cmd];
     //console.log(" func count for msg cmd " + cmd + ": " + funcs.length);
      for(var i=0; i < funcs.length; i++){
         //console.log("--- Module.hub executing func # " + i + " for cmd " + msg.cmd);
         funcs[i](msg); // dispatchOptions[msg.cmd](msg)
         } // for i
      }

}  // dispatchMessage
//----------------------------------------------------------------------------------------------------
function restrictMessagingToLogin(newState)
{
   messagingRestrictedToLogin = newState;

} // restrictMessagingToLogin
//----------------------------------------------------------------------------------------------------
function send(msg)
{
   var cmd = JSON.parse(msg).cmd;
   if(messagingRestrictedToLogin && cmd === "checkPassword"){
      console.log("hub.send drops non-login msg");
      return;
      }

   var browserLocalCommand = Object.keys(dispatchOptions).indexOf(cmd) >= 0;
   var mode = "server";
   if(browserLocalCommand)
      mode = "browser local";

   console.log("--- hub.send: '" + cmd + "' (" + mode + ")");

   if(browserLocalCommand)
      dispatchMessage(JSON.parse(msg));
   else{
      socket.send(msg);
      }

}  // send
//----------------------------------------------------------------------------------------------------
function setTitle (newTitle)
{
  window.document.title = newTitle;

}  // setTitle
//----------------------------------------------------------------------------------------------------
// add a pulldown menu to the specified menuSelector, which has been provided by the caller, which
// is assumed to be an Oncoscape module.  append the names of all previously-registered divs, 
// except for those explicitly excluded in the incoming argument "excludedModules".
// This supports the usual (but not universal) case: a module does not want to send selections
// to itself.
// this argument will often be an array of one element, the name of the calling module.
// some modules may have multiple send destinations (eg, "PCA" & "PCA (highlight)".
function configureSendSelectionMenu(menuSelector, excludedModules, changeFunction, menuTitle)
{
  var menu = $(menuSelector);
  menu.append("<option>" + menuTitle + "</option>");
  menu.change(changeFunction);
  var otherModules = Object.keys(hub.getRegisteredSelectionDestinations());

  for(var i=0; i < otherModules.length; i++){
     var moduleName = otherModules[i];
     var excluded = excludedModules.indexOf(moduleName) >= 0;
     if(!excluded){
        menu.append("<option>" + moduleName + "</option>");
        }
     } // for i

  return(menu);

} // createSendSelectionMenu
//--------------------------------------------------------------------------------------------
function disableButton(button)
{
   button.prop("disabled", true);
   button.css({"background-color": "lightgray", "color": "gray"});

} // disableButton
//--------------------------------------------------------------------------------------------
function enableButton(button)
{
   button.prop("disabled", false);
   //button.css({ 'color': 'black'})
   button.css({"background-color": "white", "color": "black"});

} // enableButton
//--------------------------------------------------------------------------------------------
// from http://stackoverflow.com/questions/4068373/center-a-popup-window-on-screen
function openCenteredBrowserWindow(url, title, w, h, replaceAnyExistingPopup) {

      // Fixes dual-screen position                       Most browsers      Firefox
    var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
    var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;

    width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
    height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;

    var left = ((width / 2) - (w / 2)) + dualScreenLeft;
    var top = ((height / 2) - (h / 2)) + dualScreenTop;
    var options = 'scrollbars=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left;

    var newWindow;

      // warning, a bug: when multiple popup windows are created, they
      // all have the same content -- not what we want.  fix this
      // by severing their relationship, and/or switching to jQuery dialog

    if(replaceAnyExistingPopup)
      newWindow = window.open(url, title, options);
    else // leave any existing popup windows untouched
      newWindow = window.open(url, "_blank", options);

    if (window.focus) {
       newWindow.focus();
       }

} // openCenteredBrowserWindow
//--------------------------------------------------------------------------------------------
// if jQuery-style tabs are in use with Oncoscape, this function raised the named tab to the
// the front (visible) position in the tabset
// the argument, "tabIDString" is the tab id used in the module's widget.html, reproduced exactly
// in tabsApp/widget.html, with some current examples being
//  pcaDiv, patientTimeLinesDiv, gbmPathwaysDiv
//
function raiseTab(tabIDString)
{
  var tabsWidget = $("#oncoscapeTabs");

  if(tabsWidget.length > 0){
     var selectionString = '#oncoscapeTabs a[href="#' + tabIDString + '"]';
     var tabIndex = $(selectionString).parent().index ();
     if(tabIndex < 0) throw "Module.hub does not recognize tabIDString '" + tabIDString + "'";
     tabsWidget.tabs( "option", "active", tabIndex);
     } // if tabs exist

} // raiseTab
//----------------------------------------------------------------------------------------------------
// each of our tabs is a div, nested directly within $("oncoscapeTabs").  
// this function returns an array of each of the div ids
function getTabDivIDs()
{
   return ($("#oncoscapeTabs").children("div").map(function(index,dom){return dom.id}));

} // getTabDivIDs
//----------------------------------------------------------------------------------------------------
// e.g., hub.hideTab("Login", "#loginDiv");
function hideTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideTab
//----------------------------------------------------------------------------------------------------
function hideAllTabsButOne(tabTitle, tabDivIDstring)
{
  var divIDs = getTabDivIDs();
  
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").hide()
  $(tabDivIDstring).hide();

} // hideAllTabsButOne
//----------------------------------------------------------------------------------------------------
function showTab(tabTitle, tabDivIDstring)
{
  $(".ui-tabs-nav li:contains('" + tabTitle + "')").show()
  $(tabDivIDstring).show();

} // showTab
//----------------------------------------------------------------------------------------------------
function addTab(tabTitle, tabDivIDstring,  content)
{
  var tabs = $("#oncoscapeTabs").tabs()
  var listItem = "<li><a href='#" + tabDivIDstring + "}'>" + tabTitle + "</a>";

  tabs.find(".ui-tabs-nav").append(listItem);
  tabs.append("<div id='" + tabDivIDstring + "'><p>" + content + "</p></div>");
  tabs.tabs("refresh");

} // addTab
//----------------------------------------------------------------------------------------------------
function getRandomFloat (min, max)
{
    return Math.random() * (max - min) + min;
}
//----------------------------------------------------------------------------------------------------
function getRandomInt (min, max) 
{
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
//----------------------------------------------------------------------------------------------------
String.prototype.beginsWith = function (string) 
{
    return(this.toLowerCase().indexOf(string.toLowerCase()) === 0);
};
//----------------------------------------------------------------------------------------------------
uniqueElementsOfArray = function(vector)
{
  var u = {}, a = [];

  for(var i = 0, l = vector.length; i < l; ++i){
     if(u.hasOwnProperty(vector[i])){
       continue;
       }
     a.push(vector[i]);
     u[vector[i]] = 1;
     } // for i

   return a;

} // uniqueElementsOfArray
//----------------------------------------------------------------------------------------------------
// return the targets matched by the candidates, where match is tolerant of differences by suffix
// thus incoming id "TCGA.06.0649.01" matches existing id "TCGA.06.0649" and
//      incoming id "TCGA.06.0649"    matches existing id "TCGA.06.0649.01" 
// this may cause problems with gene names, eg, MYC would mach MYCL and MYCA
// todo: make this suffix-tolerant match suffix-specific 
function intersectionOfArrays(candidates, targets) {

  hits=[]; 

  for(var i=0; i < candidates.length; i++){
    for (var j=0; j < targets.length; j++){
       candidate = candidates[i];
       target = targets[j];
       index1 = candidate.indexOf(target);   // "abc".indexOf("ab") -> 0
       index2 = target.indexOf(candidate); 
       //console.log("c(t): " + candidate + " contains " + target + ": " + index1);
       //console.log("t(c): " + target + " contains " + candidate + ": " + index2);
       if (index1 == 0)
          hits.push(target)
       else if (index2 == 0)
          hits.push(target)
         } // for j
     } // for i

  return(hits)

} // intersectionOfArays
//----------------------------------------------------------------------------------------------------
function setupGlobalExceptionHandler()
{
   window.onerror = function (errorMsg, url, lineNumber, column, errorObj) {

      var title = "Oncoscape Error";
      var options = {buttons: { "Ok": function () { $(this).dialog("close"); } },
                     title: title};
      var text = "<i>" + errorMsg + "</i><br>" +
                 "<br><b>Script</b>: " + url + 
                 "<br><b>Line:</b> " + lineNumber + 
                 "<br><b>Column:</b> " + column + 
                 "<br><b>StackTrace:</b> " +  errorObj;
      $("<div></div>").dialog(options).html(text);
      };
 
} // setupGlobalExceptionHandler
//----------------------------------------------------------------------------------------------------
function start()
{
  setupGlobalExceptionHandler();
  initializeWebSocket();
  $(document).ready(runOnDocumentReadyFunctions);

}  // start
//----------------------------------------------------------------------------------------------------
function test_intersectionOfArrays()
{
   console.log("---  test_intersectionOfArrays");
   var targets = ["TCGA.02.0006"];
   var candidates = ["TCGA.02.0006"];

   QUnit.test("test_intersectionOfArrays 1", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   targets = ["TCGA.02.0006"];
   candidates = ["bogus"];
   QUnit.test("test_intersectionOfArrays 2", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });

   targets = ["bogus"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 3", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), []);
      });


   targets = ["TCGA.02.0006.01"];
   candidates = ["TCGA.02.0006"];
   QUnit.test("test_intersectionOfArrays 4", function(assert) {
      assert.equal(hub.intersectionOfArrays(candidates, targets), candidates);
      });

   //targets = ["MAP2"];   this test will fail because sometimes we want incomplete matches:
   //  see test4 just above
   //candidates = ["MAP2K4", "abc"];
   //QUnit.test("test_intersectionOfArrays 5", function(assert) {
   //   assert.equal(hub.intersectionOfArrays(candidates, targets), []);
   //   });


} //  test_intersectionOfArrays
//----------------------------------------------------------------------------------------------------
function standAloneTest()
{
   test_intersectionOfArrays();

}  // standaloneTest
//----------------------------------------------------------------------------------------------------

  return({
     getName: function() {return(name)},
     restrictMessagingToLogin: restrictMessagingToLogin,
     registerModule: registerModule,
     getModules: getModules,
     registerSelectionDestination: registerSelectionDestination,
     getRegisteredSelectionDestinations: getRegisteredSelectionDestinations,
     socketConnected: socketConnected,
     addSocketConnectedFunction: addSocketConnectedFunction,
     getSocketConnectedFunctions: getSocketConnectedFunctions,
     addOnDocumentReadyFunction: addOnDocumentReadyFunction,
     getOnDocumentReadyFunctions: getOnDocumentReadyFunctions,
     runningInNode: runningInNode,
     initializeWebSocket: initializeWebSocket,
     getSocket: getSocket,
     addMessageHandler: addMessageHandler,
     getRegisteredMessageNames: getRegisteredMessageNames,
     getDispatchOptions: getDispatchOptions,
     dispatchMessage: dispatchMessage,
     configureSendSelectionMenu: configureSendSelectionMenu,
     enableButton: enableButton,
     disableButton: disableButton,
     getRandomInt: getRandomInt,
     getRandomFloat: getRandomFloat,
     intersectionOfArrays: intersectionOfArrays,
     uniqueElementsOfArray: uniqueElementsOfArray,
     send: send,
     setTitle: setTitle,
     getTabDivIDs: getTabDivIDs,
     raiseTab: raiseTab,
     hideTab: hideTab,
     showTab: showTab,
     addTab: addTab,
     openCenteredBrowserWindow: openCenteredBrowserWindow,
     sat: standAloneTest,
     start: start
     });

}); // HubModule
//----------------------------------------------------------------------------------------------------


var hub = HubModule();
hub.start();

hub.addOnDocumentReadyFunction(function() {
    console.log("====== tabapps document ready");
    window.tabsAppRunning = true
    $("#oncoscapeTabs").tabs({
         // todo: distinguish between tabs, only do needed resets
       activate: function(event, ui) {
            console.log(" tabsApp/code.js:activate");
            var tableRef = $("#historyTable").dataTable();
            var tableRef2 = $("#userDataStoreTable").dataTable();
            if (tableRef.length > 0) {
               console.log("   adjusting patient history table");
               tableRef.fnAdjustColumnSizing();
               } // if
            if (tableRef2.length > 0) {
               console.log("   skipping! - adjusting user data store table");
               tableRef2.fnAdjustColumnSizing();
               } // if
            //console.log(" ==== tab.activate, possible cyjs resize and fit");
            if(typeof(cwMarkers) != "undefined") {
               console.log("adjusting cwMarkers");
               cwMarkers.resize(); 
               cwMarkers.fit(50);
               //console.log("done adjusting cwMarkers");
               }
            if(typeof(cyGbm) != "undefined") {
               //console.log("adjusting cwGbm");
               cyGbm.resize();
               cyGbm.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cwAngio) != "undefined") {
               //console.log("adjusting cwAngio");
               cwAngio.resize();
               cwAngio.fit(50);
               //console.log("done adjusting cwGbm");
               }
            if(typeof(cyPathway) != "undefined") {
               cyPathway.resize();
               cyPathway.fit(50);
               }
            } // activate
        }); // tabs
    });  // ready



</script>
<style>
.ui-tabs .ui-tabs-nav li a {font-size:10pt !important;}
.ui-button .ui-button-text {font-size:10pt !important;}
</style>


<script>
//----------------------------------------------------------------------------------------------------
var DataSummaryModule = (function () {

  var dataSummaryDiv;

  var outputDiv;
  var dataSetNamesOutputDiv;
  var thisModulesName = "datasets";
  var thisModulesOutermostDiv = "datasetsDiv";

  var tableElement;
  var tableRef;
  var datasetMenu;
  var selectedDataSet;
  var useThisDatasetButton;

  var sendSelectionsMenu;
  var sendSelectionsMenuTitle = "Send selection...";
  var passwordProtected = false;

//----------------------------------------------------------------------------------------------------
function initializeUI()
{
  sendSelectionsMenu = hub.configureSendSelectionMenu("#datasetsSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                       sendSelectionsMenuTitle);

  hub.disableButton(sendSelectionsMenu);

  $(window).resize(handleWindowResize);
  datasetMenu = $("#datasetMenu");
  datasetMenu.change(selectManifest);

  dataSetNamesOutputDiv = $("#dataSetNamesOutputDiv");
  dataSummaryDiv = $("#dataSummaryOutputDiv");

  useThisDatasetButton = $("#selectDatasetButton");
  useThisDatasetButton.button();
  hub.disableButton(useThisDatasetButton);
  useThisDatasetButton.click(specifyCurrentDataset);

  outputDiv = $("#dataSummaryOutputDiv");
  tableElement = $("#datasetsManifestTable");
      
    // if no login tab is present, then allow unrestricted choice of datasets.
    // if it IS present, then that tab will control this.

  var loginRequired = $("#loginDiv").length === 1;
  console.log("loginRequired? " + loginRequired);

  if(!loginRequired){
    console.log(" enabling datasetMenu");
    hub.enableButton($("#datasetMenu"));
    }
  else{
    console.log(" disabling datasetMenu");
    hub.disableButton($("#datasetMenu"));
    }

   populateDataSetMenu();

} // initializeUI
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
   $("#datasetsStatusDiv").text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  $("#"+thisModulesOutermostDiv).width($(window).width() * 0.95);
  $("#"+thisModulesOutermostDiv).height($(window).height() * 0.95);

//  console.log("  div: " + outputDiv.width());
//  console.log("  tbl before: " + tableElement.width());
//  tableElement.width($(window).width() * 0.50);
//  console.log("  tbl after: " + tableElement.width());

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   var cmd = "sendSelectionTo_" + destination;
   payload = "dummy payload";
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//----------------------------------------------------------------------------------------------------
function selectManifest(event)
{
   selectedDataSet = datasetMenu.val();
   console.log("dataset '" + selectedDataSet + "'");

   if(selectedDataSet === ""){
     // outputDiv.empty();
      $("#datasetInstructions").css("display", "block")
      $("#datasetsManifestTable").css("display", "none")
      hub.disableButton(useThisDatasetButton);
      }
    else{
      $("#datasetInstructions").css("display", "none")
      $("#datasetsManifestTable").css("display", "block")      
      requestDataSetSummary(selectedDataSet);
    }

} // selectManifest
//----------------------------------------------------------------------------------------------------
function populateDataSetMenu()
{
   console.log("Module.datasets, entering populateDataSetMenu");

   //$(datasetMenu).ready(function() {
      console.log("=== datasetMenu ready, now issuing populateDataSetMenu request to server");
      var msg = {cmd: "getDataSetNames",  callback: "handleDataSetNames", status: "request", 
                 payload: ""};
      hub.send(JSON.stringify(msg));
   //   });

} // populateDataSetMenu
//----------------------------------------------------------------------------------------------------
function handleDataSetNames(msg)
{
   console.log("=== handleDataSetNames");
   
   var dataSetNames = msg.payload.datasets;
   console.log("dataSetNames length: " + dataSetNames.length);
   console.log("dataSetNames: " + JSON.stringify(dataSetNames));

   var passwordProtected = msg.payload.passwordProtected;

   if(!Array.isArray(dataSetNames))
      dataSetNames = [dataSetNames];

   for(var i=0; i < dataSetNames.length; i++){
      var s = dataSetNames[i];
      datasetMenu.append("<option value='" + s + "'>" + s + "</option>");
      }

  //if(passwordProtected)
  //   hub.disableButton($("#datasetMenu"));


} // handleDataSetNames
//----------------------------------------------------------------------------------------------------
function requestDataSetSummary(dataSetName)
{
   console.log("=== requestDataSetSummary");

   var msg = {cmd: "getDataManifest",  callback: "displayDataManifest", status: "request", 
              payload: dataSetName};

   hub.send(JSON.stringify(msg));

} // requestDataSetSummary
//----------------------------------------------------------------------------------------------------
function displayDataManifest(msg)
{
   var payload = msg.payload;
   var tblColumnNames = payload.colnames;

   var columnTitles = [];
     // convert simple strings to array of objects, each an sTitle
   for(var i=0; i < tblColumnNames.length; i++){
      columnTitles.push({sTitle: tblColumnNames[i]});
      }
     
   if(typeof(tableRef) != "undefined"){
      tableRef.destroy();
      tableElement.empty();
      }


   $(tableElement).ready(function() {
      tableRef = tableElement.DataTable({
        //sDom: 't',
        aoColumns: columnTitles,
        //scrollX: true,
        bPaginate: false,
        bFilter: false, 
        bAutoWidth: true,
        bSort: false,
        bInfo: false
        }); // dataTable

     tableRef = $("#datasetsManifestTable").DataTable();

     tableRef.rows.add(payload.mtx).draw();
     // tableRef.fnAddData(payload.mtx);

     $('#datasetsManifestTable tbody').on( 'click', 'tr', function (){ 
         console.log("=== click");
         var category = $('td', this).eq(0).text();
         var subcategory = $('td', this).eq(1).text();
         if($(this).hasClass("selected")){
            $(this).removeClass('selected');
            hub.disableButton(sendSelectionsMenu);
            }
         else{
            tableRef.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            hub.enableButton(sendSelectionsMenu);
            console.log("selected " + category + ", " + subcategory);
            }
         });

     handleWindowResize();
     hub.enableButton(useThisDatasetButton);
     postStatus("manifest table displayed");
     }); // tableElement.ready

} // displayDataManifest
//----------------------------------------------------------------------------------------------------
function specifyCurrentDataset()
{
   console.log("Module.datasets 'Use Dataset' button clicked, specifyCurrentDataset: " + selectedDataSet);

   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: selectedDataSet};

   hub.send(JSON.stringify(msg));

} // specifyCurrentDataset
//----------------------------------------------------------------------------------------------------
function datasetSpecified(msg)
{
   console.log("--- Module.datasets:  datasetSpecified");

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function test(dataSetName)
{
   console.log("Module.datasets test, on datasetName: '" + dataSetName + "'");

   QUnit.test("choose dataset '" + dataSetName + "'", function(assert) {
      hub.raiseTab("datasetsDiv");
      var desiredDataset = dataSetName;
      var dzNames = $("#datasetMenu option").map(function(opt){return this.value})

      if($.inArray(desiredDataset, dzNames) < 0){
         alert("cannot run tests:  " + desiredDataset + " dataset not loaded");
         return;
         }

      $("#datasetMenu").val(desiredDataset)
      $("#datasetMenu").trigger("change");

      var done1 = assert.async();
      var done2 = assert.async();
      var done3 = assert.async();
      assert.expect(3);

      setTimeout(function(){
         assert.equal($("#datasetMenu").val(), desiredDataset);  done1();
         assert.ok($("#datasetsManifestTable tr").length >= 10); done2();
         assert.equal($("#datasetsManifestTable tbody tr").eq(0).find("td").eq(0).text(), 
                      "mRNA expression"); done3();
         //testLoadPatientHistoryTable();
         }, 5000);
      });


} // test
//----------------------------------------------------------------------------------------------------
function moduleInit()
{
  hub.addOnDocumentReadyFunction(initializeUI);
  //hub.addSocketConnectedFunction(populateDataSetMenu);
  hub.addMessageHandler("handleDataSetNames", handleDataSetNames);
  hub.addMessageHandler("displayDataManifest", displayDataManifest);
  hub.addMessageHandler("datasetSpecified", datasetSpecified);

} // moduleInit
//----------------------------------------------------------------------------------------------------
return{
   init: moduleInit,
   test: test
   }; // DataSummaryModule return value

//----------------------------------------------------------------------------------------------------
}); // DataSummaryModule

var dataSummaryModule = DataSummaryModule();
dataSummaryModule.init();
hub.registerModule("Datasets", dataSummaryModule);

//----------------------------------------------------------------------------------------------------
var patientHistoryTableRef;

var ageAtDxMinReadout;
var ageAtDxMaxReadout;
var survivalMinReadout, survivalMaxReadout;

var ageAtDxMin, ageAtDxMax;
var ageAtDxSlider, survivalSlider;
var survivalMin, survivalMax;


var PatientHistoryModule = (function () {

  var statusDiv;
  var patientHistoryDiv;
  var controlsDiv;
  var tableDiv;
  var tableElement;
  var sendSelectionsMenu;

  var thisModulesName = "patientHistory";
  var thisModulesOutermostDiv = "patientHistoryDiv";
  var selectionDestinations = [thisModulesName];

  var sendSelectionsMenuTitle = "Send selection...";
  var showAllRowsButton;
  
//--------------------------------------------------------------------------------------------
function initializeUI()
{
  console.log("=== Module.patientHistory, initializeUID");

  $(window).resize(handleWindowResize);

  statusDiv = $("#patientHistoryStatusDiv");

  patientHistoryDiv = $("#patientHistoryDiv");
  controlsDiv = $("#patientHistoryControlsDiv");
  tableDiv = $("#patientHistoryTableDiv");
  tableElement = $("#patientHistoryTable");

  showAllRowsButton = $("#patientHistoryShowAllRowsButton");
  showAllRowsButton.click(showAllRows);

  sendSelectionsMenu = hub.configureSendSelectionMenu("#patientHistorySendSelectionsMenu", 
                                                      selectionDestinations, sendSelections,
                                                      sendSelectionsMenuTitle);

  handleWindowResize();

} // initializeUI
//----------------------------------------------------------------------------------------------------
function createDataTable(colnames, data)
{
      // DataTable likes some structure for column titles

   var columnTitles = [];
   for(var i=0; i < colnames.length; i++){
     columnTitles.push({sTitle: colnames[i]});
     }

   if(typeof(patientHistoryTableRef) != "undefined"){
      patientHistoryTableRef.destroy();
      tableElement.empty();
      }

   patientHistoryTableRef = tableElement.DataTable({
                             data: data,
                             columns: columnTitles,
                             //dom: "C<fi<t>>",
                             dom: 'C<"clear">lfrtip',
                             paging: false,
                             jQueryUI: false
                             });

   if(colnames.indexOf("AgeDx") >= 0){
      var minMax = learnSliderMinAndMax(data, colnames.indexOf("AgeDx"));
      console.log("minMax for AgeDx: ");
      console.log(minMax);
      ageAtDxMin = minMax[0];
      ageAtDxMax = minMax[1];
         // slider, title & readouts for specifying age range for table display
      createAgeAtDiagnosisWidget(ageAtDxMin, ageAtDxMax);  
      } // ageAtDx slider

   if(colnames.indexOf("Survival") >= 0){
      minMax = learnSliderMinAndMax(data, colnames.indexOf("Survival"));
      console.log("minMax for Survival: ");
      console.log(minMax);
      survivalMin = minMax[0];
      survivalMax = minMax[1];
         // slider, title & readouts for specifying age range for table display
      createSurvivalWidget(survivalMin, survivalMax);  
      } // survival slider

   showAllRows();
   setupSliderDrivenFilterBehavior(colnames);
 

} // createDataTable
//----------------------------------------------------------------------------------------------------
function setupSliderDrivenFilterBehavior(colnames)
{
  var ageDxColumn = colnames.indexOf("AgeDx");
  var survivalColumn = colnames.indexOf("Survival");

  if(ageDxColumn >= 0) {
    jQuery.fn.dataTable.ext.search.push(
       function(settings, data, dataIndex) {
         var ageAtDxMin      = parseFloat(ageAtDxMinReadout.val());
         var ageAtDxMax      = parseFloat(ageAtDxMaxReadout.val());

         var patientAgeAtDx  = parseFloat(data[ageDxColumn]) || 0;
 
         var ageAtDxInRange  = (patientAgeAtDx >= ageAtDxMin) && (patientAgeAtDx <= ageAtDxMax);
         if(ageAtDxInRange)
            return true;
         return false;
        }); // anonymous function
      } // push

  if(survivalColumn >= 0) {
    jQuery.fn.dataTable.ext.search.push(
       function(settings, data, dataIndex) {
         var survivalMin      = parseFloat(survivalMinReadout.val());
         var survivalMax      = parseFloat(survivalMaxReadout.val());

         var patientSurvival  = parseFloat(data[survivalColumn]) || 0;
         var survivalInRange  = (patientSurvival >= survivalMin) && (patientSurvival <= survivalMax);
         if(survivalInRange)
            return true;
         return false;
        }); // anonymous function
      } // push


} // setupSliderDrivenFilterBehavior
//----------------------------------------------------------------------------------------------------
function createAgeAtDiagnosisWidget(minValue, maxValue)
{
  ageAtDxSlider = $("#ageAtDxSlider");
  ageAtDxMinReadout = $("#ageAtDxMinSliderReadout");
  ageAtDxMaxReadout = $("#ageAtDxMaxSliderReadout");

  ageAtDxSlider.slider({
     range: true,
     slide: function(event, ui) {
        //console.log("AgeDx: " + ui.values[0] + ", " + ui.values[1]);
        if(ui.values[0] > ui.values[1]){
           return false;
           }          
       ageAtDxMinReadout.text (ui.values[0]);
       ageAtDxMaxReadout.text (ui.values[1]);
       patientHistoryTableRef.draw();
       handleWindowResize();
       //updateRowCountReadout();
       },
    min: minValue,
    max: maxValue,
    values: [minValue, maxValue]
    });

  ageAtDxMinReadout.text(minValue);
  ageAtDxMaxReadout.text(maxValue);

} // createAgeAtDiagnosisWidget
//----------------------------------------------------------------------------------------------------
function createSurvivalWidget(minValue, maxValue)
{
  survivalSlider = $("#survivalSlider");
  survivalMinReadout = $("#survivalMinSliderReadout");
  survivalMaxReadout = $("#survivalMaxSliderReadout");
  console.log("createSurvivalWidget");

  survivalSlider.slider({
     range: true,
     slide: function(event, ui) {
        //console.log("survival: " + ui.values[0] + ", " + ui.values[1]);
        if(ui.values[0] > ui.values[1]){
           return false;
           }          
       survivalMinReadout.text (ui.values[0]);
       survivalMaxReadout.text (ui.values[1]);
       patientHistoryTableRef.draw();
       handleWindowResize();
       },
    min: minValue,
    max: maxValue,
    values: [minValue, maxValue]
    });

  survivalMinReadout.text(minValue);
  survivalMaxReadout.text(maxValue);

} // createSurvivalWidget
//----------------------------------------------------------------------------------------------------
// when the patient history table arrives, the filtering sliders can be setup, using the 
// min and max values of selected columns.  our sliders are currently ageAtDx and survival.
// the column numbers for these are specified by the caller.  missing values are not
// troublesome to Javascript's min and max functions.  note the use of floor and ceil,
// to nudge min and max values out a bit.
function learnSliderMinAndMax(tbl, columnNumber)
{
  var rowCount = tbl.length;
  var min = Number.MAX_VALUE;
  var max = -Number.MAX_VALUE;

  for(var r=0; r < rowCount; r++){
    var value = Number.parseFloat(tbl[r][columnNumber]);
    //console.log(value)
    if(value < min)
      min = value;
    if(value > max)
      max = value;
    } // for r

  return[Math.floor(min), Math.ceil(max)];

} // learnSliderMinAndMax
//----------------------------------------------------------------------------------------------------
function showAllRows()
{
   if(typeof(ageAtDxMin)  != "undefined" &&
      typeof(ageAtDxMax)  != "undefined" &&
      typeof(survivalMin) != "undefined" &&
      typeof(survivalMax) != "undefined") {

        ageAtDxSlider.slider("values", [ageAtDxMin, ageAtDxMax]);
        survivalSlider.slider("values", [survivalMin, survivalMax]);
        ageAtDxMinReadout.text(ageAtDxMin);
        ageAtDxMaxReadout.text(ageAtDxMax);
        survivalMinReadout.text(survivalMin);
        survivalMaxReadout.text(survivalMax);
        } // all 4 min/max slider values defined

    // chained calls: clear the DataTable search box, then iterate through the columns, then render

   if(typeof(patientHistoryTableRef) != "undefined")
       patientHistoryTableRef.search('').columns().search('').draw();

   handleWindowResize();

} // showAllRows
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{

  patientHistoryDiv.width($(window).width() * 0.95);
  patientHistoryDiv.height($(window).height() * 0.90);  // leave room for tabs above

  //controlsDiv.width($(window).width() * 0.90);
  controlsDiv.width(patientHistoryDiv.width()); //  * 0.95);
  controlsDiv.height("100px");

  tableDiv.width(patientHistoryDiv.width()); //  * 0.95);
  tableDiv.height(patientHistoryDiv.height() - 130);

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();

   var visibleRows = patientHistoryTableRef.rows({'filter': 'applied'})[0];
   if(visibleRows.length === 0)
      return;

   var selectedIDs = [];

   var data = patientHistoryTableRef.data();

   for(var i=0; i < visibleRows.length; i++){
      var id = data[visibleRows[i]][0];
      selectedIDs.push(id);
      } // for i

   var cmd = "sendSelectionTo_" + destination;

   payload = {value: selectedIDs, count: selectedIDs.length, source: "patient history module"};
   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function handleSelections(msg)
{
   showAllRows();
   var ids = msg.payload.value;
   if(typeof(ids) == "string")
      ids = [ids];

      // incoming ids may have trailing version number, e.g., "TCGA.02.0114.01"
      // strip all such 2-digit suffixes:

   ids = ids.map(function(id) {return(id.replace(/\.0[0-9]$/, ""))})
   filterByString(ids);
   hub.raiseTab(thisModulesOutermostDiv);

} // handleSelections
//----------------------------------------------------------------------------------------------------
filterByString = function(strings)
{
   var filterString = strings[0];
   for(var i=1; i < strings.length; i++){
     filterString += "|" + strings[i];
     }

   showAllRows();
   console.log(filterString);

   if(typeof(patientHistoryTableRef) != "undefined")
      patientHistoryTableRef.search(filterString, true, false).draw();   // string, regex, smart

}; // filterByString
//----------------------------------------------------------------------------------------------------
function displayPatientHistoryTable(msg)
{
   var payload = msg.payload;
   var colnames = payload.colnames;
   var data = payload.tbl; // an array of arrays

   console.log("incoming table, rows: " + data.length);
   console.log("incoming table, cols: " + data[0].length);
   createDataTable(colnames, data);
   postStatus("patientHistory data table loaded");
   // hub.raiseTab(thisModulesOutermostDiv);

}  // displayPatientHistoryTable
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the patient history table from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

     // request patient data table
   var payload = {datasetName: datasetName, durationFormat: "byYear"};
   var newMsg = {cmd: "getPatientHistoryTable",  callback: "displayPatientHistoryTable", 
                 status: "request", payload: payload};

   hub.send(JSON.stringify(newMsg));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
// for standalone exploration, development, and testing.   assumes a hub has been
// created and initialized.  set the dataset, and in the callback load the table
// thus 
//   specifyCurrentDataSet -> getPatientHistoryTable -> displayPatientHistoryTable
//
function testLoad()
{
   var msg = {cmd: "specifyCurrentDataset",  callback: "datasetSpecified", 
              status: "request", payload: "TCGAgbm"};

   hub.send(JSON.stringify(msg));

} // test
//----------------------------------------------------------------------------------------------------
function testSelect()
{
   var msg={cmd: "sendSelectionTo_patientHistory", status: "request", callback: "", 
            payload:["TCGA.02.0011", "TCGA.06.0238"]};

   hub.send(JSON.stringify(msg));

} // testSelect
//----------------------------------------------------------------------------------------------------
return{
   init: function(){
      hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
      hub.addOnDocumentReadyFunction(initializeUI);
      hub.addMessageHandler("sendSelectionTo_patientHistory", handleSelections);
      hub.addMessageHandler("datasetSpecified", datasetSpecified);
      hub.addMessageHandler("displayPatientHistoryTable", displayPatientHistoryTable);
      //hub.addSocketConnectedFunction(testLoad);
      //hub.setTitle("patientHistory");
      },
   testSelect: testSelect,
   testLoad:   testLoad
   }; // PatientHistoryModule return value

//----------------------------------------------------------------------------------------------------
}); // PatientHistoryModule
pts = PatientHistoryModule();
pts.init();


//----------------------------------------------------------------------------------------------------
// move these all back inside module scope when debugging is done
var cwMarkers;
var XXX;
var nodeRestriction = [];
//----------------------------------------------------------------------------------------------------
var markersAndTissuesModule = (function () {

  var statusDiv; 
  var cyDiv;
  var searchBox;
  var hideEdgesButton, showEdgesButton, showAllEdgesButton, clearSelectionButton, sfnButton;
  var helpButton;
  var infoMenu;
  var edgeTypeSelector;
  var mouseOverReadout;
  var graphOperationsMenu;
  var tumorCategorizationsMenu;
  var tumorCategorizationsMenuTitle = "Tumor Groups...";
  var sendSelectionsMenu;
  var layoutMenu;
  var thisModulesName = "MarkersAndPatients";
  var thisModulesOutermostDiv = "markersAndPatientsDiv";

      // sometimes a module offers multiple selection destinations.
      // usually there is just one:

  var selectionDestinations = [thisModulesName];


  var sendSelectionsMenuTitle = "Send selection...";

     // the user may specify that only certain tumors, and/or certain genes
     // are to be used in any subsequent network operations -- especially
     // "show edges from selected nodes"
     // to experiment with this capability, there are two new net ops menu
     // options, which assign zero or more selected nodes to these variables,
     // which are then used (if defined) to limit the subsequent network
     // operation


//--------------------------------------------------------------------------------------------
function initializeUI ()
{

  cyDiv = $("#cyMarkersDiv");
  statusDiv = $("#markersAndPatientsStatusDiv");

  sendSelectionsMenu = hub.configureSendSelectionMenu("#cyMarkersSendSelectionsMenu", 
                                                      [thisModulesName], sendSelections,
                                                      sendSelectionsMenuTitle);

  tumorCategorizationsMenu = $("#cyMarkersTumorCategorizationsMenu");
  tumorCategorizationsMenu.empty()
  tumorCategorizationsMenu.append("<option>" + tumorCategorizationsMenuTitle + "</otpion>");
  tumorCategorizationsMenu.change(requestTumorCategorization);

  graphOperationsMenu = $("#cyMarkersOperationsMenu");
  graphOperationsMenu.change(doGraphOperation);
  graphOperationsMenu.empty();
  graphOperationsMenu.append("<option>Network Operations...</option>");

  var operations = ["Show All Edges",
                    "Show Edges from Selected Nodes",
                    "Hide All Edges",
                    //"Connect to First Neighbors",
                    "Invert Node Selection",
                    "Clear Selections",
                    "Select All Connected Nodes",
                    "Select All Nodes with Selected Edges",
                    "Hide Unselected Nodes",
                    "Show All Nodes",
                    "Restrict Next Ops to Selected Nodes"];

  for(var i=0;i< operations.length; i++){
     var optionMarkup = "<option>" + operations[i] + "</option>";
     graphOperationsMenu.append(optionMarkup);
     } // for 


   layoutMenu = $("#markerLayouts");
   layoutMenu.change(performLayout);

   showEdgesButton = $("#cyMarkersShowEdgesButton");
   showEdgesButton.click(showEdges);
   
   showAllEdgesButton = $("#cyMarkersShowAllEdgesButton");
   showAllEdgesButton.click(showAllEdges);

   sfnButton = $("#cyMarkersSFNButton");
   sfnButton.click(selectFirstNeighbors);
   clearSelectionButton = $("#cyMarkersClearSelectionButton");
   clearSelectionButton.click(clearSelection);

   hideEdgesButton = $("#cyMarkersHideEdgesButton");
   hideEdgesButton.click(hideAllEdges)


   searchBox = $("#markersAndTissuesSearchBox");

   edgeTypeSelector = $("#markersEdgeTypeSelector");
   mouseOverReadout = $("#markersAndTissuesMouseOverReadout");
   configureCytoscape();
   $(".chosen-select").chosen();
   $(window).resize(handleWindowResize);

   setInterval(function(){
      var count = cwMarkers.nodes("node:selected").length;
      var disable = (count == 0);
      sendSelectionsMenu.attr("disabled", disable);
      }, 500);
 

} // initializeUI
//----------------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();
   console.log("CyMarkers send selections to " + destination);
   sendSelectionsMenu.val(sendSelectionsMenuTitle);
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length == 0){
      console.log("no nodes selected!")
      return;
      }

  var cmd = "sendSelectionTo_" + destination;
  payload = {value: nodeNames, count: nodeNames.length, source: "markers and patients module"};
  var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

  sendSelectionsMenu.val(sendSelectionsMenuTitle);

  hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function configureLayoutsMenu(layoutMenu){

   console.log("--- configureLayoutsMenu");
   layoutMenu.append("<option>Layouts...</option>");
   layoutMenu.append("<option> Save Current</option>");

   var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
            return{id:n.id(), position:n.position()}}));

   localStorage.markersDefault = defaultLayout;

   var existingLayouts = Object.keys(localStorage);
   for(var i=0; i < existingLayouts.length; i++){
      if(existingLayouts[i].match("markers") != null){
        layoutMenu.append("<option>" + existingLayouts[i] + "</option>");
        }
      } // for i

} // configureLayoutsMenu
//----------------------------------------------------------------------------------------------------
function performLayout(event){

  var chosenLayoutName = layoutMenu.val();

  if(chosenLayoutName == "Save Current"){
     var uniqueNumber = Math.floor(new Date().getTime()/1000);   // number of seconds since 1970
     newName = "markers." + (uniqueNumber - 1420414900);    // since today, very roughly
     currentLayout = JSON.stringify(cwMarkers.nodes().map(function(n){return{id:n.id(), position:n.position()}}));
     localStorage[newName] = currentLayout;
     layoutMenu.append("<option>" + newName + "</option>");
     layoutMenu.val(newName);
     return;
     }

  if(Object.keys(localStorage).indexOf(chosenLayoutName) >= 0){
     var newLayout;
     newLayout = JSON.parse(localStorage[chosenLayoutName]);
     cwMarkers.nodes().positions(function(i, node){
        return{x: newLayout[i].position.x, y:newLayout[i].position.y};
         });
     } // if requested layout name is recognized
  
  layoutMenu.val("Layouts...");   // restore the title

} // performLayout
//--------------------------------------------------------------------------------------------
function sendSelection()
{
   destinationModule = sendSelectionsMenu.val();
   var nodeNames = selectedNodeNames(cwMarkers);
   if(nodeNames.length == 0){
      console.log("no nodes selected!")
      return;
      }
   metadata = {};
   sendSelectionToModule(destinationModule, nodeNames, metadata);
   sendSelectionsMenu.val("Send Selection...");

}; // sendSelectionsMenuChanged
//--------------------------------------------------------------------------------------------
function configureCytoscape ()
{
  cwMarkers = $("#cyMarkersDiv");
  cwMarkers.cytoscape({
     boxSelectionEnabled: true,
     showOverlay: false,
     minZoom: 0.01,
     maxZoom: 8.0,
     layout: {
       name: "preset",
       fit: true
       },
   ready: function() {
      console.log("cwMarkers ready");
      cwMarkers = this;
      cwMarkers.on('mouseover', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val(node.id());
         })
      cwMarkers.on('mouseout', 'node', function(evt){
         var node = evt.cyTarget;
         mouseOverReadout.val("");
         })
      cwMarkers.on('mouseover', 'edge', function(evt){
         var edge = evt.cyTarget;
         var d = edge.data();
         var msg = d.edgeType + ": " + d.source + " - " + d.target;
         var mutation = d.mutation
         if(typeof(mutation) == "string")
            msg = mutation + " " + msg;
         mouseOverReadout.val(msg);
         })

      //cwMarkers.on('select', 'node', function(evt){
      //   console.log("cwMarkers.on('select', 'node')");
      //   var disable = selectedNodeIDs(cwMarkers).length == 0;
      //   sendSelectionsMenu.attr("disabled", disable);
      //   })
      //cwMarkers.on('unselect', 'node', function(evt){
      //   var disable = selectedNodeIDs(cwMarkers).length == 0;
      //   sendSelectionsMenu.attr("disabled", disable);
      //   })

      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      searchBox.keydown(doSearch);

      console.log("cwMarkers.reset");
      cwMarkers.reset();
      handleWindowResize();
      cwMarkers.edges().selectify(); // this seems to hold through session, visibility notwithstanding
      //hideAllEdges();
      configureLayoutsMenu(layoutMenu);
      }, // cy.ready
     }) // .cytoscape
    .cytoscapePanzoom({ });   // need to learn about options

} // configureCytoscape
//----------------------------------------------------------------------------------------------------
function handleWindowResize ()
{
   cyDiv.width(0.95 * $(window).width());
   cyDiv.height(0.8 * $(window).height());
   cwMarkers.resize();
   cwMarkers.fit(50);

} // handleWindowResize
//----------------------------------------------------------------------------------------------------
function requestTumorCategorization()
{
  var categorizationName = tumorCategorizationsMenu.val();
  console.log("apply " + categorizationName);

  var msg = {cmd: "getSampleCategorization", callback: "markersApplyTumorCategorization",
             status: "request", payload: categorizationName};

  hub.send(JSON.stringify(msg));

  tumorCategorizationsMenu.val(tumorCategorizationsMenuTitle);

} // requestTumorCategorization
//----------------------------------------------------------------------------------------------------
function applyTumorCategorization(msg)
{
   console.log("=== applyTumorCategorization");
   var tumorsInGraph = cwMarkers.nodes("[nodeType='patient']")
   var tumorsInTable = msg.payload.rownames
   var tbl = msg.payload.tbl

   tumorsInGraph.forEach(function(node, index){
      var nodeID = node.id();  // our convention is that this is the tumor name, eg, "TCGA.02.0014"
      var indexInTable = tumorsInTable.indexOf(nodeID);
      if(indexInTable >= 0){
         var cluster = tbl[indexInTable][0];
         node.data({subType: cluster});
         }
      else{
         node.data({subType: "unassigned"});
         }
       }); // forEach

  cwMarkers.style().update();

} // applyTumorCategorization
//----------------------------------------------------------------------------------------------------
function doGraphOperation()
{
   var operation = graphOperationsMenu.val();

   switch(operation){
      case "Show All Edges":
         showAllEdges();
         break;
      case "Show Edges from Selected Nodes":
         //showEdgesFromSelectedNodes();
         showEdgesFromSelectedNodes();
         break;
      case "Hide All Edges":
         hideAllEdges();
         break;
      case "Invert Node Selection":
         invertSelection();
         break;
      case "Clear Selections":
         cwMarkers.filter('node:selected').unselect();
         break;
      case "Select All Connected Nodes":
         selectAllConnectedNodes();
         break;
      case "Select All Nodes with Selected Edges":
        selectAllNodesConnectedBySelectedEdges();
        break;
      case "Hide Unselected Nodes":
         cwMarkers.filter("node:unselected").hide();
         break;
      case "Show All Nodes":
         cwMarkers.filter('node:hidden').show();
         break;
      case "Restrict Next Ops to Selected Nodes":
         restrictNextOpsToSelectedNodes();
         break;
      default:
         console.log("unrecoginized graph operation requested from menu: " + operation);
      } // switch

      // restore menu to initial condition, with only title showing
   graphOperationsMenu.val("Network Operations...");

} // doGraphOperation
//----------------------------------------------------------------------------------------------------
function clearSelection ()
{
   cwMarkers.elements().unselect();
}
//----------------------------------------------------------------------------------------------------
function selectFirstNeighbors ()
{
  selectedNodes = cwMarkers.filter('node:selected');
  showEdgesForNodes(cwMarkers, selectedNodes);

}
//----------------------------------------------------------------------------------------------------
function invertSelection ()
{
   selected = cwMarkers.filter("node:selected");
   unselected = cwMarkers.filter("node:unselected");
   selected.unselect();
   unselected.select();
}
//----------------------------------------------------------------------------------------------------
function hideAllEdges ()
{
   cwMarkers.filter('edge').hide();
}
//----------------------------------------------------------------------------------------------------
function showAllEdges ()
{
   var edgeTypesToDisplay = edgeTypeSelector.val();

   console.log("edgeTypeToDisplay: " + edgeTypesToDisplay);

   if(edgeTypesToDisplay == null){
      return;
      }

   for(var e=0; e < edgeTypesToDisplay.length; e++){
      var type =  edgeTypesToDisplay[e];
      selectionString = '[edgeType="' + type + '"]';
      //console.log(" showAllEdges selection string: " + selectionString);
      cwMarkers.edges(selectionString).show()
      } // for e

} // showAllEdges
//----------------------------------------------------------------------------------------------------
function zoomSelected()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 100)
}
//----------------------------------------------------------------------------------------------------
function handleIncomingIdentifiers(msg)
{
   console.log("Module.markers, handleIncomingIdentifiers");
      // expect 3 payload fields: value, count, source
   var ids = msg.payload.value; 
   if(typeof(ids) == "string")
      ids = [ids];
   //intersectingIDs = hub.intersectionOfArrays(ids, nodeNames())
   intersectingIDs = hub.intersectionOfArrays(ids, nodeIDs())
   console.log("found ids: " + intersectingIDs.length);

   if(intersectingIDs.length > 0)
      selectNodesByID(intersectingIDs);
   else{
      errorMessage = "No overlap with genes or tissue sample IDs:  <br><br>" +
                      ids.join(", ");
      title = ids.length + " unrecognized identifiers";
      $('<div />').html(errorMessage).dialog({title: title, width:600, height:300});
      }

   hub.raiseTab(thisModulesOutermostDiv);

} // handleIncomingIdentifiers
//----------------------------------------------------------------------------------------------------
  // run all that should happen when this module receives an incoming selection of patientIDs
demoMarkersIncomingSelectionOfIDs = function()
{

   names = ["TCGA.06.0210", "TCGA.02.0106", "TCGA.02.0111",
            "TCGA.06.0194", "TCGA.06.0164", "TCGA.06.0409", "TCGA.02.0004",
            "TCGA.02.0051", "TCGA.08.0390", "TCGA.02.0025", "TCGA.08.0392",
            "TCGA.02.0079", "TCGA.12.0620", "TCGA.08.0373", "TCGA.06.0645",
            "TCGA.06.0192", "TCGA.12.0776", "TCGA.12.0778", "TCGA.06.0750",
            "TCGA.06.0878", "TCGA.14.0789", "TCGA.06.0881", "BCL11A",
            "BRCA1", "MDM2", "PIK3R1", "ABCA1", "CDK6", "CNTRL", "FH",
            "IFNA1", "LMO2", "PRKCA", "RELA", "STK11", "ZEB1", "CCNB1IP1",
            "CREB3L1", "GDF2", "OR4K2", "PRKCH", "WAS"];

   subset = []
   for(var i=0; i < 10; i++)
     subset.push(names[getRandomInt(0, names.length -1)]);

   selectNodes(subset);

} // demoIncomingSelectionOfPatientIDs
//----------------------------------------------------------------------------------------------------
function allNodeIDs()
{
   ids = [];
   allNodes = cwMarkers.nodes();

   for(i=0; i < allNodes.length; i++)
       ids.push(allNodes[i].data("id"))

   return(ids);

} // allNodeIDs
//----------------------------------------------------------------------------------------------------
function showEdges()
{
   hideAllEdges();   // is this wise?

   var edgeTypesToDisplay = edgeTypeSelector.val();
   if(edgeTypesToDisplay == null){
      hideAllEdges();
      return;
      }

   var selectedNodes = selectedNodeIDs(cwMarkers);

   //console.log(" newEdgeTypeSelection (" + edgeTypesToDisplay.length + 
   //            "), selectedNodes: " + selectedNodes.length);

   if(selectedNodes.length > 0) { // show edges to and from all selected nodes
     showEdgesForNodes(cwMarkers, selectedNodes);
     }

} // showEdges
//----------------------------------------------------------------------------------------------------
// function showEdgesFromSelectedNodes()
// {
//    var selectedNodes = cwMarkers.filter('node:selected');
// 
//       // break out the selected nodes into the two groups we care about: 
//       //    genes & tumors (aka, patients)
// 
//    var tumorNodes = selectedNodes.filter("[nodeType='patient']");
//    var geneNodes  = selectedNodes.filter("[nodeType='gene']");
// 
//       // if any tumor node restriction is in force, only 
//       // the intersecton of that with our current selection is kept
// 
//    if(tumorNodeRestriction.length > 0){
//       var correctedTumorNodes = [];
//       tumorNodes.forEach(function(node){
//         if(tumorNodeRestriction.indexOf(node.id()) >= 0){
//            console.log("match!");
//            correctedTumorNodes.push(node);
//           } // if matched
//         }); // forEach
//      console.log("some tumor nodes restricted, some selected");
//      tumorNodes = correctedTumorNodes;   // 0 or more
//      } // some tumor nodes restricted
// 
//    if(geneNodeRestriction.length > 0){
//       var correctedGeneNodes = [];
//       geneNodes.forEach(function(node){
//        if(geneNodeRestriction.indexOf(node.id()) >= 0){
//          console.log("match!");
//          correctedTumorNodes.push(node);
//           } // if matched
//        }); // forEach
//     console.log("some gene nodes restricted, some selected");
//     geneNodes = correctedGeneNodes;   // 0 or more
//     } // some gene node restriction
//        
//    selectedNodes = tumorNodes;
//    geneNodes.forEach(function(node){selectedNodes.push(node)});
// 
//    if(selectedNodes.length == 0) {
//       return;
//       }
// 
//       // "closed" means that we have tumors and genes specified, and
//       // only want to find connections among them
// 
//    //var closedCandidates = FALSE;
// 
//    //if(tumorNodes.length > 0 & geneNodes.length > 0)
//    //   closedCandidates = TRUE;
// 
//    debugger;
//    showEdgesForNodes(cwMarkers, selectedNodes);
// 
// } // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function zoomSelection()
{
   cwMarkers.fit(cwMarkers.$(':selected'), 50)

}
//----------------------------------------------------------------------------------------------------
function selectedNodeIDs(cw)
{
   ids = [];
   noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     ids.push(noi[n].data()['id']);
     }
  return(ids);

} // selectedNodeIDs
//----------------------------------------------------------------------------------------------------
function selectedNodeNames(cw)
{
   var names = [];
   var noi = cw.filter('node:selected');
   for(var n=0; n < noi.length; n++){
     names.push(noi[n].data('name'));
     }
  return(names);

} // selectedNodeNames
//----------------------------------------------------------------------------------------------------
showEdgesFromSelectedNodes = function()
{
   var targets = nodeRestriction;
   var selectedNodes = cwMarkers.nodes("node:selected");
   var neighbors = selectedNodes.neighborhood();
   var candidateEdges = neighbors.filterFn(function(e) {if(e.isEdge()) return e})
   candidateEdges = candidateEdges.fnFilter(function(edge){
      return(edgeTypeSelector.val().indexOf(edge.data("edgeType")) >= 0)
      });

   if(targets.length == 0){
      candidateEdges.show();
      return;
      }

   function intersects(array1, array2){
      var size = array1.filter(function(n) {return array2.indexOf(n) != -1}).length;
      return(size > 0);
      }

   candidateEdges.filterFn(function(edge){
      var actual=edge.connectedNodes().map(function(node){return node.id()});
      return(intersects(actual, targets));
       }).show()

} // showEdgesFromSelectedNodes
//----------------------------------------------------------------------------------------------------
function selectSourceAndTargetNodesOfEdges(cw, edges)
{

  var edgesVisible = cwMarkers.filter('edge:visible').length

  var filterStrings = [];

  for(var i=0; i < edges.length; i++){
     edge = edges[i];
     targetID = edge.target().data("id")
     sourceID = edge.source().data("id")
     var sourceFilterString = '[id="' + sourceID + '"]';
     var targetFilterString = '[id="' + targetID + '"]';
     filterStrings.push(sourceFilterString);
     filterStrings.push(targetFilterString);
     } // for i

   var nodesToSelect = cw.nodes(filterStrings.join());
   nodesToSelect.select()

} // selecteSourceAndTargetNodesOfEdge
//----------------------------------------------------------------------------------------------------
  // todo: massive inefficiencies here
function showEdgesForNodes(cw, nodes)
{

  var edgeTypes = edgeTypeSelector.val();
  console.log("=== showEdgesForNodes, edgeType count: " + edgeTypes.length);
  console.log(edgeTypes);

  if(edgeTypes.length == 0)
      return;

  var filterStrings = [];

  $("body").toggleClass("wait");

  setTimeout(function(){
     for(var e=0; e < edgeTypes.length; e++){
        var edgeType = edgeTypes[e];
        for(var n=0; n < nodes.length; n++){
          var nodeID = nodes[n].data("id");
          var sourceFilterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
          var targetFilterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
          filterStrings.push(sourceFilterString)
          filterStrings.push(targetFilterString)
          } // for n
        } // for e

      console.log("filterString count: " + filterStrings.length);
      filter = filterStrings.join();
      console.log("filter created, about to apply...");
      var existingEdges = cw.edges(filter);
      console.log("filtering complete");
      if(existingEdges.length > 0) {
         console.log("about to show edges");
         existingEdges.show()
         console.log("edges shown...");
         }
     }, 1000); // setTimeout

  $("body").toggleClass("wait");

} // showEdgesForNodes
//----------------------------------------------------------------------------------------------------
function selectAllConnectedNodes()
{
    var selectedEdges = cwMarkers.filter("edge:visible");
    selectSourceAndTargetNodesOfEdges(cwMarkers, selectedEdges);

} // selectAllConnectedNodes
//----------------------------------------------------------------------------------------------------
function selectAllNodesConnectedBySelectedEdges()
{
    edges = cwMarkers.filter("edge:selected")
    console.log(" selected edge count: " + edges.length);
    if(edges.length == 0)
      return;
    for(var e=0; e < edges.length; e++){
       selectNodes(edges[e].target().data("name"))
       selectNodes(edges[e].source().data("name"))
       } // for e

} //selectAllNodesConnectedBySelectedEdges
//----------------------------------------------------------------------------------------------------
function showEdgesForSelectedNodes(cw, edgeTypes)
{
   var nodeIDs = selectedNodeIDs(cw);
   for(var n=0; n < nodeIDs.length; n++){
      nodeID = nodeIDs[n];
      for(var e=0; e < edgeTypes.length; e++){
         edgeType = edgeTypes[e];
         filterString = '[edgeType="' + edgeType + '"][source="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         filterString = '[edgeType="' + edgeType + '"][target="' + nodeID + '"]';
         //console.log("filter string: " + filterString);
         cw.edges(filterString).show();
         } // for e
      } // for n

} // showEdgesForSelectedNodes
//----------------------------------------------------------------------------------------------------
function restrictNextOpsToSelectedNodes()
{
  var nodes = cwMarkers.nodes("node:selected"); // .filter("[nodeType='gene']");
  if(nodes.length == 0){
     nodeRestriction = [];
     }
  else{
     nodeRestriction = nodes.map(function(node){return node.id()})
     }

  debugger;

} // restrictNextOpsToSelectedNodes
//----------------------------------------------------------------------------------------------------
function nodeNames()
{
  var nodes = cwMarkers.filter("node:visible");
  var result = [];
  for(var i=0; i < nodes.length; i++){
    result.push(nodes[i].data().label)
    } // for i
  return(result)

} // nodeNames
//----------------------------------------------------------------------------------------------------
function nodeIDs()
{
   return(cwMarkers.nodes().map(function(node){return node.id()}));
}
//----------------------------------------------------------------------------------------------------
function upperCaseNodeIDs()
{
   return(nodeIDs().map(function(node){return(node.toUpperCase())}));
}
//----------------------------------------------------------------------------------------------------
// todo: build up the filter string first, then send it all at once
function selectNodes(nodeNames)
{
  console.log("Module.markers::selectNodes");
  console.log(nodeNames);

  if(typeof(nodeNames) == "string")   // trap scalar, but expect and support arrays
     nodeNames = [nodeNames];

  var allNodes = cwMarkers.nodes().map(function(n){return n.id()});
  var allNodesUpperCase = allNodes.map(function(name){return name.toUpperCase()});

  for(var i=0; i < nodeNames.length; i++){
    var nodeName = nodeNames[i].toUpperCase();  // depends upon this conv
    var index = allNodesUpperCase.indexOf(nodeName);
    if(index >= 0){
      var actualNodeID = allNodes[index];
      var s = "cwMarkers.filter('node[id=\"" + actualNodeID + "\"]').select()";
       //console.log("markers selectNodes: " + s);
       eval (s);
       } // if found, index >= 0
    } // for i

} // selectNodes
//----------------------------------------------------------------------------------------------------
   // todo: build up the filter string first, then send it all at once
function selectNodesByID(nodeIDs) {

  if(typeof(nodeIDs) == "string")   // trap scalar, but expect and support arrays
     nodeIDs = [nodeIDs];

  console.log("about to select nodes by id: " + nodeIDs.length);
  console.log(nodeIDs);

  for(var i=0; i < nodeIDs.length; i++){
    s = "cwMarkers.filter('node[id=\"" + nodeIDs[i] + "\"]').select()";
    console.log(s)
    eval (s);
    } // for i

} // selectNodesByID
//----------------------------------------------------------------------------------------------------
function doSearch(e)
{
   var keyCode = e.keyCode || e.which;

   if (keyCode == 13) {
      var searchString = searchBox.val().toUpperCase();
      console.log("searchString: " + searchString);
      var idsActual = nodeIDs();
      var idsUpper = upperCaseNodeIDs();
      var hits = idsUpper.filter(function(id) {return(id.startsWith(searchString))});
      var hitIndices = hits.map(function(hit) {return idsUpper.indexOf(hit)});
      var hitsActual = hitIndices.map(function(hit) {return idsActual[hit]})
      selectNodes(hitsActual);
      } // if 13 (return key)

} // doSearch
//----------------------------------------------------------------------------------------------------
function displayMarkersNetwork(msg)
{
   console.log("--- Module.markers: displayMarkersNetwork");
   //console.log(msg)
   if(msg.status == "success"){
      console.log("nchar(network): " + msg.payload.length);
      s = msg.payload;
      XXX = msg.payload;
      console.log("      1:40: " + s.substring(1, 40));
      var json = JSON.parse(msg.payload);
      cwMarkers.remove(cwMarkers.edges());
      cwMarkers.remove(cwMarkers.nodes());
      console.log(" after JSON.parse, json.length: " + json.length);
      console.log("  about to add json.elements");
      cwMarkers.add(json.elements);
      console.log("  about to add  json.style");
      cwMarkers.style(json.style);
      console.log("   hiding edges");
      cwMarkers.edges().hide()
      cwMarkers.filter("edge[edgeType='chromosome']").style({"curve-style": "bezier"});
      cwMarkers.filter("edge[edgeType='chromosome']").show();
      cwMarkers.nodes().unselect();
        // map current node degree into a node attribute of that name
      cwMarkers.nodes().map(function(node){node.data({degree: node.degree()})});

      var edgeTypes = hub.uniqueElementsOfArray(cwMarkers.edges().map(function(edge){
                               return(edge.data("edgeType"))}
                               ));
      updateEdgeSelectionWidget(edgeTypes);  // preserve only known edgeTypes
      cwMarkers.fit(20);
      var defaultLayout = JSON.stringify(cwMarkers.nodes().map(function(n){
                                         return{id:n.id(), position:n.position()}}));
      localStorage["markersDefault"] = defaultLayout;
      postStatus("markers network displayed");
      }
   else{
     console.log("displayMarkersNetwork error: " + msg.payload);
     }

} // displayMarkersNetwork
//----------------------------------------------------------------------------------------------------
function postStatus(msg)
{
  statusDiv.text(msg);

} // postStatus
//----------------------------------------------------------------------------------------------------
// ensure that only edgeTypes in current network are offered in the selection widget
function updateEdgeSelectionWidget(edgeTypes)
{
     // loop over currently offered edge types
   var options = $("#markersEdgeTypeSelector").children();
   for(var i=0; i < options.length; i++){
      var optionElement = options[i];
      var optionValue = optionElement.value;
      var found = jQuery.inArray(optionValue, edgeTypes) >= 0
      console.log("checking option '" + optionValue + "':  " + found);
      if(!found){
         console.log("  deleting selector option " + optionValue);
         $("#markersEdgeTypeSelector option[value='" + optionValue + "']").remove();
         } // unrecognized edge type
      }
   $("#markersEdgeTypeSelector").trigger("chosen:updated");

} // updateEdgeSelectionWidget
//----------------------------------------------------------------------------------------------------
// called when the a dataset has been specified, typically via the Datasets tab, which presents
// the user with a list of the datasets they are able to use, from which they choose one at a time
// as their current working dataset.
// this module uses the dataset name to request the g.markers.json network from the server
function datasetSpecified (msg)
{
   var datasetName = msg.payload;

     // request patient data table
   var newMsg = {cmd: "getMarkersNetwork",  callback: "displayMarkersNetwork", 
                status: "request", payload: datasetName};

   hub.send(JSON.stringify(newMsg));

   var msg2 = {cmd: "getSampleCategorizationNames", callback: "configureSampleCategorizationMenu",
               status: "request", payload: ""};

   hub.send(JSON.stringify(msg2));

} // datasetSpecified
//----------------------------------------------------------------------------------------------------
function configureSampleCategorizationMenu(msg)
{
   console.log("=== configureSampleCategorizationMenu")
   console.log(msg.payload)
   tumorCategorizationsMenu.empty()
   var categorizations = msg.payload;

   var titleOption = "Tumor Groups...";

   tumorCategorizationsMenu.append("<option>" + titleOption + "</option>");

   for(var i=0; i < categorizations.length; i++){
     tumorCategorizationsMenu.append("<option>" + categorizations[i] + "</option>");
     } // for i

   tumorCategorizationsMenu.val(titleOption);

} // configureSampleCategorizationMenu
//----------------------------------------------------------------------------------------------------
// this module supports (or soon will support) markers & patients (or markers & samples) networks
// for a variety of diseases and patient sets.  we will develop tests which know nothing beforehand
// about the data, but our first priority now (28 apr 2015) is for the lgg/gbm combined tcga 
// dataset
function standAloneTest()
{
   $("#qunit").css({display: "block"})

   gbmLggDzSpecificTests();

} // standAloneTest
//----------------------------------------------------------------------------------------------------
function gbmLggDzSpecificTests()
{
   QUnit.test("markersAndSamples: basic network test", function(assert){
      console.log("============= starting basic network test");
      assert.expect(2);
      console.log("about to check node count");
      assert.ok(cwMarkers.nodes().length > 1500);
      console.log("about to check edge count");
      assert.ok(cwMarkers.edges().length > 13000)
      console.log("end of test");
      });

  QUnit.test("markersAndSamples: select EGFR", function(assert){
     cwMarkers.nodes().unselect();
     assert.ok(cwMarkers.filter("node:selected").length == 0);
     cwMarkers.$("#EGFR").select();
     assert.ok(cwMarkers.filter("node:selected").length == 1);
     });


  QUnit.test("markersAndSamples: choose edge types", function(assert){
     edgeTypes = $("#markersEdgeTypeSelector option").map(function(opt){return this.value})
     var desiredEdgeType = "chromosome";

     if($.inArray(desiredEdgeType, edgeTypes) < 0){
        alert("cannot run tests:  " + desiredEdgeType + " edgeType not available");
        return;
        }

     $("#markersEdgeTypeSelector").val(desiredEdgeType)
     $("#markersEdgeTypeSelector").trigger("change")
     console.log("=== edge type selected: " + $("#markersEdgeTypeSelector").val());
     assert.equal($("#markersEdgeTypeSelector").val(), desiredEdgeType);
     assert.equal(cwMarkers.filter("node:selected").length, 1);
       // now restore the original settings. 
     $("#markersEdgeTypeSelector").val(["chromosome", "mutation", "cnGain.2", "cnLoss.2", "cnGain.1", "cnLoss.1"])
     $("#markersEdgeTypeSelector").trigger("change");
     });

  QUnit.test("markersAndSamples: select chrom edges from EGFR", function(assert){
      var desiredAction = "Show Edges from Selected Nodes";
      var actions = $("#cyMarkersOperationsMenu option").map(function(x) {return this.value});

      if($.inArray(desiredAction, actions) < 0){
         alert("cannot run tests:  " + desiredAction + " not available");
         return;
         }

     cwMarkers.edges().hide()
     assert.equal(cwMarkers.filter("edge:visible").length, 0);
     $("#cyMarkersOperationsMenu").val(desiredAction);
     $("#cyMarkersOperationsMenu").trigger("change");
     assert.expect(1); // specify number of assertions which should run
     setTimeout(function() {  // takes a little while for the edge to be rendered
        assert.equal(cwMarkers.filter("edge:visible").length, 1);
        }, 2000);
     });


  QUnit.test("markersAndSamples: search and select EGFR", function(assert){
     cwMarkers.nodes().unselect();
     assert.equal(cwMarkers.filter("node:selected").length, 0);
     var targetNode = "EGFR";
     $("#markersAndTissuesSearchBox").val(targetNode);
     var e = jQuery.Event("keydown");
     e.which = 13;  
     $("#markersAndTissuesSearchBox").trigger(e);
     var selectedNode = cwMarkers.filter("node:selected")
     assert.equal(selectedNode.length, 1);
     assert.equal(selectedNode.data().id, targetNode);
     });


} // gbmLggDzSpecificTests
//----------------------------------------------------------------------------------------------------
// query the oncoscape server for user id.  the callback then makes a local (that is,
// Module-specific) decision to run this module's automated tests based upon that id
function runAutomatedTestsIfAppropriate()
{
   console.log("Module.markers, runAutomatedTestsIfAppropriate");

   var msg = {cmd: "getUserId",  callback: "markersAssessUserIdForTesting",
              status: "request", payload: ""};

   hub.send(JSON.stringify(msg));

} // runAutomatedTestsIfAppropriate
//----------------------------------------------------------------------------------------------------
function assessUserIdForTesting(msg)
{
   var userID = msg.payload;
   userId = userID.toLowerCase();

   console.log("markersAndSamples/Module.js assesUserIdForTesting: " + userID)
   
   if(userID.indexOf("autotest") === 0){
      console.log("markersAndSamples/Module.js running tests for user " + userID)
      debugger;
      mast = MarkersAndSamplesTestModule();
      mast.show()
      mast.run();
      }

} // assessUserIdForTesting
//----------------------------------------------------------------------------------------------------
 return{
     init: function(){
        hub.addMessageHandler("sendSelectionTo_MarkersAndPatients", handleIncomingIdentifiers);
        hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
        hub.addMessageHandler("datasetSpecified", datasetSpecified);
        hub.addMessageHandler("displayMarkersNetwork", displayMarkersNetwork);
        hub.addMessageHandler("configureSampleCategorizationMenu", configureSampleCategorizationMenu);
        hub.addMessageHandler("markersApplyTumorCategorization", applyTumorCategorization);
        hub.addMessageHandler("markersAssessUserIdForTesting", assessUserIdForTesting);
        hub.addSocketConnectedFunction(runAutomatedTestsIfAppropriate);
        hub.addOnDocumentReadyFunction(initializeUI);
       },
     sat: standAloneTest
     };

   }); // markersAndTissuesModule
//----------------------------------------------------------------------------------------------------
markersModule = markersAndTissuesModule()
markersModule.init();


//----------------------------------------------------------------------------------------------------
var OncoprintModule = (function () {

  var sendSelectionsMenu;

  var thisModulesName = "Oncoprint";
  var thisModulesOutermostDiv = "oncoprintDiv";

  var sendSelectionsMenuTitle = "Send selection...";

      // sometimes a module offers multiple selection destinations
      // but usually just the one entry point
  var selectionDestinations = [thisModulesName];
      // make sure to register, eg,
      // hub.addMessageHandler("sendSelectionTo_blankTab", handleSelections);
  var onc;
  var cell_padding = 3;
  var cell_width = 4;
  var whitespace_on = true;
  var tracks_to_load = 1;
  var gene = "EGFR";
  var cnv_track_id = [];
//--------------------------------------------------------------------------------------------
function initializeUI()
{
  $(window).resize(handleWindowResize);

  OncoprintDiv = $("#oncoprintDiv");
  sendSelectionsMenu = hub.configureSendSelectionMenu("#oncoprintSendSelectionsMenu", 
                                                      selectionDestinations, 
                                                      sendSelections,
                                                      sendSelectionsMenuTitle);
  

  $('#shuffle_btn').click(function() {
	onc.sort(gender_track_id, function(d1, d2) {
		var map = {'MALE':0, 'FEMALE':1};
		return map[d1.attr_val] - map[d2.attr_val];
	});
});

  $('#toggle_whitespace').click(function() {
	onc.toggleCellPadding();
});
  var z = 1;
  $('#reduce_cell_width').click(function() {
	z *= 0.5;
	onc.setZoom(z);
});
  $('#change_color_scheme').click(function() {
	onc.setRuleSet(gender_track_id, Oncoprint.CATEGORICAL_COLOR, {
		color: {MALE: '#CBCBCB', FEMALE: 'green'},
		getCategory: function(d) {
			return d.attr_val;
		},
		legend_label: 'Gender (modified color)'
	});
});                                                 
 
  
	
  
  handleWindowResize();

} // initializeUI
//----------------------------------------------------------------------------------------------------
function handleWindowResize()
{
  OncoprintDiv.width($(window).width() * 0.95);
  OncoprintDiv.height($(window).height() * 0.90);  // leave room for tabs above

  //$("#onc").width(OncoprintTabDiv.width()); //  * 0.95);
  //$("#onc").height("100px");

} // handleWindowResize
//--------------------------------------------------------------------------------------------
function sendSelections(event)
{
   var destination = sendSelectionsMenu.val();

   var cmd = "sendSelectionTo_" + destination;
   var dummySelections = ["dummy selection 1", "dummy selection 2"];

   payload = {value: dummySelections, count: dummySelections.length, 
             source: thisModulesName};

   var newMsg = {cmd: cmd,  callback: "", status: "request", payload: payload};

      // restore default (informational) title of the menu
   sendSelectionsMenu.val(sendSelectionsMenuTitle);

   hub.send(JSON.stringify(newMsg));

} // sendSelections
//--------------------------------------------------------------------------------------------
function handleSelections(msg)
{
   hub.raiseTab(thisModulesOutermostDiv);
   //var msgAsString = JSON.stringify(msg.payload);
   
   var ids = msg.payload.value;
   
   if(typeof(ids) == "string")
      ids = [ids];

   console.log("Oncoprint module, " + msg.cmd + " patients and markers: " + ids);
   $("#onc").empty();
   
   analyzeSelectedTissues(ids);


} // handleSelections
//----------------------------------------------------------------------------------------------------
function analyzeSelectedTissues(IDs)
{
   $("#onc").append("Computing...");
   console.log("Oncoprint module, hub.send 'cnv_data_selection' for %d IDs",
               IDs.length);
   if(IDs.length > 108){
   		alert("Please choose less than 108 Nodes");
   }else{
	   var payload = {sampleIDs: IDs};
	   var msg = {cmd:"cnv_data_selection", callback: "displayOncoprint", status: "request", 
				  payload: payload};
	   console.log("msg cmd, call back, status, payload: %s,%s,%s,%s", msg.cmd, msg.callback, msg.status, msg.payload.sampleIDs );
	   hub.send(JSON.stringify(msg));
	}

} // analyzeSelectedTissues
//----------------------------------------------------------------------------------------------------
function displayOncoprint(msg)
{
   //console.log("about to add survival curve image to survivalCurve div");
   $("#onc").empty();
   console.log("entering displayOncoprint");
   console.log("displayOncoprint print recieved msg.payload: %s", msg.payload);
   xx = JSON.parse(msg.payload);
   if(xx.length != 2) alert(msg.payload);
   else{
	   var cnv_data_promise = JSON.parse(xx[0]);
	   console.log("displayOncoprint print recieved genes: %s",xx[1]);
	   genes = xx[1];
   
	   onc = Oncoprint.create('#onc', {cell_padding: cell_padding, cell_width: cell_width});
	   var cnv_data;
	  
	   onc.suppressRendering();
  
   
	   tracks_to_load = genes.length;
	   console.log(tracks_to_load);
	   function map_data(data){
				cnv_data = _.map(data, function(x) { 
							if(x.value > 2) x.mrna='UPREGULATED';
							if(x.value < -2) x.mrna='DOWNREGULATED';
							if(x.value == 2) x.cna='AMPLIFIED';
							if(x.value == 1) x.cna='GAINED';
							if(x.value == -1) x.cna='HEMIZYGOUSLYDELETED'; 
							if(x.value == -2) x.cna='HOMODELETED';  
							x.patient = x.sample; return x; })
	   }
	   map_data(cnv_data_promise,gene);
   
	   for(i = 0; i < genes.length; i++){
			gene = genes[i];
			
			var cnv_data_gene = cnv_data.filter(function(obj){return obj.gene === gene});     
			$.when(cnv_data_promise).then(function() {
				cnv_track_id[i] = onc.addTrack({label: gene}, 0);
				tracks_to_load -= 1;
				if(i == 0){
					onc.setRuleSet(cnv_track_id[i], Oncoprint.GENETIC_ALTERATION);
				}else{
					onc.useSameRuleSet(cnv_track_id[i], cnv_track_id[0]);
				}
				onc.setTrackData(cnv_track_id[i], cnv_data_gene, true);
				if (tracks_to_load === 0) {
					onc.releaseRendering();
				};
			})
	   }	
   } 
} // displaySurvivalCurves
//----------------------------------------------------------------------------------------------------
function initializeModule()
{
   hub.registerSelectionDestination(selectionDestinations, thisModulesOutermostDiv);
   hub.addOnDocumentReadyFunction(initializeUI);
   hub.addMessageHandler("sendSelectionTo_Oncoprint", handleSelections);
   hub.addMessageHandler("displayOncoprint", displayOncoprint);

} // initializeModule
//----------------------------------------------------------------------------------------------------
function demoPatientSet()
{
   var longSurvivors = ["TCGA.06.6693", "TCGA.12.1088", "TCGA.02.0113", "TCGA.02.0114", "TCGA.08.0344"];

   var firstFortyGbmPatients = ["TCGA.02.0001", "TCGA.02.0003", "TCGA.02.0006", "TCGA.02.0007",
                                "TCGA.02.0009", "TCGA.02.0010", "TCGA.02.0011", "TCGA.02.0014",
                                "TCGA.02.0021", "TCGA.02.0024", "TCGA.02.0027", "TCGA.02.0028",
                                "TCGA.02.0033", "TCGA.02.0034", "TCGA.02.0037", "TCGA.02.0038",
                                "TCGA.02.0043", "TCGA.02.0046", "TCGA.02.0047", "TCGA.02.0052",
                                "TCGA.02.0054", "TCGA.02.0055", "TCGA.02.0057", "TCGA.02.0058",
                                "TCGA.02.0060", "TCGA.06.0875", "TCGA.06.0876", "TCGA.06.0877",
                                "TCGA.06.0878", "TCGA.06.0879", "TCGA.06.0881", "TCGA.06.0882",
                                "TCGA.12.0670", "TCGA.12.0818", "TCGA.12.0819", "TCGA.12.0820",
                                "TCGA.12.0821", "TCGA.12.0822", "TCGA.12.0826", "TCGA.12.0827"];

   firstFortyGbmPatients.push(longSurvivors);
   return (firstFortyGbmPatients);

} // demoPatientSet
//----------------------------------------------------------------------------------------------------
function sat(maxReps)
{

} // sat
//----------------------------------------------------------------------------------------------------
return{
   init: initializeModule,
   sat: sat
   }; // OncoprintTabModule return value

//----------------------------------------------------------------------------------------------------
}); // OncoprintTabModule

OncoprintM = OncoprintModule();
OncoprintM.init();



</script>

<body>

<div id="oncoscapeTabs">
   <ul>
     <li><a href="#datasetsDiv">Datasets</a></li>
     <li><a href="#patientHistoryDiv">Patient History</a></li>
     <li><a href="#markersAndPatientsDiv">Markers &amp; Patients</a></li>
     <li><a href="#oncoprintDiv">Oncoprint</a></li>
   </ul>

<style>
#oncoprintDiv{
   width: 1000px;
   height: 400px;
   background-color: #f0f0f0;
   margin: auto;
   padding: 5px;
   }
</style>
<div id = 'oncoprintDiv'>
<div id="oncoprintControlsDiv">  
	<select type="button" id="oncoprintSendSelectionsMenu" style="float:right; margin:15px"></select>
</div>
<div id='onc'></div>
    <button id='toggle_whitespace' >Toggle Whitespace</button>
    <button id='reduce_cell_width'>Reduce Cell Width</button>
</div>
<style>


#patientHistoryDiv{
   width: 600px;
   height: 400px;
   background-color: #ffffff;
   margin: auto;
   padding: 5px;
   }


#patientHistoryControlsDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  border-radius: 5px;
  margin-right: auto;
  margin-left: auto;
  margin-top: 10px;
  margin-bottom: 5px;
  padding: 0px;
  }

#patientHistoryTableDiv {
  background-color: #FFFFFF;
  position: relative;
  height: 400px;
  width: 600px;
  overflow-x:auto;
  margin-right: auto;
  margin-left: auto;
  margin-top: 5px;
  margin-bottom: 5px;
  padding: 0px;
  }

.patientDataFilterSliderReadout {
  font-family:"Courier";
  color: #0000FF;
  background-color: #FFF;
  font-size: 12px;
  border: 2px solid #DDD;
  width: 50px;
  height: 25px;
  resize: none;
  margin-top: 5px;
  margin-left: 1px;
  }

.patientDataFilterSliderTitleDiv {
  font-family:"Arial";
  color: #000000;
  font-size: 12px;
  padding-top: 0px;
  padding-right:0px;
  }


</style>


<div id="patientHistoryDiv">
  <div id="patientHistoryStatusDiv" style="display:none"></div>
  <div id="patientHistoryControlsDiv">  


        <div id="ageSliderDiv" class="nav navbar-nav navbar-form navbar-left"  style="display: inline-block">
           <div id="ageAtDxSliderTitleDiv" class="patientDataFilterSliderTitleDiv" style="text-align: center; width=100%">Age at Dx</div>
           <div style="width: 280px; overflow: hidden;">
               <div id="ageAtDxMsgBox1" style="float: left; margin-left: 5px; margin-right: 15<px; width: 40px" >
  
                  <textarea id="ageAtDxMinSliderReadout" style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
               <div style="width: 120px; height: 6px; float: left; margin-top: 10px; 
                           margin-left: 30px; margin-right: 15px;" 
                   id="ageAtDxSlider" class="slider patientDataFilterSlider">
                   </div>
               <div id="ageAtDxMsgBox2" style="float: left">  
                  <textarea id="ageAtDxMaxSliderReadout" style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
              </div>
           </div>


        <div id="survivalSliderDiv" class="nav navbar-nav navbar-form navbar-left" style="display: inline-block">
           <div id="survivalSliderTitleDiv" class="patientDataFilterSliderTitleDiv" style="text-align: center; width=100%">Survival</div>
           <div style="width: 280px; overflow: hidden;">
               <div id="survivalMsgBox1" style="float: left" >  
                  <textarea id="survivalMinSliderReadout" style="font-size: 12px; height:16px"
                             readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
               <div style="width: 120px; height: 6px; float: left; margin-top: 10px; margin-left: 15px;
                            margin-right: 15px;" 
                   id="survivalSlider" class="slider patientDataFilterSlider">
                   </div>
               <div id="survivalMsgBox2" style="float: left">  
                  <textarea id="survivalMaxSliderReadout"  style="font-size: 12px; height:16px"
                            readonly class="patientDataFilterSliderReadout"></textarea> 
                  </div>
              </div>
           </div>

     <button id="patientHistoryShowAllRowsButton" type="button">Reset</button>
     <select type="button" id="patientHistorySendSelectionsMenu" style="float:right; margin:15px"></select>


  </div>

  <div id="patientHistoryTableDiv">  
    <table id="patientHistoryTable" cellpadding="0" cellspacing="0" border="0" class="display">
    </table>
 </div>

</div>

<style>
 
</style>

<div id="datasetsDiv">
  <div id="datasetsStatusDiv" style="display:none"></div>
  <div id="dataSummaryControlsDiv">
     <span id="selectDataSetMenuLabel" style="margin-left: 20px;">Available Datasets</span>
     <select type="button" id="datasetMenu" style="margin: 5px;"><option> </option></select>
     <button id="selectDatasetButton">Use Dataset</button>
     <select type="button" id="datasetsSendSelectionsMenu" style="float:right; margin:15px; display: none"></select>
  </div>

   <div id="dataSetNamesOutputDiv" style="margin: 20px;"></div>

   <div id="dataSummaryOutputDiv" style="margin: 20px;overflow-x:auto">
      <div id="datasetInstructions">Please select a dataset from the above menu.</div>
      <table id="datasetsManifestTable" class="display" cellpadding="0" cellspacing="0" border="1" style="margin:0px; width:auto; display:none"></table>
   </div>
</div>

<style>

div {
   display: block;
   }

body.wait, body.wait *{
   cursor: wait !important;   
}

#markersAndPatientssDiv{
  }

button {font-size:10pt !important;}

#cyMarkersDiv {
  background-color: #FAFAFA;  // light gray
  height: 400px;
  width: 600px;
  border: 1px solid #aaa;
  margin-top: 2px;
  margin-left: 0px;
  padding: 0px;
  }

#markersAndTissuesSearchBox{
  border: 1px solid #aaa;
  width: 80px;
  height: 20px;
  }

markersAndTissuesMouseOverReadout{
  border: 1px solid #aaa;
  width: 400px !important;
  height: 24px;
  font-size: 12pt !important;
  font-weight: bold;
  }


#cyMarkersClearSelectionButton #cyMarkersHideEdgesButton #cyMarkersShowEdgesButton #cyMarkersShowAllEdgesButton {
   font-size:8pt  !important;
   }

#markersAndTissuesbuttonDiv{
  margin-top: 1px;
  margin-bottom: 1px;
  }

#hiddenmarkersEdgeTypeSelector {
  width: 100% !important;
  }

.chosen-container, .chosen-drop, .chosen-drop .chosen-search, .chosen-drop .chosen-search input {
  width: 100% !important;
  -webkit-box-sizing: border-box;
     -moz-box-sizing: border-box;
          box-sizing: border-box;
}

.chosen-container { width:350px !important; 
                    height:25px;
                    font-size:8pt;}
iframe {
display: initial !important;
}


#MTNavForm{
  padding:4px !important;
  margin-top:4px !important;
  margin-bottom:0px !important;
  margin-left:0px !important;
}
#bottomMargin{
  height:18px;
}
</style>


<div id="markersAndPatientsDiv" class="container-fluid">
  <div id="markersAndPatientsStatusDiv" style="display:none"></div>
   <div id="markersAndTissuesButtonDiv" style="margin-bottom: 0px; margin-top: 8px;">
      <input type="text" id="markersAndTissuesMouseOverReadout" disabled value="(names displayed here)"></input>

     <select id="cyMarkersOperationsMenu" class="navbar-form selectpicker" style="font-size:8pt"></select>
     <select id="cyMarkersTumorCategorizationsMenu" style="font-size:8pt"></select>
      
     <select class="chosen-select form-control dropdown navbar-form selectpicker" 
                    style="width:280px;font-size:12pt"
                    data-placeholder="Select edge types to display" 
                    multiple id="markersEdgeTypeSelector">
           <option value="mutation" class="btn-info" selected>Mut</option>
           <option value="cnGain.2" class="btn-info" selected>Copy+2</option>
           <option value="cnLoss.2" class="btn-info" selected>Copy-2</option>
           <option value="cnGain.1" class="btn-info" selected>C+1</option>
           <option value="cnLoss.1" class="btn-info" selected>C-1</option>
           <option value="chromosome" class="btn-info" selected>Chrom</option>
       </select>
     
 
   <input  type="text" id="markersAndTissuesSearchBox" placeholder="search" style="width:100px;font-size:8pt"></input>
   <select type="button" id="cyMarkersSendSelectionsMenu" style="float:right; margin-right:15px"></select>
 
   <select class="btn btn-primary selectpicker" type="button" id="markerLayouts"
            name="markerLayoutMenu"></select>
 
   </div>
   
   
 <div id="cyMarkersDiv" data-toggle="tooltip" class="content" style="margin:0 auto" ></div>
 <div id="bottomMargin" style="width:100%;height:30px margin:0 auto"></div>

</div>





</div>

<script>
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.oncoprint_events = {
	ADD_TRACK: 'add_track.oncoprint',
	REMOVE_TRACK: 'remove_track.oncoprint',
	MOVE_TRACK: 'move_track.oncoprint',
	SORT: 'sort.oncoprint',
	SET_CELL_PADDING: 'set_cell_padding.oncoprint',
	SET_CELL_WIDTH: 'set_cell_width.oncoprint',
	SET_TRACK_DATA: 'set_track_data.oncoprint',
	SET_ID_ORDER: 'set_id_order.oncoprint',
	CELL_CLICK: 'cell_click.oncoprint',
	CELL_MOUSEENTER: 'cell_mouseenter.oncoprint',
	CELL_MOUSELEAVE: 'cell_mouseleave.oncoprint',
	ONCOPRINT_MOUSEENTER: 'oncoprint_mouseenter.oncoprint',
	ONCOPRINT_MOUSELEAVE: 'oncoprint_mouseleave.oncoprint',
	SET_PRE_TRACK_PADDING: 'set_pre_track_padding.oncoprint',
	TRACK_INIT: 'init.track.oncoprint',
	UPDATE_RENDER_RULES: 'update_render_rules.cell_renderer.oncoprint',
	FINISHED_RENDERING: 'finished_rendering.oncoprint',
	FINISHED_POSITIONING: 'finished_positioning.renderer.oncoprint',
	SET_ZOOM: 'set_zoom.oncoprint',
	SET_SORT_DIRECTION: 'set_sort_direction.oncoprint',
	SET_VISIBLE_ID_ORDER: 'set_visible_ids.oncoprint'
};
;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.oncoprint_utils = (function() {
	var exports = {};

	exports.sign = function(number) {
		return number?((number<0)?-1:1):0
	};

	exports.invert_array = function invert_array(arr) {
		return arr.reduce(function(curr, next, index) {
			curr[next] = index;
			return curr;
		}, {});
	};

	exports.cssClassToSelector = function(classes) {
		return "."+classes.split(" ").join(".");
	};
	exports.mouseY = function(evt) {
		return exports.ifndef(evt.offsetY, evt.originalEvent && evt.originalEvent.layerY);
	};
	exports.mouseX = function(evt) {
		return exports.ifndef(evt.offsetX, evt.originalEvent && evt.originalEvent.layerX);
	};
	exports.ifndef = function(val, replacement) {
		return (typeof val === 'undefined') ? replacement : val;
	};
	exports.extends = function(child_class, parent_class) {
		child_class.prototype = Object.create(parent_class.prototype);
		child_class.prototype.constructor = child_class;
	};

	exports.makeIdCounter = function() {
		var counter = 0;
		return function() {
			counter += 1;
			return counter;
		};
	};

	exports.clamp = function(t, a, b) {
		return Math.max(Math.min(b,t), a);
	};

	exports.makeD3SVGElement = function(tag) {
		return d3.select(document.createElementNS('http://www.w3.org/2000/svg', tag));
	};

	exports.appendD3SVGElement = function(elt, target, svg) {
		return target.select(function() {
			return this.appendChild(elt.node().cloneNode(true));
		});
	};

	exports.spaceSVGElementsHorizontally = function(group, padding) {
		var x = 0;
		var elts = exports.d3SelectChildren(group, '*').each(function() {
			if (this.tagName === 'defs') {
				// don't adjust spacing for a defs element
				return;
			}
			var transform = d3.select(this).attr('transform');
			var y = transform && transform.indexOf("translate") > -1 && parseFloat(transform.split(",")[1], 10);
			y = y || 0;
			d3.select(this).attr('transform', exports.translate(x, y));
			x += this.getBBox().width;
			x += padding;
		});
		return group;
	};

	exports.textWidth = function(string, font) {
		var obj = $('<div>'+string+'</div>')
				.css({position: 'absolute', float: 'left',
					'white-space':'nowrap', visibility: 'hidden',
					font: font})
				.appendTo($('body'));
		var width = obj.width();
		obj.remove();
		return width;
	};

	exports.d3SelectChildren = function(parent, selector) {
		return parent.selectAll(selector).filter(function() {
			return this.parentNode === parent.node();
		});
	};

	exports.warn = function(str, context) {
		console.log("Oncoprint error in "+context+": "+str);
	};

	exports.stableSort = function(arr, cmp) {
		// cmp returns something in [-1,0,1]

		var zipped = [];
		_.each(arr, function(val, ind) {
			zipped.push([val, ind]);
		});
		var stable_cmp = function(a,b) {
			var res = cmp(a[0], b[0]);
			if (res === 0) {
				if (a[1] < b[1]) {
					res = -1;
				} else if (a[1] > b[1]) {
					res = 1;
				}
			}
			return res;
		};
		zipped.sort(stable_cmp);
		return _.map(zipped, function(x) { return x[0];});
	};

	exports.lin_interp = function(t, a, b) {
		if (a[0] === '#') {
			var r = [parseInt(a.substring(1,3), 16), parseInt(b.substring(1,3), 16)];
			var g = [parseInt(a.substring(3,5), 16), parseInt(b.substring(3,5), 16)];
			var b = [parseInt(a.substring(5,7), 16), parseInt(b.substring(5,7), 16)];
			var R = Math.round(r[0]*(1-t) + r[1]*t).toString(16);
			var G = Math.round(g[0]*(1-t) + g[1]*t).toString(16);
			var B = Math.round(b[0]*(1-t) + b[1]*t).toString(16);

			R = R.length < 2 ? '0'+R : R;
			G = G.length < 2 ? '0'+G : G;
			B = B.length < 2 ? '0'+B : B;

			return '#' + R + G + B;
		} else if (isNaN(a) && a.indexOf('%') > -1) {
			var A = parseFloat(a, 10);
			var B = parseFloat(b, 10);
			return (A*(1-t) + B*t)+'%';
		} else {
			return a*(1-t) + b*t;
		}
	};

	exports.translate = function(x,y) {
		return "translate(" + x + "," + y + ")";
	};

	exports.assert = function(bool, msg) {
		if (!bool) {
			throw msg;
		}
	}
	return exports;
})();
;
window.oncoprint_defaults = (function() {
	var utils = window.oncoprint_utils;
	var makeGeneticAlterationComparator = function(distinguish_mutations) {
		var cna_key = 'cna';
		var cna_order = utils.invert_array(['AMPLIFIED', 'HOMODELETED', 'GAINED', 'HEMIZYGOUSLYDELETED', 'DIPLOID', undefined]);
		var mut_type_key = 'mut_type';
		var mut_order = (function() {
			if (!distinguish_mutations) {
				return function(m) {
					return +(typeof m === 'undefined');
				}
			} else {
				var _order = utils.invert_array(['TRUNC', 'INFRAME', 'MISSENSE', undefined]); 
				return function(m) {
					return _order[m];
				}
			}
		})();
		var mrna_key = 'mrna';
		var rppa_key = 'rppa';
		var regulation_order = utils.invert_array(['UPREGULATED', 'DOWNREGULATED', undefined]);

		return function(d1, d2) {
			var cna_diff = utils.sign(cna_order[d1[cna_key]] - cna_order[d2[cna_key]]);
			if (cna_diff !== 0) {
				return cna_diff;
			}

			var mut_type_diff = utils.sign(mut_order(d1[mut_type_key]) - mut_order(d2[mut_type_key]));
			if (mut_type_diff !== 0) {
				return mut_type_diff;
			}

			var mrna_diff = utils.sign(regulation_order[d1[mrna_key]] - regulation_order[d2[mrna_key]]);
			if (mrna_diff !== 0) {
				return mrna_diff;
			}

			var rppa_diff = utils.sign(regulation_order[d1[rppa_key]] - regulation_order[d2[rppa_key]]);
			if (rppa_diff !== 0) {
				return rppa_diff;
			}

			return 0;
		};
	};

	var genetic_alteration_config_base = {
		default: [{shape: 'full-rect', color: '#D3D3D3', z_index: -1}],
		altered: {
			'cna': {
				'AMPLIFIED': {
					shape: 'full-rect',
					color: 'red',
					legend_label: 'Amplification'
				},
				'GAINED': {
					shape: 'full-rect',
					color: '#FFB6C1',
					legend_label: 'Gain'
				},
				'HOMODELETED':{
					shape: 'full-rect',
					color: '#0000FF',
					legend_label: 'Deep Deletion'
				},
				'HEMIZYGOUSLYDELETED': {
					shape: 'full-rect',
					color: '#8FD8D8',
					legend_label: 'Shallow Deletion'
				}
			},
			'mrna': {
				'UPREGULATED': {
					shape: 'outline',
					color: '#FF9999',
					legend_label: 'mRNA Upregulation'
				},
				'DOWNREGULATED': {
					shape: 'outline',
					color: '#6699CC',
					legend_label: 'mRNA Downregulation'
				}
			},
			'rppa': {
				'UPREGULATED': {
					shape: 'small-up-arrow',
					color: 'black',
					legend_label: 'Protein Upregulation'
				},
				'DOWNREGULATED': {
					shape: 'small-down-arrow',
					color: 'black',
					legend_label: 'Protein Downregulation'
				}
			}
		},
		legend_label: "Genetic Alteration",
	};
	var genetic_alteration_config_nondistinct_mutations = $.extend(true,{},genetic_alteration_config_base);
	genetic_alteration_config_nondistinct_mutations.altered.mut_type = {
		'*': {
			shape: 'middle-rect',
			color: 'green',
			legend_label: 'Mutation'
		}
	};
	var genetic_alteration_config = $.extend(true,{},genetic_alteration_config_base);
	genetic_alteration_config.altered.mut_type = {
		'MISSENSE': {
			shape: 'middle-rect',
			color: 'green',
			legend_label: 'Missense Mutation'
		},
		'INFRAME': {
			shape: 'middle-rect',
			color: '#9F8170',
			legend_label: 'Inframe Mutation'
		},
		'TRUNC': {
			shape: 'middle-rect',
			color: 'black',
			legend_label: 'Truncating Mutation'
		},
		'FUSION':{
			shape: 'large-right-arrow',
			color: 'black',
			legend_label: 'Fusion'
		}
	};
	
	return {
		genetic_alteration_config: genetic_alteration_config,
		genetic_alteration_config_nondistinct_mutations: genetic_alteration_config_nondistinct_mutations,
		genetic_alteration_comparator: makeGeneticAlterationComparator(true),
		genetic_alteration_comparator_nondistinct_mutations: makeGeneticAlterationComparator(false)
	};
})();
;
window.oncoprint_RuleSet = (function() {
	var utils = oncoprint_utils;
	var defaults = oncoprint_defaults;

	var CATEGORICAL_COLOR = 'categorical_color';
	var GRADIENT_COLOR = 'gradient_color'; 
	var GENETIC_ALTERATION = 'genetic_alteration';
	var BAR_CHART = 'bar_chart';

	var CELL = "cell";
	var ANY = '*';

	var getRuleSetId = utils.makeIdCounter();

	var numericalNaNSort = function(d1, d2) {
		var f1 = parseFloat(d1[this.data_key], 10);
		var f2 = parseFloat(d2[this.data_key], 10);
		var f1_isNaN = isNaN(f1);
		var f2_isNaN = isNaN(f2);
		if (f1_isNaN && f2_isNaN) {
			return 0;
		} else if (!f1_isNaN && !f2_isNaN) {
			if (f1 < f2) {
				return -1;
			} else if (f1 > f2) {
				return 1;
			} else {
				return 0;
			}	
		} else if (f1_isNaN) {
			return Number.POSITIVE_INFINITY;
		} else {
			return Number.NEGATIVE_INFINITY;
		}
	};
	var makeNARuleParams = function(condition, label) {
		return {
				condition: condition,
				shape: utils.makeD3SVGElement('rect'),
				attrs: {fill: '#eeeeee', width: '100%', height:'100%'},
				legend_label: label,
				children: [{
					condition: condition,
					shape: utils.makeD3SVGElement('path'),
					attrs: {d: "m 0% 0% L 100% 100%"},
					styles: {'stroke-width':'1px', 'stroke':'#555555'},
					legend_label: label,
				}],
			};
	};
	var D3SVGRuleSet = (function() {
		function D3SVGRuleSet(params) {
			this.rule_map = {};
			this.rule_set_id = getRuleSetId();
			this.legend_label = params.legend_label;
			this.exclude_from_legend = false;
		};
		var getRuleId = utils.makeIdCounter();

		D3SVGRuleSet.prototype.getLegendLabel = function() {
			return this.legend_label;
		};
		D3SVGRuleSet.prototype.getRuleSetId = function() {
			return this.rule_set_id;
		};
		D3SVGRuleSet.prototype.addRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGRule(params, rule_id);
			return rule_id;
		}
		D3SVGRuleSet.prototype.addStaticRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGStaticRule(params, rule_id);
			return rule_id;
		};
		D3SVGRuleSet.prototype.addGradientRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGGradientRule(params, rule_id);
			return rule_id;
		};
		D3SVGRuleSet.prototype.addBarChartRule = function(params) {
			var rule_id = getRuleId();
			this.rule_map[rule_id] = new D3SVGBarChartRule(params, rule_id);
			return rule_id;
		};
		D3SVGRuleSet.prototype.removeRule = function(rule_id) {
			delete this.rule_map[rule_id];
		};
		D3SVGRuleSet.prototype.getRules = function() {
			var self = this;
			var rule_ids = Object.keys(this.rule_map);
			var rules = _.map(rule_ids, function(id) { return self.rule_map[id]; });
			var sorted_rules = _.sortBy(rules, function(r) { return r.z_index; });
			return sorted_rules;
		};
		D3SVGRuleSet.prototype.apply = function(g, cell_width, cell_height) {
			var active_rules = {};
			_.each(this.getRules(), function(rule) {
				var affected_groups = rule.filter(g);
				if (affected_groups[0].length > 0) {
					active_rules[rule.rule_id] = true;
				}
				rule.apply(affected_groups, cell_width, cell_height);
			});
			return active_rules;
		};
		D3SVGRuleSet.prototype.getRule = function(rule_id) {
			return this.rule_map[rule_id];
		};
		return D3SVGRuleSet;
	})();

	function D3SVGCategoricalColorRuleSet(params) {
		D3SVGRuleSet.call(this, params);
		this.type = CATEGORICAL_COLOR;
		var self = this;
		var d3_colors = ["#3366cc","#dc3912","#ff9900","#109618",
				"#990099","#0099c6","#dd4477","#66aa00",
				"#b82e2e","#316395","#994499","#22aa99",
				"#aaaa11","#6633cc","#e67300","#8b0707",
				"#651067","#329262","#5574a6","#3b3eac",
				"#b77322","#16d620","#b91383","#f4359e",
				"#9c5935","#a9c413","#2a778d","#668d1c",
				"#bea413","#0c5922","#743411"];/*_.shuffle(_.filter(d3.scale.category20().range().concat(d3.scale.category20b().range()).concat(d3.scale.category20c().range()),
									function(color) {
										var rgb = d3.rgb(color);
										return !(rgb.r === rgb.g && rgb.g === rgb.b);
									}));*/
		var addColorRule = function(color, category) {
			var colored_rect = utils.makeD3SVGElement('rect').attr('fill', color);
			var condition = (function(cat) {
				return function(d) {
					return params.getCategory(d) === cat;
				};
			})(category);
			self.addStaticRule({
				condition: condition,
				shape: colored_rect,
				legend_label: category
			});
		};
		params.color = params.color || {};
		_.each(params.color, function(color, category) {
			addColorRule(color, category);
		});
		self.addStaticRule(makeNARuleParams(function(d) {
			return params.getCategory(d) === 'NA';
		}, 'NA'));

		this.sort_cmp = params.sort_cmp || function(d1,d2) {
			var cat1 = params.getCategory(d1);
			var cat2 = params.getCategory(d2);
			if (typeof cat1 !== 'string') {
				cat1 = cat1.toString();
			}
			if (typeof cat2 !== 'string') {
				cat2 = cat2.toString();
			}
			if (cat1 === cat2) {
				return 0;
			} else if (cat1 === 'NA') {
				return Number.POSITIVE_INFINITY;
			} else if (cat2 === 'NA') {
				return Number.NEGATIVE_INFINITY;
			} else {
				return cat1.localeCompare(cat2);
			}
		};
		self.apply = function(g, cell_width, cell_height) {
			g.each(function(d,i) {
				var category = params.getCategory(d);
				if (!params.color.hasOwnProperty(category) && category !== "NA") {
					var new_color = d3_colors.pop();
					params.color[category] = new_color;
					addColorRule(new_color, category);
				}
			});
			return D3SVGRuleSet.prototype.apply.call(this, g, cell_width, cell_height);
		};

		self.getLegendDiv = function(active_rules, cell_width, cell_height) {
			var div = d3.select(document.createElement('div'));
			_.each(self.getRules(), function(rule) {
				if (active_rules[rule.rule_id]) {
					var legend_div = rule.getLegendDiv(cell_width, cell_height);
					if (legend_div) {
						div.node().appendChild(legend_div);
					}
				}
			});
			utils.d3SelectChildren(div, '*').style('padding-right', '20px');
			return div.node();
		};
	}
	D3SVGCategoricalColorRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	function D3SVGGradientColorRuleSet(params) {
		D3SVGRuleSet.call(this, params);
		this.type = GRADIENT_COLOR;
		this.data_key = params.data_key;
		var rule = this.addGradientRule({
			shape: utils.makeD3SVGElement('rect'),
			data_key: params.data_key,
			data_range: params.data_range,
			color_range: params.color_range,
			scale: params.scale,
			na_color: params.na_color
		});
		this.addStaticRule(makeNARuleParams(function(d) {
			return isNaN(d[params.data_key]);
		}, 'NA'));
		this.sort_cmp = params.sort_cmp || $.proxy(numericalNaNSort, this);
		this.getLegendDiv = function(active_rules, cell_width, cell_height) {
			return (active_rules[rule] && this.rule_map[rule].getLegendDiv(cell_width, cell_height)) || $('<div>')[0];
		};
	}
	D3SVGGradientColorRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	function D3SVGBarChartRuleSet(params) {
		D3SVGRuleSet.call(this, params);
		var self = this;
		self.type = BAR_CHART;
		self.data_key = params.data_key;
		var rule = this.addBarChartRule({
			data_key: params.data_key,
			data_range: params.data_range,
			scale: params.scale,
			fill: params.fill,
			na_color: params.na_color
		});
		this.addStaticRule(makeNARuleParams(function(d) {
			return isNaN(d[params.data_key]);
		}, 'NA'));
		this.sort_cmp = params.sort_cmp || $.proxy(numericalNaNSort, this);
		this.getLegendDiv = function(active_rules, cell_width, cell_height) {
			return (active_rules[rule] && this.rule_map[rule].getLegendDiv(cell_width, cell_height)) || $('<div>')[0];
		};
	}
	D3SVGBarChartRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	function D3SVGGeneticAlterationRuleSet(params) {
		if (params && params.dont_distinguish_mutation_color) {
			params = $.extend({}, params, defaults.genetic_alteration_config_nondistinct_mutations);
		} else {
			params = $.extend({}, params, defaults.genetic_alteration_config);
		}
		if (params && params.distinguish_mutation_order) {
			this.sort_cmp = defaults.genetic_alteration_comparator;
		} else {
			this.sort_cmp = defaults.genetic_alteration_comparator_nondistinct_mutations;
		}
		D3SVGRuleSet.call(this, params);
		var vocab = ['full-rect', 'middle-rect', 'large-right-arrow', 'small-up-arrow', 'small-down-arrow'];
		var self = this;
		self.type = GENETIC_ALTERATION;

		var makeStaticShapeRule = function(rule_spec, key, value) {
			var condition = typeof key !== 'undefined' && typeof value !== 'undefined' ? (function(_key, _value) {
				if (_value === ANY) {
					return function(d) {
						return typeof d[_key] !== 'undefined';
					}
				} else {
					return function(d) {
						return d[_key] === _value;
					};
				}
			})(key, value) : undefined;
			var shape, attrs, styles, z_index;
			switch (rule_spec.shape) {
				case 'full-rect':
					shape = utils.makeD3SVGElement('rect');
					attrs = {fill: rule_spec.color, width: '100%', height: '100%'};
					styles = {};
					z_index = utils.ifndef(rule_spec.z_index, 0);
					break;
				case 'middle-rect':
					shape = utils.makeD3SVGElement('rect');
					attrs = {fill: rule_spec.color, width: '100%', height: '33.33%', y: '33.33%'};
					styles = {};
					z_index = utils.ifndef(rule_spec.z_index, 1);
					break;
				case 'large-right-arrow':
					shape = utils.makeD3SVGElement('polygon');
					attrs = {points: "0%,0% 100%,50% 0%,100%"};
					styles = {'stroke-width':'0px', 'fill': rule_spec.color};
					z_index = utils.ifndef(rule_spec.z_index, 2);
					break;
				case 'small-up-arrow':
					shape = utils.makeD3SVGElement('polygon');
					attrs = {points: "50%,0% 100%,25% 0%,25%"};
					styles = {'stroke-width':'0px', 'fill': rule_spec.color};
					z_index = utils.ifndef(rule_spec.z_index, 3);
					break;
				case 'small-down-arrow':
					shape = utils.makeD3SVGElement('polygon');
					attrs = {points: "50%,100% 100%,75% 0%,75%"};
					styles = {'stroke-width':'0px', 'fill': rule_spec.color};
					z_index = utils.ifndef(rule_spec.z_index, 4);
					break;
				case 'outline':
					shape = CELL;
					styles = {'outline-color':rule_spec.color, 'outline-style':'solid', 'outline-width':'2px'};
					z_index = utils.ifndef(rule_spec.z_index, 5);
					break;
			}
			var new_rule = self.addStaticRule({
				condition: condition,
				shape: shape,
				attrs: attrs,
				styles: styles,
				z_index: z_index,
				legend_label: rule_spec.legend_label,
				exclude_from_legend: (typeof rule_spec.legend_label === "undefined")
			});
			return new_rule;
		};
		var altered_rules = [];
		_.each(params.altered, function(values, key) {
			_.each(values, function(rule_spec, value) {
				altered_rules.push(makeStaticShapeRule(rule_spec, key, value));
			});
		});
		_.each(params.default, function(rule_spec) {
			makeStaticShapeRule(rule_spec);
		});
		self.getLegendDiv = function(active_rules, cell_width, cell_height) {
			var div = d3.select(document.createElement('div'));
			_.each(self.getRules(), function(rule) {
				if (active_rules[rule.rule_id]) {
					var legend_div = rule.getLegendDiv(cell_width, cell_height);
					if (legend_div) {
						div.node().appendChild(legend_div);
					}
				}
			});
			utils.d3SelectChildren(div, '*').style('padding-right', '20px');
			return div.node();
		};
		self.alteredData = function(data) {
			var altered_data = [];
			_.each(altered_rules, function(rule_id) {
				altered_data = altered_data.concat(self.getRule(rule_id).filterData(data));
			});
			return _.uniq(altered_data);
		};
	}
	D3SVGGeneticAlterationRuleSet.prototype = Object.create(D3SVGRuleSet.prototype);

	var D3SVGRule = (function() {
		function D3SVGRule(params, rule_id) {
			this.rule_id = rule_id;
			this.condition = params.condition || function(d) { return true; };
			this.shape = typeof params.shape === 'undefined' ? utils.makeD3SVGElement('rect') : params.shape;
			this.z_index = typeof params.z_index === 'undefined' ? this.rule_id : params.z_index;
			this.legend_label = params.legend_label;
			this.exclude_from_legend = params.exclude_from_legend;

			this.attrs = params.attrs || {};
			this.attrs.width = utils.ifndef(this.attrs.width, '100%');
			this.attrs.height = utils.ifndef(this.attrs.height, '100%');
			this.attrs.x = utils.ifndef(this.attrs.x, 0);
			this.attrs.y = utils.ifndef(this.attrs.y, 0);

			this.styles = params.styles || {};

			this.children = _.map(params.children, function(p) {
				return new D3SVGRule(p);
			});
		}

		var percentToPx = function(attr_val, attr_name, cell_width, cell_height) {
			// convert a percentage to a local pixel coordinate
			var width_like = ['width', 'x'];
			var height_like = ['height', 'y'];
			attr_val = parseFloat(attr_val, 10)/100;
			if (width_like.indexOf(attr_name) > -1) {
				attr_val = attr_val*cell_width;
			} else if (height_like.indexOf(attr_name) > -1) {
				attr_val = attr_val*cell_height;
			} 
			return attr_val+'';
		};

		var convertAttr = function(d, i, attr_val, attr_name, cell_width, cell_height) {
			var ret = attr_val;
			if (typeof ret === 'function') {
				ret = ret(d,i);
			}
			if (typeof ret === 'string' && ret.indexOf('%') > -1) {
				if (attr_name === 'points') {
					ret = _.map(ret.split(" "), function(pt) {
						var split_pt = pt.split(",");
						var pt_x = percentToPx(split_pt[0], 'x', cell_width, cell_height);
						var pt_y = percentToPx(split_pt[1], 'y', cell_width, cell_height);
						return pt_x+","+pt_y;
					}).join(" ");
				} else if (attr_name === 'd') {
					var split = ret.split(/\s+/);
					for (var i=0, _len = split.length; i<_len; i++) {
						var c = split[i].toLowerCase();
						if (c === 'm' || c === 'l') {
							split[i+1] = percentToPx(split[i+1], 'x', cell_width, cell_height);
							split[i+2] = percentToPx(split[i+2], 'y', cell_width, cell_height);
							i += 2;
						}
					}
					return split.join(" ");
				} else {
					ret = percentToPx(ret, attr_name, cell_width, cell_height);
				}
			}
			return ret;
		};

		D3SVGRule.prototype.apply = function(g, cell_width, cell_height) {
			var shape = this.shape;
			var elts = shape === CELL ? g : utils.appendD3SVGElement(shape, g);
			var styles = this.styles;
			var attrs = this.attrs;
			attrs.x = attrs.x || 0;
			attrs.y = attrs.y || 0;
			_.each(attrs, function(val, key) {
				elts.attr(key, function(d,i) {
					return convertAttr(d, i, val, key, cell_width, cell_height);
				});
			});
			_.each(styles, function(val, key) {
				elts.style(key, val);
			});
			_.each(this.children, function(r) {
				r.apply(g, cell_width, cell_height);
			});
		}
		D3SVGRule.prototype.filter = function(g) {
			return g.filter(this.condition);
		};
		D3SVGRule.prototype.filterData = function(data) {
			return data.filter(this.condition);
		};
		D3SVGRule.prototype.showInLegend = function() {
			return !this.exclude_from_legend;
		};
		return D3SVGRule;
	})();
	

	function D3SVGBarChartRule(params, rule_id) {
		D3SVGRule.call(this, params, rule_id);
		this.data_key = params.data_key;
		this.data_range = params.data_range;
		this.inferred_data_range;
		this.attrs.fill = function(d) {
			if (isNaN(d[params.data_key])) {
				return params.na_color;
			}  else {
				return params.fill;
			}
		};
		this.na_color = params.na_color;

		var scale = function(x) {
			if (params.scale === 'log') {
				return Math.log10(Math.max(Math.abs(x), 0.1)); 
			} else {
				return x;
			}
		};
		var makeDatum = function(x) {
			var ret = {};
			ret[params.data_key] = x;
			return ret;
		};

		this.setUpHelperFunctions = function(data_range) {
			var scaled_data_range = _.map(data_range, scale);
			var height_helper = function(d) {
				var datum = scale(d[params.data_key]);
				var distance = Math.abs(datum-scaled_data_range[0]) / Math.abs(scaled_data_range[1]-scaled_data_range[0]);
				return distance * 100;
			};
			var y_function = function(d) {
				return (isNaN(d[params.data_key]) ? "0" : (100 - height_helper(d))) + '%';
			};
			var height_function = function(d) { 
				return (isNaN(d[params.data_key]) ? "100" : height_helper(d)) + '%';
			};
			this.attrs.height = height_function;
			this.attrs.y = y_function;
		};

		this.inferDataRange = function(g) {
			var self = this;
			var min = Number.POSITIVE_INFINITY;
			var max = Number.NEGATIVE_INFINITY;
			g.each(function(d,i) {
				var datum = d[self.data_key];
				var datumIsNaN = isNaN(datum);
				min = Math.min(min, datumIsNaN ? Number.POSITIVE_INFINITY : datum);
				max = Math.max(max, datumIsNaN ? Number.NEGATIVE_INFINITY : datum);
			});
			return [min, max];
		};

		this.getEffectiveDataRange = function() {
			if (typeof this.data_range === "undefined") {
				return this.inferred_data_range;
			} else {
				var ret = [];
				ret[0] = (typeof this.data_range[0] === 'undefined' ? this.inferred_data_range[0] : this.data_range[0]);
				ret[1] = (typeof this.data_range[1] === 'undefined' ? this.inferred_data_range[1] : this.data_range[1]);
				return ret;
			}
		};
		this.getLegendDiv = function(cell_width, cell_height) {
			if (!this.showInLegend()) {
				return;
			}
			var div = d3.select(document.createElement('div'));
			var data_range = this.getEffectiveDataRange();
			if (!data_range) {
				return div.node();
			}
			var display_data_range = _.map(data_range, function(x) { 
				var num_digit_multiplier = Math.pow(10, utils.ifndef(params.legend_num_decimal_digits,2));
				return Math.round(x * num_digit_multiplier) / num_digit_multiplier;
			});
			div.append('span').text(display_data_range[0]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', '0px');
			var mesh = 50;
			var svg = div.append('svg').attr('width', mesh+'px').attr('height', cell_height+'px').classed('oncoprint-legend-element', true)
			for (var i=0; i<=mesh; i++) {
				var t = i/mesh;
				var d = (1-t)*data_range[0] + t*data_range[1];
				var datum = makeDatum(d);
				var height = cell_height*parseInt(this.attrs.height(datum))/100;
				svg.append('rect')
					.attr('width', '1px')
					.attr('height', height+'px')
					.attr('y', (cell_height-height)+'px')
					.attr('fill', params.fill)
					.attr('x', i+'px');
			}
			div.append('span').text(display_data_range[1]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', cell_height - 3 + 'px');
			utils.d3SelectChildren(div, '*').style('padding-right', '10px');
			return div.node();
		};
		this.apply = function(g, cell_width, cell_height) {
			if (g[0].length === 0) {
				return;
			}
			this.inferred_data_range = this.inferDataRange(g);
			this.setUpHelperFunctions(this.getEffectiveDataRange());
			D3SVGRule.prototype.apply.call(this, g, cell_width, cell_height);
		};

	}
	D3SVGBarChartRule.prototype = Object.create(D3SVGRule.prototype);

	function D3SVGGradientRule(params, rule_id) {
		D3SVGRule.call(this, params, rule_id);
		this.data_key = params.data_key;
		this.data_range = params.data_range;
		this.inferred_data_range;
		this.color_range = params.color_range;
		this.na_color = params.na_color;

		var makeDatum = function(x) {
			var ret = {};
			ret[params.data_key] = x;
			return ret;
		};
		var scale = function(x) {
			if (params.scale === 'log') {
				return Math.log10(Math.max(x, 0.1)); 
			} else {
				return x;
			}
		};

		this.setUpHelperFunctions = function(data_range) {
			var scaled_data_range = _.map(data_range, scale);
			var fill_function = function(d) {
				if (isNaN(d[params.data_key])) {
					return params.na_color;
				}
 				var datum = scale(d[params.data_key]);
				var data_range = [scaled_data_range[0], scaled_data_range[1]];
				var distance = (datum-scaled_data_range[0]) / (scaled_data_range[1]-scaled_data_range[0]);
				color_range = [d3.rgb(params.color_range[0]).toString(),
						d3.rgb(params.color_range[1]).toString()];
				return utils.lin_interp(distance, params.color_range[0], params.color_range[1]);
			};
			this.attrs.fill = fill_function;
		};

		this.inferDataRange = function(g) {
			var self = this;
			var min = Number.POSITIVE_INFINITY;
			var max = Number.NEGATIVE_INFINITY;
			g.each(function(d,i) {
				var datum = d[self.data_key];
				var datumIsNaN = isNaN(datum);
				min = Math.min(min, datumIsNaN ? Number.POSITIVE_INFINITY : datum);
				max = Math.max(max, datumIsNaN ? Number.NEGATIVE_INFINITY : datum);
			});
			return [min, max];
		};

		this.getLegendDiv = function(cell_width, cell_height) {
			if (!this.showInLegend()) {
				return;
			}
			var div = d3.select(document.createElement('div'));
			var data_range = this.data_range || this.inferred_data_range;
			if (!data_range) {
				return div.node();
			}
			var display_data_range = _.map(data_range, function(x) { 
				var num_digit_multiplier = Math.pow(10, utils.ifndef(params.legend_num_decimal_digits,2));
				return Math.round(x * num_digit_multiplier) / num_digit_multiplier;
			});
			div.append('span').text(display_data_range[0]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', cell_height / 2 - 3 + 'px');
			var mesh = 50;
			var svg = div.append('svg').attr('width', mesh+'px').attr('height', cell_height+'px').classed('oncoprint-legend-element', true);
			for (var i=0; i<=mesh; i++) {
				var t = i/mesh;
				var d = (1-t)*data_range[0] + t*data_range[1];
				var datum = makeDatum(d);
				svg.append('rect')
					.attr('width', '1px')
					.attr('height', cell_height+'px')
					.attr('fill', this.attrs.fill(datum))
					.attr('x', i+'px');
			}
			div.append('span').text(display_data_range[1]).classed('oncoprint-legend-label oncoprint-legend-element', true)
					.style('position', 'relative').style('bottom', cell_height / 2 - 3 + 'px');
			utils.d3SelectChildren(div, '*').style('padding-right', '10px');
			return div.node();
		};
		this.apply = function(g, cell_width, cell_height) {
			this.setUpHelperFunctions(this.data_range || (this.inferred_data_range = this.inferDataRange(g)));
			D3SVGRule.prototype.apply.call(this, g, cell_width, cell_height);
		};
	}
	D3SVGGradientRule.prototype = Object.create(D3SVGRule.prototype);

	function D3SVGStaticRule(params, rule_id) {
		D3SVGRule.call(this, params, rule_id);

		this.getLegendDiv = function(cell_width, cell_height) {
			if (!this.showInLegend()) {
				return;
			}
			var div = d3.select(document.createElement('div'));
			var svg_ctr = div.append('div').classed('oncoprint-legend-block', true);
			var svg = svg_ctr.append('svg').attr('width', cell_width+'px').attr('height', cell_height+'px').classed('oncoprint-legend-element', true);
			this.apply(svg, cell_width, cell_height);
			if (this.legend_label) {
				div.append('span').text(this.legend_label).classed('oncoprint-legend-label oncoprint-legend-element', true)
						.style('position', 'relative').style('bottom', cell_height / 2 - 3 + 'px');
			}
			utils.d3SelectChildren(div, '*').style('padding-right', '10px');
			return div.node();
		};
	}
	D3SVGStaticRule.prototype = Object.create(D3SVGRule.prototype);

	return {
		CATEGORICAL_COLOR: CATEGORICAL_COLOR,
		GRADIENT_COLOR: GRADIENT_COLOR,
		GENETIC_ALTERATION: GENETIC_ALTERATION,
		BAR_CHART: BAR_CHART,
		makeRuleSet: function(type, params) {
			if (type === CATEGORICAL_COLOR) {
				return new D3SVGCategoricalColorRuleSet(params);
			} else if (type === GRADIENT_COLOR) {
				return new D3SVGGradientColorRuleSet(params);
			} else if (type === GENETIC_ALTERATION) {
				return new D3SVGGeneticAlterationRuleSet(params);
			} else if (type === BAR_CHART) {
				return new D3SVGBarChartRuleSet(params);
			} else {
				return new D3SVGRuleSet();
			}
		}
	};
})();;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.OncoprintRenderer = (function() {
	var events = oncoprint_events;
	var utils = oncoprint_utils;
	var RuleSet = oncoprint_RuleSet;

	function OncoprintRenderer(oncoprint, config) {
		this.rule_sets = {};
		this.clipping = true;
		this.oncoprint = oncoprint;
		this.config = config;
		this.upper_padding = utils.ifndef(config.upper_padding, 0);
		this.max_label_length = utils.ifndef(config.max_label_length, 20);
		this.track_group_separation = 12;

		(function computeLabelAreaWidth(self) {
			var label_font = self.getLabelFont();
			var max_label_width = utils.textWidth((Math.pow(10,self.max_label_length)-1).toString(), label_font);
			var max_percent_altered_width = utils.textWidth('100%', label_font);
			var buffer_width = 20;
			self.label_area_width = max_label_width + buffer_width + max_percent_altered_width;
		})(this);
	};
	OncoprintRenderer.prototype.getCellCSSClass = function() {
		return 'oncoprint-cell';	
	};
	OncoprintRenderer.prototype.getTrackCellCSSClass = function(track_id) {
		return this.getCellCSSClass()+track_id;
	};
	OncoprintRenderer.prototype.getTrackLabelCSSClass = function(track_id) {
		return 'oncoprint-track-label oncoprint-track-label'+track_id;
	};
	OncoprintRenderer.prototype.getTrackLabelCSSSelector = function(track_id) {
		// TODO: replace with utils.cssClassToSelector
		return "."+this.getTrackLabelCSSClass(track_id).split(" ").join(".");
	};
	OncoprintRenderer.prototype.getTrackCellCtrCSSClass = function(track_id) {
		return 'oncoprint-track-cell-ctr'+track_id;
	};
	OncoprintRenderer.prototype.getLabelFont = function() {
		return this.config.label_font;
	};
	OncoprintRenderer.prototype.setRuleSet = function(track_id, type, params) {
		var new_rule_set = RuleSet.makeRuleSet(type, params);
		this.rule_sets[track_id] = new_rule_set;
		if (new_rule_set.sort_cmp) {
			this.oncoprint.setTrackSortComparator(track_id, new_rule_set.sort_cmp);
		}
	};
	OncoprintRenderer.prototype.useSameRuleSet = function(target_track_id, source_track_id) {
		var rule_set = this.rule_sets[source_track_id];
		this.rule_sets[target_track_id] = rule_set;
		if (rule_set.sort_cmp) {
			this.oncoprint.setTrackSortComparator(target_track_id, rule_set.sort_cmp);
		}
	};
	OncoprintRenderer.prototype.getRuleSet = function(track_id) {
		return this.rule_sets[track_id];
	};
	OncoprintRenderer.prototype.getTrackTops = function() {
		var ret = {};
		var y = this.upper_padding;
		var self = this;
		_.each(this.oncoprint.getTrackGroups(), function(group) {
			if (group.length === 0) {
				return;
			}
			_.each(group, function(id) {
				ret[id] = y;
				y+= self.getRenderedTrackHeight(id);
			});
			y += self.track_group_separation;
		});
		return ret;
	};
	OncoprintRenderer.prototype.getTrackCellTops = function() {
		return this.track_cell_tops || this.computeTrackCellTops();
	};
	OncoprintRenderer.prototype.computeTrackCellTops = function() {
		var tops = this.getTrackTops();
		var self = this;
		_.each(tops, function(top, id) {
			tops[id] = top + self.oncoprint.getTrackPadding(id);
		});
		this.track_cell_tops = tops;
		return tops;
	};
	OncoprintRenderer.prototype.getTrackLabelTops = function() {
		return this.getTrackCellTops();
	};
	OncoprintRenderer.prototype.getRenderedTrackHeight = function(track_id) {
		return this.oncoprint.getTrackHeight(track_id) + 2*this.oncoprint.getTrackPadding(track_id);
	};
	OncoprintRenderer.prototype.getCellX = function(index) {
		return (typeof index === 'number' ? index*(this.oncoprint.getZoomedCellWidth()+this.oncoprint.getCellPadding()) : -1);
	};
	OncoprintRenderer.prototype.getCellXArray = function(length) {
		var cell_unit = this.oncoprint.getZoomedCellWidth() + this.oncoprint.getCellPadding();
		return _.map(_.range(0,length), function(x) { return x*cell_unit; });
	};
	OncoprintRenderer.prototype.getCellAreaWidth = function() {
		return this.oncoprint.getVisibleIdOrder().length*(this.oncoprint.getZoomedCellWidth() + this.oncoprint.getCellPadding());
	};
	OncoprintRenderer.prototype.getCellAreaHeight = function() {
		var track_tops = this.getTrackTops();
		var track_order = this.oncoprint.getTracks();
		if (track_order.length === 0) {
			return 0;
		} else {
			var last_track = track_order[track_order.length-1];
			return track_tops[last_track] + this.getRenderedTrackHeight(last_track);
		}
	};
	OncoprintRenderer.prototype.getLabelAreaWidth = function() {
		return this.label_area_width;
	};
	OncoprintRenderer.prototype.getLabelAreaHeight = function() {
		return this.getCellAreaHeight();
	};
	OncoprintRenderer.prototype.render = function() {
		throw "not implemented in abstract class";
	}
	return OncoprintRenderer;
})();;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 window.OncoprintSVGRenderer = (function() {
	var events = oncoprint_events;
	var utils = oncoprint_utils;

	var TOOLBAR_CONTAINER_CLASS = 'oncoprint-toolbar-ctr';
	var LABEL_AREA_CONTAINER_CLASS = 'oncoprint-label-area-ctr';
	var CELL_AREA_CONTAINER_CLASS = 'oncoprint-cell-area-ctr';
	var CELL_AREA_CLASS = 'oncoprint-cell-area';
	var COLUMN_HIGHLIGHT_CLASS = 'oncoprint-column-highlight'
	
	var CELL_HOVER_CLASS = 'oncoprint-cell-hover';
	var LEGEND_HEADER_CLASS = 'oncoprint-legend-header';
	var LABEL_DRAGGING_CLASS = 'oncoprint-label-dragging';
	var LABEL_DRAGGABLE_CLASS = 'oncoprint-label-draggable';
	var CELL_QTIP_CLASS = 'oncoprint-cell-qtip';

	function OncoprintSVGRenderer(container_selector_string, oncoprint, config) {
		OncoprintRenderer.call(this, oncoprint, config);
		var self = this;
		this.track_cell_selections = {};
		this.track_cells = {};
		this.active_rule_set_rules = {};
		this.toolbar_container;
		this.label_div;
		this.label_drag_div;
		this.label_container;
		this.cell_container;
		this.cell_container_node;
		this.cell_div;
		this.legend_table;
		this.document_fragment;
		this.percent_altered_max_width = utils.textWidth('100%', self.getLabelFont());
		this.altered_data_percentage = {};
		
		this.cell_tooltip_html = '';

		this.container = d3.select(container_selector_string);
		this.container.classed('noselect', true).selectAll('*').remove();
		this.container.append('br');
		var content_area = d3.select(container_selector_string).append('div').classed('oncoprint-content-area', true);
		(function initLabelContainer() {
			self.label_container = content_area.append('div').classed(LABEL_AREA_CONTAINER_CLASS, true).style('position', 'relative');
			self.label_div = self.label_container.append('div').style('position', 'relative').style('overflow', 'hidden');
			self.label_drag_div = self.label_container.append('div').style('position', 'absolute').style('overflow', 'hidden')
							.style('top', '0px').style('left','0px')
							.style('display','none');
		})();
		(function initCellContainer() {
			self.cell_container = content_area.append('div').classed(CELL_AREA_CONTAINER_CLASS, true);
			self.cell_column_highlight = self.cell_container.append('div').classed(COLUMN_HIGHLIGHT_CLASS, true)
						.style('height', self.getCellAreaHeight())
						.style('visibility', 'hidden');

			self.cell_container_node = self.cell_container.node();
			self.cell_div = self.cell_container.append('div').classed(CELL_AREA_CLASS, true);

		
			self.cell_mouseover_div = self.cell_container.append('div').style('position', 'absolute').style('overflow', 'hidden')
							.style('top', '0px').style('left','0px');
			self.cell_container_node.addEventListener("scroll", function() {
				self.calculateVisibleInterval();
				self.clipAndPositionCells();
			});
			var mouseMove, mouseOut;
			(function() {
				var prev_track, prev_cell_index, prev_dom, highlighted_col_cells = [];
				var column_highlight_timeout;
				$(self.cell_div.node()).qtip({
					content: 'SHARED QTIP',
					position: {target: 'event', my:'bottom middle', at:'top middle', viewport: $(window)},
					style: { classes: CELL_QTIP_CLASS, border: 'none'},
					show: {event: "cell-mouseover"},
					hide: {fixed: true, delay: 100, event: "cell-mouseout"},
					events: {
						show: function() {
							$(this).find('.qtip-content').html(self.cell_tooltip_html);
						},
						render: function(){
							$(this).find('.qtip-content').html(self.cell_tooltip_html);
						}
					}
				});
				var hover_cell = function(dom) {
					$('.'+CELL_QTIP_CLASS).finish();
					$(dom).trigger("cell-mouseover");
				};
				var unhover_cell = function(dom) {
					$('.'+CELL_QTIP_CLASS).finish();
					$(dom).trigger("cell-mouseout");
				};
				var clear_and_unhover = function() {
					prev_track = undefined;
					prev_cell_index = undefined;
					prev_dom && unhover_cell(prev_dom);
					prev_dom = undefined;
					//self.cell_column_highlight.style('visibility', 'hidden');
					column_highlight_timeout && clearTimeout(column_highlight_timeout)
					_.each(highlighted_col_cells, function(cell) {
						if (cell) {
							cell.style.border = '';
							cell.style.margin = '';
						}
					});
					highlighted_col_cells = [];
				};
				mouseOut = function() {
					clear_and_unhover();
				};
				mouseMove = function(evt) {
					var mouseX = utils.mouseX(evt);
					var mouseY = utils.mouseY(evt);
					var track_cell_tops = self.getTrackCellTops();
					var track = (function() {
						var closest_track_dist = Number.POSITIVE_INFINITY;
						var closest_track = undefined;
						_.each(track_cell_tops, function(top, track_id) {
							var dist = mouseY - top;
							if (dist >= 0 && dist < closest_track_dist) {
								closest_track_dist = dist;
								closest_track = track_id;
							}
						});
						return closest_track;
					})();
					if (!track) {
						clear_and_unhover();
						return;
					}
					var track_height = oncoprint.getCellHeight(track);
					if (mouseY > track_cell_tops[track] + track_height) {
						clear_and_unhover();
						return;
					}
					var cell_width = oncoprint.getZoomedCellWidth();
					var cell_unit = cell_width + oncoprint.getCellPadding();
					if (mouseX % cell_unit > cell_width) {
						clear_and_unhover();
						return;
					}
					// at this point, we are hovered over a cell position
					var cell_index = Math.floor(mouseX / cell_unit);
					if (cell_index !== prev_cell_index || track !== prev_track) {
						//self.cell_column_highlight.style('visibility', 'hidden');
						column_highlight_timeout && clearTimeout(column_highlight_timeout)
						// not the same cell as before
						clear_and_unhover();
						var cell_id = oncoprint.getVisibleIdOrder()[cell_index];
						var track_cell = self.track_cells[track][cell_id];
						if (!track_cell) {
							// track doesn't have a cell there
							return;
						}
						// otherwise, we're over a cell
						$('.'+CELL_QTIP_CLASS).finish().hide();
						prev_cell_index = cell_index;
						prev_track = track;
						prev_dom = track_cell.dom;
						self.cell_tooltip_html = oncoprint.getTrackTooltip(track)(track_cell.d);
						hover_cell(prev_dom);
						column_highlight_timeout = setTimeout(function() {
							highlighted_col_cells = _.map(self.track_cells, function(cells, track_id) {
								var cell = cells[cell_id].dom;
								if (cell) {
									if (track_id === track) {
										cell.style.border = "1px solid #000000";
										cell.style.margin = "-1px";
									} else {
										cell.style.border = "1px solid #999999";
										cell.style.margin = "-1px";
									}
								}
								return cell;
							});
						}, 200);
					}
				};
			})();
			self.cell_mouseover_div.node().addEventListener('mousemove', mouseMove);
			self.cell_mouseover_div.node().addEventListener('mouseout', mouseOut);
			// TODO: magic number
			self.cell_div.style('max-width', '1000px');
		})();
		$(content_area.node()).hover(function() {
			$(self.label_div.node()).find('.'+self.getTrackButtonCSSClass()).stop().fadeTo(80,1);
		}, function() {
			$(self.label_div.node()).find('.'+self.getTrackButtonCSSClass()).stop().fadeOut(500);
		});
		(function initLegend() {
			if (config.legend) {
				self.legend_table = d3.select(container_selector_string).append('table').style('border-collapse', 'collapse');
			}
		})();
		(function reactToOncoprint() {
			$(oncoprint).on(events.REMOVE_TRACK, function(evt, data) {
				var track_id = data.track_id;
				delete self.rule_sets[track_id];
				delete self.track_cell_selections[track_id];
				delete self.altered_data_percentage[track_id];
				self.removeTrackCells(track_id);
				self.removeTrackLabels(track_id);
				self.removeTrackButtons(track_id);
				
				self.computeTrackCellTops();
				self.renderLegend();
				self.renderTrackLabels();
				self.renderTrackButtons();
				self.resizeLabelDiv();
				self.resizeCellDiv();
				oncoprint.sort();
			});
			$(oncoprint).on(events.MOVE_TRACK, function(evt, data) {
				self.computeTrackCellTops();
				self.clipAndPositionCells(data.moved_tracks, 'top', true);
				self.renderTrackLabels();
				self.renderTrackButtons();
				oncoprint.sort();
			});

			$(oncoprint).on(events.ADD_TRACK, function(e,d) {
				//this.cell_div.style('display', 'none');
				self.drawCells(d.track_id);
				self.clipAndPositionCells(undefined, 'top', true);
				self.computeTrackCellTops();
				self.renderTrackLabels();
				self.renderTrackButtons();
				self.resizeLabelDiv();
				//self.clipCells(true, d.track_id);
				//this.cell_div.style('display','inherit');
			});

			$(oncoprint).on(events.SET_TRACK_DATA, function(e,d) {
				//this.cell_div.style('display', 'none');
				self.drawCells(d.track_id);
				self.clipAndPositionCells(d.track_id, undefined, true);
				self.computeAlteredDataPercentage(d.track_id);
				self.renderTrackLabels(d.track_id);
				self.resizeCellDiv();
				self.renderLegend();
				//self.clipCells(true);
				//this.cell_div.style('display','inherit');
			});


			$(oncoprint).on(events.SET_CELL_PADDING, function(e,d) {
				self.clipAndPositionCells(undefined, undefined, true);
				self.resizeCellDiv();
			});

			$(oncoprint).on(events.SET_ZOOM, function(e,d) {
				self.clipAndPositionCells(undefined, undefined, true);
				self.resizeCells();
				self.resizeCellDiv();
				//self.cell_highlight.style('width', oncoprint.getZoomedCellWidth() + 'px');
			});

			$(oncoprint).on(events.SET_VISIBLE_ID_ORDER, function() {
				self.clipAndPositionCells(undefined, undefined, true);
				self.resizeCellDiv();
			});
		})();
	}
	utils.extends(OncoprintSVGRenderer, OncoprintRenderer);
	OncoprintSVGRenderer.prototype.computeAlteredDataPercentage = function(track_id) {
		var rule_set = this.getRuleSet(track_id);
		if (rule_set && rule_set.alteredData) {
			var data = this.oncoprint.getTrackData(track_id);
			var num_altered = rule_set.alteredData(data).length;
			var percent_altered = Math.floor(100 * num_altered / data.length);
			this.altered_data_percentage[track_id] = percent_altered;
		}
	};
	OncoprintSVGRenderer.prototype.getAlteredDataPercentage = function(track_id) {
		return this.altered_data_percentage[track_id];
	};
	OncoprintSVGRenderer.prototype.calculateVisibleInterval = function() {
		var cell_unit = this.oncoprint.getZoomedCellWidth() + this.oncoprint.getCellPadding();
		var cell_ctr_rect = this.cell_container_node.getBoundingClientRect();
		this.visible_interval = [this.cell_container_node.scrollLeft, this.cell_container_node.scrollLeft + cell_ctr_rect.right - cell_ctr_rect.left];
		return this.visible_interval;
	};
	OncoprintSVGRenderer.prototype.getVisibleInterval = function() {
		return (this.visible_interval || this.calculateVisibleInterval());
	};
	OncoprintSVGRenderer.prototype.cellRenderTarget = function() {
		return d3.select(this.document_fragment || this.cell_div.node());
	};
	OncoprintSVGRenderer.prototype.suppressRendering = function() {
		this.document_fragment = document.createDocumentFragment();
	};
	OncoprintSVGRenderer.prototype.releaseRendering = function() {
		this.cell_div.node().appendChild(this.document_fragment);
		this.document_fragment = undefined;
		var self = this;
		$(this.cell_div.node()).ready(function() {
			self.resizeCells();
			self.clipAndPositionCells(undefined, undefined, true);
		});
	};
	// Rule sets
	OncoprintSVGRenderer.prototype.setRuleSet = function(track_id, type, params) {
		OncoprintRenderer.prototype.setRuleSet.call(this, track_id, type, params);
		this.active_rule_set_rules[this.getRuleSet(track_id).getRuleSetId()] = {};
		this.drawCells(track_id);
		this.clipAndPositionCells(track_id, undefined, true);
		this.renderLegend();
		this.computeAlteredDataPercentage(track_id);
		this.renderTrackLabels(track_id);
	};
	OncoprintSVGRenderer.prototype.useSameRuleSet = function(target_track_id, source_track_id) {
		OncoprintRenderer.prototype.useSameRuleSet.call(this, target_track_id, source_track_id);
		this.drawCells(target_track_id);
		this.clipAndPositionCells(target_track_id, undefined, true);
		this.renderLegend();
		this.computeAlteredDataPercentage(target_track_id);
		this.renderTrackLabels(target_track_id);
	}

	// Containers
	OncoprintSVGRenderer.prototype.getLabelDiv = function() {
		return this.label_div;
	};
	OncoprintSVGRenderer.prototype.getLabelDragDiv = function() {
		return this.label_drag_div;
	};
	OncoprintSVGRenderer.prototype.resizeCellDiv = function() {
		this.cell_div.style('min-width', this.getCellAreaWidth()+'px')
				.style('min-height', this.getCellAreaHeight()+'px');
		
		this.cell_mouseover_div.style('min-width', this.getCellAreaWidth()+'px')
				.style('min-height', this.getCellAreaHeight()+'px');
		this.cell_column_highlight.style('height', this.getCellAreaHeight() + 'px');
	};
	OncoprintSVGRenderer.prototype.resizeLabelDiv = function() {
		this.getLabelDiv().style('width', this.getLabelAreaWidth()+'px')
				.style('height', this.getLabelAreaHeight()+'px');
		this.getLabelDragDiv().style('width', this.getLabelAreaWidth()+'px')
				.style('height', this.getLabelAreaHeight()+'px');
	};

	// Labels
	OncoprintSVGRenderer.prototype.removeTrackLabels =function(track_ids) {
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);	
		var div = this.label_div;
		var self = this;
		_.each(track_ids, function(track_id) {
			div.selectAll(self.getTrackLabelCSSSelector(track_id)).remove();
		});
	}
	OncoprintSVGRenderer.prototype.renderTrackLabels = function(track_ids, y, render_whole_labels) {
		var div = this.label_div;
		if (typeof y !== "undefined") {
			div.selectAll(this.getTrackLabelCSSSelector(track_ids)).style('top', y+'px');
		} else {
			track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
			track_ids = [].concat(track_ids);
			var label_tops = this.getTrackLabelTops();
			var self = this;
			var label_area_width = this.getLabelAreaWidth();
			var percent_altered_left = label_area_width - this.percent_altered_max_width;
			_.each(track_ids, function(track_id) {
				var label_top = label_tops[track_id];
				var track_label_class = self.getTrackLabelCSSClass(track_id);
				var label_text = self.oncoprint.getTrackLabel(track_id);
				var disp_label_text = label_text;
				if (label_text.length > self.max_label_length && !render_whole_labels) {
					disp_label_text = label_text.substring(0,self.max_label_length-3)+'...';
				}
				_.each(div.selectAll(self.getTrackLabelCSSSelector(track_id)), function(node) {
					$(node).qtip('destroy');
				});
				div.selectAll(self.getTrackLabelCSSSelector(track_id)).remove();
				var span = div.append('span')
					.style('position','absolute')
					.classed(self.getTrackLabelCSSClass(track_id), true)
					.classed('oncoprint-track-label-draggable', true)
					.classed('oncoprint-track-label-main', true)
					.classed('oncoprint-track-label', true)
					.classed('noselect', true)
					.style('font-family', self.getLabelFont())
					.style('font-weight', 'bold')
					.text(disp_label_text)
					.style('top', label_top+'px')
					.on("mousedown", function() {
						self.dragLabel(track_id);
					});
					$(span.node()).qtip( {content: {text: (label_text.length > self.max_label_length ? label_text+'<br> hold to drag' : 'hold to drag') },
									position: {my:'middle right', at:'middle left', viewport: $(window)},
									style: { classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow'},
									show: {event: "mouseover"}
								});
				var percent_altered = self.getAlteredDataPercentage(track_id);
				if (typeof percent_altered !== 'undefined') {
					div.append('span')
						.style('position','absolute')
						.classed(self.getTrackLabelCSSClass(track_id), true)
						.classed('oncoprint-track-label', true)
						.classed('noselect', true)
						.style('font-family', self.getLabelFont())
						.text(percent_altered + '%')
						.style('top', label_top+'px')
						.style('left', percent_altered_left+'px');	
				}
			});
		}
	};

	// Buttons
	OncoprintSVGRenderer.prototype.getTrackButtonCSSClass = function(track_id) {
		return 'oncoprint-track-button'+utils.ifndef(track_id, "");
	};
	OncoprintSVGRenderer.prototype.removeTrackButtons = function(track_ids) {
		var div = this.label_div;
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var self = this;
		_.each(track_ids, function(track_id) {
			div.selectAll('.'+self.getTrackButtonCSSClass(track_id)).remove();
		});
	};
	OncoprintSVGRenderer.prototype.renderTrackButtons = function(track_ids) {
		var div = this.label_div;
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var label_tops = this.getTrackLabelTops();
		var self = this;
		var label_area_width = this.getLabelAreaWidth();
		_.each(track_ids, function(track_id) {
			var button_class = self.getTrackButtonCSSClass(track_id);
			div.selectAll('.'+button_class).remove();
			var left = label_area_width - 15;
			if (self.oncoprint.isTrackRemovable(track_id)) {
				(function() {
					var new_btn = div.append('span').classed('noselect', true).style('font-size','12px').style('color', '#87CEFA').style('cursor', 'pointer')
					.classed(button_class, true).classed(self.getTrackButtonCSSClass(), true).on('click', function() {
						self.oncoprint.removeTrack(track_id);
					})
					.style('position', 'absolute').style('left', left+'px').style('top', label_tops[track_id]+'px');
					new_btn.text('X');
					$(new_btn.node()).hover(function() {
						new_btn.style('font-size', '15px').style('color', '#0000FF');
					}, function() {
						new_btn.style('font-size','12px').style('color', '#87CEFA');
					}).qtip({
				                    content: {text: 'Click to remove'},
				                    position: {my:'bottom middle', at:'top middle', viewport: $(window)},
				                    style: { classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow' },
				                    show: {event: "mouseover"},
				                    hide: {fixed: true, delay: 100, event: "mouseout"}
                    				});
				})();
				left -= 35;
			}
			if (self.oncoprint.isTrackSortDirectionChangable(track_id)) {
				(function() {
					var imgs = ['images/decreaseSort.svg', 'images/increaseSort.svg', 'images/nonSort.svg'];
					var descs = ['Click to sort in descending order', 'Click to not sort on this track', 'Click to sort in ascending order'];
					var sort_direction = [1, -1, 0];
					var current_sort_setting = sort_direction.indexOf(self.oncoprint.getTrackSortDirection(track_id));
					var new_btn = div.append('img');
					new_btn.attr('src', imgs[current_sort_setting]).style('cursor','pointer');
					$(new_btn.node()).qtip({
				                    content: {text: function() {
				                    	return descs[current_sort_setting];
				                    }},
				                    position: {my:'bottom middle', at:'top middle', viewport: $(window)},
				                    style: { classes: 'qtip-light qtip-rounded qtip-shadow qtip-lightyellow' },
				                    show: {event: "mouseover"},
				                    hide: {fixed: true, delay: 100, event: "mouseout"}
                    				});
					new_btn.classed(button_class, true).classed(self.getTrackButtonCSSClass(), true).on('click', function() {
						current_sort_setting = (current_sort_setting + 1) % 3;
						self.oncoprint.setTrackSortDirection(track_id, sort_direction[current_sort_setting]);//toggleTrackSortDirection(track_id);
						new_btn.attr('src', imgs[current_sort_setting]);
					})
					.style('position', 'absolute').style('left', left+'px').style('top', label_tops[track_id]+'px');
				})();
			}
		});
	};

	// Cells
	OncoprintSVGRenderer.prototype.resizeCells = function(new_width) {
		this.cell_div.selectAll('svg.'+this.getCellCSSClass()).style('width', this.oncoprint.getZoomedCellWidth()+'px');
	};
	OncoprintSVGRenderer.prototype.removeTrackCells = function(track_id) {
		this.cell_div.selectAll('svg.'+this.getTrackCellCSSClass(track_id)).remove();
	};
	OncoprintSVGRenderer.prototype.drawTrackCells = function(track_id, fragment) {
		var oncoprint = this.oncoprint;
		var data = oncoprint.getTrackData(track_id);
		var id_key = oncoprint.getTrackDatumIdKey(track_id);
		var id_accessor = oncoprint.getTrackDatumIdAccessor(track_id);
		var rule_set = this.getRuleSet(track_id);
		if (!rule_set) {
			return;
		}
		var self = this;

		this.track_cells[track_id] = {};
		var cell_class = this.getCellCSSClass();
		var track_cell_class = this.getTrackCellCSSClass(track_id);
		var track_cells = this.track_cells[track_id];

		var bound_svg = d3.select(fragment).selectAll('svg.'+track_cell_class).data(data);
		bound_svg.enter().append('svg').classed(track_cell_class, true).classed(cell_class, true)
			.attr('shape-rendering','geometricPrecision')
			.attr('preserveAspectRatio','none')
			.attr('viewBox', '0 0 '+oncoprint.getFullCellWidth()+' '+oncoprint.getCellHeight(track_id))
			.style('width', oncoprint.getZoomedCellWidth()+'px').style('height', oncoprint.getCellHeight(track_id)+'px');
		bound_svg.exit().remove();

		var tooltip = oncoprint.getTrackTooltip(track_id);
		bound_svg.each(function(d,i) {
			var dom_cell = this;
			var id = id_accessor(d);
			track_cells[id] = {dom: this, d: d};
		});
		bound_svg.selectAll('*').remove();
		this.active_rule_set_rules[rule_set.getRuleSetId()][track_id] = rule_set.apply(bound_svg, oncoprint.getFullCellWidth(), oncoprint.getCellHeight(track_id));
		self.track_cell_selections[track_id] = bound_svg;
	};
	OncoprintSVGRenderer.prototype.drawCells = function(track_ids) {
		var fragment;
		if (this.document_fragment) {
			//HACK
			fragment = document.createDocumentFragment();
		} else {
			fragment = this.cell_div.node();
		}
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var self = this;
		_.each(track_ids, function(track_id) {
			self.drawTrackCells(track_id, fragment);
		});
		if (this.document_fragment) {
			this.cellRenderTarget().node().appendChild(fragment);
		}
		setTimeout(function() {
			$(self).trigger(events.FINISHED_RENDERING);
		}, 0);
	};

	// Positioning
	OncoprintSVGRenderer.prototype.clipAndPositionCells = function(track_ids, axis, force, display_all) {
		this.cell_div.node().display = 'none';
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : track_ids;
		track_ids = [].concat(track_ids);
		var visible_interval = this.getVisibleInterval();
		var interval_width = 4*(visible_interval[1] - visible_interval[0]);
		var interval_number = Math.floor(visible_interval[0] / interval_width);
		visible_interval = _.map([-interval_width, 2*interval_width], function(x) { 
			return Math.max(x + interval_number*interval_width, 0); 
		});
		var self = this;
		var track_cell_tops = this.getTrackCellTops();
		var id_order = this.oncoprint.getVisibleInvertedIdOrder();
		var cell_x = this.getCellXArray(Object.keys(id_order).length);
		_.each(track_ids, function(track_id) {
			var y;
			if (!axis || axis === 'top') {
				y = track_cell_tops[track_id];
			}
			var id_key = self.oncoprint.getTrackDatumIdKey(track_id);
			if ((interval_number !== self.prev_interval_number) || force) {
				if (self.track_cell_selections.hasOwnProperty(track_id)) {
					self.track_cell_selections[track_id].each(function(d,i) {
						var new_x = cell_x[id_order[d[id_key]]];
						var disp = this.style.display;
						var new_disp = ((isNaN(new_x) || new_x < visible_interval[0] || new_x > visible_interval[1]) && !display_all) ? 'none' : 'inherit';
						if (disp !== new_disp) {
							this.style.display = new_disp;
						}
						if ((!axis || axis === 'left') && new_disp !== 'none') {
							this.style.left = new_x + 'px';
						}
						if ((!axis || axis === 'top') && new_disp !== 'none') {
							this.style.top = y+'px';
						}
					});
				}
			}
		});
		this.prev_interval_number = interval_number;
		this.cell_div.node().display = 'block';
	};

	OncoprintSVGRenderer.prototype.setLegendVisible = function(track_ids, visible) {
		var self = this;
		track_ids = typeof track_ids === "undefined" ? this.oncoprint.getTracks() : [].concat(track_ids);
		_.each(track_ids, function(id) {
			self.getRuleSet(id).exclude_from_legend = !visible;
		});
		this.renderLegend();
	};
	OncoprintSVGRenderer.prototype.renderLegend = function(include_all) {
		var cell_width = this.oncoprint.getFullCellWidth();
		var self = this;
		var rendered = {};
		self.legend_table.selectAll('*').remove();
		_.each(this.rule_sets, function(rule_set, track_id) {
			if (rule_set.exclude_from_legend && !include_all) {
				return;
			}
			var rule_set_id = rule_set.getRuleSetId();
			var active_rules = {};
			_.each(self.active_rule_set_rules[rule_set_id], function(track_map, track_id) {
				$.extend(active_rules, track_map);
			});
			if (!rendered.hasOwnProperty(rule_set_id)) {
				var tr = self.legend_table.append('tr');
				var label_header = tr.append('td').style('padding-top', '1em').style('padding-bottom', '1em')
							.append('span').classed('oncoprint-legend-header', true);
				label_header.text(rule_set.getLegendLabel());
				var legend_body_td = tr.append('td');
				var legend_div = rule_set.getLegendDiv(active_rules, cell_width, self.oncoprint.getCellHeight(track_id));
				legend_body_td.node().appendChild(legend_div);
				utils.d3SelectChildren(d3.select(legend_div), '*').classed('oncoprint-legend-block', true);
				rendered[rule_set_id] = true;
			}
		});
	};
	OncoprintSVGRenderer.prototype.dragLabel = function(track_id) {
		this.getLabelDragDiv().style('display','block');
		var track_group = this.oncoprint.getContainingTrackGroup(track_id);
		var first_track = track_group[0], last_track=track_group[track_group.length-1];
		var all_track_tops = this.getTrackLabelTops();
		var track_tops = {};
		_.each(track_group, function(id) { 
			track_tops[id] = all_track_tops[id];
		});
		track_group.splice(track_group.indexOf(track_id), 1);
		var group_track_tops = _.map(track_group, function(id) {
			return track_tops[id];
		});
		var label_area_height = this.getLabelAreaHeight();
		var drag_bounds = [undefined, undefined];
		drag_bounds[0] = utils.clamp(track_tops[first_track], 0, label_area_height);
		drag_bounds[1] = utils.clamp(track_tops[last_track]+this.getRenderedTrackHeight(last_track), 0, label_area_height);

		var self = this;
		var $label_drag_div = $(self.getLabelDragDiv().node());
		delete track_tops[track_id];

		(function(track_id) {
			var new_pos = -1;
			var moveHandler = function(evt) {
				if (evt.stopPropagation) {
					evt.stopPropagation();
				}
				if (evt.preventDefault) {
					evt.preventDefault();
				}
				var mouse_y = utils.clamp(utils.mouseY(evt), drag_bounds[0], drag_bounds[1]);
				self.renderTrackLabels(track_id, mouse_y);
				d3.selectAll(self.getTrackLabelCSSSelector(track_id)).classed(LABEL_DRAGGING_CLASS, true);
				
				new_pos = _.sortedIndex(group_track_tops, mouse_y);
				_.each(track_tops, function(top, id) {
					top += 3*(+(new_pos < track_group.length && track_group[new_pos] == id));
					top -= 3*(+(new_pos > 0 && track_group[new_pos-1] == id));
					self.renderTrackLabels(id, top);
				});
			}
			$label_drag_div.on("mousemove", moveHandler);
			var mouseUpHandler = function(evt) {
				$label_drag_div.hide();
				$label_drag_div.off("mousemove", moveHandler);
				if (new_pos > -1) {
					self.oncoprint.moveTrack(track_id, new_pos);
				}
			};
			$(document).one("mouseup", mouseUpHandler);
		})(track_id);
	};
	OncoprintSVGRenderer.prototype.toSVG = function(full_labels) {
		var self = this;
		var root = $(this.container.node()).offset();
		var svg = d3.select(document.createElementNS('http://www.w3.org/2000/svg', 'svg'));
		svg.attr('width', this.getLabelAreaWidth() + this.getCellAreaWidth() + 'px');
		this.renderLegend(true);
		this.renderTrackLabels(undefined, undefined, full_labels);
		svg.attr('height', $(this.container.node()).height()+'px');
		(function addLabels() {
			self.label_div.selectAll('.oncoprint-track-label').each(function() {
				var text_elt = d3.select(this);
				var font = text_elt.style('font-family') || 'Arial';
				var weight = text_elt.style('font-weight'); 
				var size = text_elt.style('font-size') || '12px';
				var pos = $(text_elt.node()).offset();
				var text = text_elt.text();
				svg.append('text').style('font-family', font).style('font-weight', weight).style('font-size', size)
						.attr('transform', utils.translate(pos.left - root.left,pos.top - root.top))
						.style('alignment-baseline', 'hanging')
						.text(text);	
			});
		})();
		(function addCells() {
			self.clipAndPositionCells(undefined, undefined, true, true);
			self.cell_div.selectAll('.oncoprint-cell').each(function() {
				var cell_elt = d3.select(this);
				var cell_rect = cell_elt.node().getBoundingClientRect();
				var cell_dim = {width: cell_rect.width, height: cell_rect.height};
				var pos = $(cell_elt.node()).offset();
				var g = svg.append('g').attr('transform', utils.translate(pos.left - root.left, pos.top - root.top));
				cell_elt.selectAll('*').each(function() {
					utils.appendD3SVGElement(d3.select(this), g);
				});
				var outline_styles = {color: cell_elt.style('outline-color'), width: cell_elt.style('outline-width')};
				if (outline_styles.color) {
					g.append('rect').attr('width', cell_dim.width+'px').attr('height', cell_dim.height+'px')
							.style('fill', 'none').style('stroke', outline_styles.color).style('stroke-width', outline_styles.width);
				}
			});
			//styles = {'outline-color':rule_spec.color, 'outline-style':'solid', 'outline-width':'2px'};
			self.clipAndPositionCells(undefined, undefined, true);
		})();
		(function addLegend() {
			self.legend_table.selectAll('tr').each(function() {
				d3.select(this).selectAll('td').each(function() {
					d3.select(this).selectAll('.oncoprint-legend-header,.oncoprint-legend-element').each(function() {
						if ($(this).text().trim().length) {
							// text type element
							var text_elt = d3.select(this);
							var font = text_elt.style('font-family') || 'Arial';
							if (font !== 'Arial') {
								console.log(this);
							}
							var weight = text_elt.style('font-weight'); 
							var size = text_elt.style('font-size') || '12px';
							var text = text_elt.text();
							var pos = $(text_elt.node()).offset();
							svg.append('text').style('font-family', font).style('font-weight', weight)
								.style('font-size', size)
								.attr('transform', utils.translate(pos.left - root.left, pos.top - root.top))
								.style('alignment-baseline', 'hanging')
								.text(text);
						} else if (this.tagName.toLowerCase() === 'svg') {
							var elt = d3.select(this);
							var pos = $(elt.node()).offset();
							var g = svg.append('g').attr('transform', utils.translate(pos.left - root.left, pos.top - root.top));
							var cell_rect = elt.node().getBoundingClientRect();
							var cell_dim = {width: cell_rect.width, height: cell_rect.height};
							var outline_styles = {color: elt.style('outline-color'), width: elt.style('outline-width')};
							if (outline_styles.color) {
								g.append('rect').attr('width', cell_dim.width+'px').attr('height', cell_dim.height+'px')
										.style('fill', 'none').style('stroke', outline_styles.color).style('stroke-width', outline_styles.width);
							}
							elt.selectAll('*').each(function() {
								utils.appendD3SVGElement(d3.select(this), g);
							});
						}
					});
				});
			});
		})();
		this.renderLegend();
		this.renderTrackLabels();
		return svg.node();
	};
	return OncoprintSVGRenderer;
})();;
/*
 * Copyright (c) 2015 Memorial Sloan-Kettering Cancer Center.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an "as is" basis, and Memorial Sloan-Kettering Cancer Center has no
 * obligations to provide maintenance, support, updates, enhancements or
 * modifications. In no event shall Memorial Sloan-Kettering Cancer Center be
 * liable to any party for direct, indirect, special, incidental or
 * consequential damages, including lost profits, arising out of the use of this
 * software and its documentation, even if Memorial Sloan-Kettering Cancer
 * Center has been advised of the possibility of such damage.
 */

/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
window.Oncoprint = (function() {
	var events = oncoprint_events;
	var utils = oncoprint_utils;
	var RuleSet = oncoprint_RuleSet;

	var defaultOncoprintConfig = {
		cell_width: 6,
		cell_padding: 2.5,
		legend: true,
	};

	var hiddenOncoprintConfig = {
		pre_track_padding: 0,
	};

	var defaultTrackConfig = {
		label: 'Gene',
		datum_id_key: 'patient',
		cell_height: 23,
		track_height: 20,
		track_padding: 5,
		sort_cmp: undefined,
		tooltip: function(d) {
			return d['patient'];
		},
		removable: false,
		sort_direction_changable: false
	}; 



	function Oncoprint(config) {
		var self = this;
		var getTrackId = utils.makeIdCounter();

		self.config = config;

		self.id_order = [];
		self.inverted_id_order = {};
		self.visible_id_order = [];
		self.visible_inverted_id_order = {};
		self.hidden_ids = {};
		self.track_groups = [[],[]];
		self.track_group_sort_order = [0,1];
		self.sort_direction = {};
		self.tracks = {};
		self.sort_config = {type: 'track'};

		self.cell_padding_on = true;
		self.true_cell_width = config.cell_width;

		self.zoomed_cell_width = self.true_cell_width;
		self.zoom = 1;

		// Cell Padding
		self.toggleCellPadding = function() {
			self.cell_padding_on = !self.cell_padding_on;
			$(self).trigger(events.SET_CELL_PADDING);
		};
		self.getCellPadding = function() {
			return Math.ceil(self.config.cell_padding*self.getZoom())*(+self.cell_padding_on);
		};

		// Zoom
		self.getZoom = function() {
			return self.zoom;
		};
		self.setZoom = function(z) {
			self.zoom = utils.clamp(z, 0, 1);
			updateZoomedCellWidth();
			updateZoom();
			$(self).trigger(events.SET_ZOOM);
			return self.zoom;
		};
		var updateZoom = function() {
			// maps {1, ... , true_cell_width} to [0,1]
			self.zoom = (self.zoomed_cell_width-1)/(self.true_cell_width - 1);
		};
		var updateZoomedCellWidth = function() {
			// maps [0,1] to {1, ... , true_cell_width}
			self.zoomed_cell_width = Math.round(self.zoom*(self.true_cell_width-1) + 1);
		};
		self.increaseZoom = function() {
			self.zoomed_cell_width = utils.clamp(self.zoomed_cell_width+1, 1, self.true_cell_width);
			updateZoom();
			$(self).trigger(events.SET_ZOOM);
			return self.zoom;
		};
		self.decreaseZoom = function() {
			self.zoomed_cell_width = utils.clamp(self.zoomed_cell_width-1, 1, self.true_cell_width);
			updateZoom();
			$(self).trigger(events.SET_ZOOM);
			return self.zoom;
		};

		// Cell Width
		self.getFullCellWidth = function() {
			return self.true_cell_width;
		};
		self.getZoomedCellWidth = function() {
			return self.zoomed_cell_width;
		};

		// Cell Height
		self.getCellHeight = function(track_id) {
			return self.tracks[track_id].config.cell_height;
		};

		// Track Height
		self.getTrackHeight = function(track_id) {
			return self.tracks[track_id].config.track_height;
		};

		// Track Padding
		self.getTrackPadding = function(track_id) {
			return self.tracks[track_id].config.track_padding;
		};

		// Id Order
		self.getFilteredIdOrder = function(data_filter_fn, track_ids) {
			var tracks = track_ids || self.getTracks();
			return _.filter(self.id_order, function(id) {
				var d = _.map(tracks, function(track_id) {
					return self.getTrackDatum(track_id, id);
				});
				return data_filter_fn(d);
			});
		};
		self.getIdOrder = function() {
			return self.id_order;
		};
		self.getInvertedIdOrder = function() {
			return self.inverted_id_order;
		};
		self.getVisibleIdOrder = function() {
			return self.visible_id_order;
		};
		self.getVisibleInvertedIdOrder = function() {
			return self.visible_inverted_id_order;
		};
		var updateVisibleIdOrder = function() {
			self.visible_id_order = _.filter(self.id_order, function(id) {
				return !self.hidden_ids[id];
			});
			self.visible_inverted_id_order = utils.invert_array(self.visible_id_order);
			$(self).trigger(events.SET_VISIBLE_ID_ORDER);
		};
		self.setIdOrder = function(id_order) {
			self.id_order = id_order.slice();
			self.inverted_id_order = utils.invert_array(self.id_order);
			updateVisibleIdOrder();
			$(self).trigger(events.SET_ID_ORDER);
		};
		// Hide Ids
		self.hideIds = function(ids, clear_existing) {
			if (clear_existing) {
				self.hidden_ids = {};
			}
			_.each(ids, function(id) {
				self.hidden_ids[id] = true;
			});
			updateVisibleIdOrder();
		};
		self.showIds = function(ids) {
			if (!ids) {
				self.hidden_ids = {};
			} else {
				_.each(ids, function(id) {
					delete self.hidden_ids[id];
				});
			}
			updateVisibleIdOrder();
		};

		// Sorting
		self.getTopmostTrack = function() {
			return (self.track_groups[0].length > 0 ? self.track_groups[0][0] : self.track_groups[1][0]);
		};
		self.setTrackSortComparator = function(track_id, cmp) {
			self.tracks[track_id].config.sort_cmp = cmp;
		};
		self.getTrackSortComparator = function(track_id) {
			return self.tracks[track_id].config.sort_cmp;
		};
		self.getTrackSortDirection = function(track_id) {
			return self.sort_direction[track_id];
		};
		self.setTrackSortDirection = function(track_id, dir) {
			self.sort_direction[track_id] = dir;
			self.sort();
		};
		self.setTrackGroupSortOrder = function(order) {
			self.track_group_sort_order = order.slice();
		};
		self.getTrackGroupSortOrder = function() {
			return self.track_group_sort_order.slice();
		};
		self.getTrackSortOrder = function() {
			var ret = [];
			var track_groups = self.getTrackGroups();
			_.each(self.getTrackGroupSortOrder(), function(group_id) {
				ret = ret.concat(track_groups[group_id]);
			});
			return ret;
		};
		self.setSortConfig = function(config) {
			self.sort_config = config;
		};
		var sortById = function(desc) {
			var ret = _.sortBy(self.getIdOrder(), _.identity);
			if (desc) {
				ret.reverse();
			}
			self.setIdOrder(ret);
		};
		var sortByTrack = function() {
			var track_id_list = self.getTrackSortOrder();
			var cmp_list = _.map(track_id_list, function(track_id) { 
				return self.getTrackSortComparator(track_id);
			});
			var data = {};
			var id_order = self.getIdOrder();
			_.each(id_order, function(id) {
				data[id] = {};
				_.each(track_id_list, function(track_id) {
					data[id][track_id] = self.getTrackDatum(track_id, id);
				});
			});
			var lexicographically_ordered_cmp = function(id1,id2) {
				var cmp_result = 0;
				for (var i=0, _len = track_id_list.length; i<_len; i++) {
					var track_id = track_id_list[i];
					var cmp = cmp_list[i];
					var d1 = data[id1][track_id];
					var d2 = data[id2][track_id];
					var d1_undef = (typeof d1 === "undefined");
					var d2_undef = (typeof d2 === "undefined");
					if (!d1_undef && !d2_undef) {
						cmp_result = cmp(d1, d2);
					} else if (d1_undef && d2_undef) {
						cmp_result = 0;
					} else if (d1_undef) {
						cmp_result = 1;
					} else {
						cmp_result = -1;
					}
					if (isFinite(cmp_result)) {
						// reverse direction unless infinite, which is a signal that an NA is involved
						cmp_result *= self.sort_direction[track_id];
					}
					if (cmp_result !== 0) {
						break;
					}
				}
				return cmp_result;
			};
			self.setIdOrder(utils.stableSort(self.getIdOrder(), lexicographically_ordered_cmp));
		};
		self.sort = function() {
			var config = self.sort_config;
			if (config.type === 'track') {
				sortByTrack();
			} else if (config.type === 'id') {
				sortById(config.desc);
			}
		};

		// Track Creation/Destruction
		self.addTrack = function(config, group) {
			group = utils.ifndef(group, 1);
			var track_id = getTrackId();
			self.tracks[track_id] ={id: track_id, 
						data: [], 
						config: $.extend({}, defaultTrackConfig, config),
						id_data_map: {}};
			self.track_groups[group].push(track_id);
			self.sort_direction[track_id] = 1;

			$(self).trigger(events.ADD_TRACK, {track_id: track_id});
			return track_id;
		};
		self.removeTrack = function(track_id) {
			var track = self.tracks[track_id];
			delete self.tracks[track_id];
			delete self.sort_direction[track_id];

			var track_group = self.getContainingTrackGroup(track_id, true);
			if (!track_group) {
				return false;
			} else {
				var old_position = track_group.indexOf(track_id);
				track_group.splice(old_position, 1);

				$(self).trigger(events.REMOVE_TRACK, {track: track, track_id: track_id});
				return true;	
			}
		};

		// Track Ordering
		self.getTrackGroups = function(reference) {
			return (reference === true ? self.track_groups : $.extend(true, [], self.track_groups));			
		};
		self.getTracks = function() {
			return _.flatten(self.getTrackGroups());
		};
		self.getContainingTrackGroup = function(track_id, reference) {
			var group = false;
			_.find(self.track_groups, function(grp) {
				if (grp.indexOf(track_id) > -1) {
					group = grp;
					return true;
				}
				return false;
			});
			return (reference === true ? group : group.slice());
		};
		self.moveTrack = function(track_id, new_position) {
			var track_group = self.getContainingTrackGroup(track_id, true);
			if (!track_group) {
				return false;
			}
			var old_position = track_group.indexOf(track_id);
			new_position = utils.clamp(new_position, 0, track_group.length-1);
			track_group.splice(old_position, 1);
			track_group.splice(new_position, 0, track_id);
			var moved_tracks = track_group.slice(Math.min(old_position, new_position), Math.max(old_position, new_position) + 1);
			$(self).trigger(events.MOVE_TRACK, {moved_tracks: moved_tracks});
		};


		// Track Label
		self.getTrackLabel = function(track_id) {
			return self.tracks[track_id].config.label;
		};

		// Track Tooltip
		self.getTrackTooltip = function(track_id) {
			return self.tracks[track_id].config.tooltip;
		};
		self.setTrackTooltip = function(track_id, tooltip) {
			self.tracks[track_id].config.tooltip = tooltip;
		};

		// Track Data
		self.getTrackData = function(track_id) {
			return self.tracks[track_id].data;
		};
		self.setTrackData = function(track_id, data) {
			var id_accessor = self.getTrackDatumIdAccessor(track_id);

			self.tracks[track_id].data = data;

			var current_id_order = self.getIdOrder();
			var current_inverted_id_order = self.getInvertedIdOrder();
			_.each(_.map(data, id_accessor), function(id) {
				if (!(id in current_inverted_id_order)) {
					current_id_order.push(id);
				}
			});
			self.setIdOrder(current_id_order);
			
			self.tracks[track_id].id_data_map = {};
			var id_data_map = self.tracks[track_id].id_data_map;
			_.each(self.tracks[track_id].data, function(datum) {
				id_data_map[id_accessor(datum)] = datum;
			});
			$(self).trigger(events.SET_TRACK_DATA, {track_id: track_id});
		};
		self.getTrackDatum = function(track_id, datum_id) {
			return self.tracks[track_id].id_data_map[datum_id];
		};
		self.getTrackDatumDataKey = function(track_id) {
			return self.tracks[track_id].config.datum_data_key;
		};

		// Track Datum Id
		self.getTrackDatumIdAccessor = function(track_id) {
			var key = self.getTrackDatumIdKey(track_id);
			return function(d) {
				return d[key];
			};
		};
		self.getTrackDatumIdKey = function(track_id) {
			return self.tracks[track_id].config.datum_id_key;
		};
		self.setTrackDatumIdKey = function(track_id, key) {
			self.tracks[track_id].config.datum_id_key = key;
		};

		// Track info
		self.isTrackRemovable = function(track_id) {
			return self.tracks[track_id].config.removable;
		};
		self.isTrackSortDirectionChangable = function(track_id) {
			return self.tracks[track_id].config.sort_direction_changable;
		};

		// Clearing
		self.clearData = function() {
			_.each(self.getTracks(), function(track_id) {
				self.setTrackData(track_id, []);
			});
			self.setIdOrder([]);
		}
	}

	return { 
		CATEGORICAL_COLOR: RuleSet.CATEGORICAL_COLOR,
		GRADIENT_COLOR: RuleSet.GRADIENT_COLOR,
		GENETIC_ALTERATION: RuleSet.GENETIC_ALTERATION,
		BAR_CHART: RuleSet.BAR_CHART,
		create: function CreateOncoprint(container_selector_string, config) {
			config = $.extend({}, defaultOncoprintConfig, config || {});
			config = $.extend(config, hiddenOncoprintConfig);
			var oncoprint = new Oncoprint(config);
			var renderer = new OncoprintSVGRenderer(container_selector_string, oncoprint, {label_font: 'Arial', legend:config.legend});
			var ret = {
				onc_dev: oncoprint,
				ren_dev: renderer,
				addTrack: function(config, group) {
					var track_id = oncoprint.addTrack(config, group);
					return track_id;
				},
				removeTrack: function(track_id) {
					oncoprint.removeTrack(track_id);
				},
				moveTrack: function(track_id, position) {
					oncoprint.moveTrack(track_id, position);
				},
				setTrackDatumIdKey: function(track_id, key) {
					oncoprint.setTrackDatumIdKey(track_id, key);
				},
				setTrackData: function(track_id, data) {
					oncoprint.setTrackData(track_id, data);
				},
				setRuleSet: function(track_id, type, params) {
					renderer.setRuleSet(track_id, type, params);
				},
				useSameRuleSet: function(target_track_id, source_track_id) {
					renderer.useSameRuleSet(target_track_id, source_track_id);
				},
				toggleCellPadding: function() {
					oncoprint.toggleCellPadding();
				},
				toSVG: function() {
					return renderer.toSVG();
				},
				setTrackGroupSortOrder: function(order) {
					oncoprint.setTrackGroupSortOrder(order);
				},
				sort: function() {
					oncoprint.sort();
				},
				setSortConfig: function(config) {
					oncoprint.setSortConfig(config);
				},
				setIdOrder: function(id_order) {
					oncoprint.setIdOrder(id_order);
				},
				getTrackSortDirection: function(track_id) {
					return oncoprint.getTrackSortDirection(track_id);
				},
				setTrackSortDirection: function(track_id, dir) {
					oncoprint.setTrackSortDirection(track_id, dir);
				},
				setZoom: function(z) {
					return oncoprint.setZoom(z);
				},
				increaseZoom: function() {
					return oncoprint.increaseZoom();
				},
				decreaseZoom: function() {
					return oncoprint.decreaseZoom();
				},
				suppressRendering: function() {
					renderer.suppressRendering();
				},
				releaseRendering: function() {
					renderer.releaseRendering();
				},
				setLegendVisible: function(track_ids, visible) {
					renderer.setLegendVisible(track_ids, visible);
				},
				getFilteredIdOrder: function(data_filter_fn, track_ids) {
					return oncoprint.getFilteredIdOrder(data_filter_fn, track_ids);
				},
				getVisibleIdOrder: function() {
					return oncoprint.getVisibleIdOrder();
				},
				hideIds: function(ids) {
					oncoprint.hideIds(ids);
				},
				showIds: function(ids) {
					oncoprint.showIds(ids);
				},
				clearData: function() {
					oncoprint.clearData();
				},
				setTrackTooltip: function(track_id, tooltip) {
					oncoprint.setTrackTooltip(track_id, tooltip);
				}
			};
			$(oncoprint).on(events.MOVE_TRACK, function() {
				$(ret).trigger(events.MOVE_TRACK);
			});
			$(renderer).on(events.FINISHED_RENDERING, function() {
				$(ret).trigger(events.FINISHED_RENDERING);
			});
			$(oncoprint).on(events.REMOVE_TRACK, function(evt, data) {
				$(ret).trigger(events.REMOVE_TRACK, {track_id: data.track_id});
			});
			$(renderer).on(events.CONTENT_AREA_MOUSEENTER, function(evt, data) {
				$(ret).trigger(events.CONTENT_AREA_MOUSEENTER);
			});
			$(renderer).on(events.CONTENT_AREA_MOUSELEAVE, function(evt, data) {
				$(ret).trigger(events.CONTENT_AREA_MOUSELEAVE);
			});
			return ret;
		}
	};
})();
;
</script>
</body>
</html>
